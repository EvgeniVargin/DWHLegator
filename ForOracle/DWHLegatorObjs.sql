
set define off
spool DWHLegatorObjs.log

prompt
prompt Creating sequence TB_ANLT_2_GROUP_ID_SEQ
prompt ========================================
prompt
create sequence DM_SKB.TB_ANLT_2_GROUP_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 140
increment by 1
nocache;

prompt
prompt Creating sequence TB_APARAM_REGISTRY_ID_SEQ
prompt ===========================================
prompt
create sequence DM_SKB.TB_APARAM_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 85
increment by 1
nocache;

prompt
prompt Creating sequence TB_CALC_POOL_ID_SEQ
prompt =====================================
prompt
create sequence DM_SKB.TB_CALC_POOL_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 96
increment by 1
nocache;

prompt
prompt Creating sequence TB_CALC_2_CALC_ID_SEQ
prompt =======================================
prompt
create sequence DM_SKB.TB_CALC_2_CALC_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 75
increment by 1
nocache;

prompt
prompt Creating sequence TB_CLASS_REGISTRY_ID_SEQ
prompt ==========================================
prompt
create sequence DM_SKB.TB_CLASS_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 29
increment by 1
nocache;

prompt
prompt Creating sequence TB_DEPARTMENTS_ID_SEQ
prompt =======================================
prompt
create sequence DM_SKB.TB_DEPARTMENTS_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 10
increment by 1
nocache;

prompt
prompt Creating sequence TB_EMPLOYEES_ID_SEQ
prompt =====================================
prompt
create sequence DM_SKB.TB_EMPLOYEES_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 473
increment by 1
nocache;

prompt
prompt Creating sequence TB_EMP_TO_DEP_ID_SEQ
prompt ======================================
prompt
create sequence DM_SKB.TB_EMP_TO_DEP_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 20
increment by 1
nocache;

prompt
prompt Creating sequence TB_ENTITY_ID_SEQ
prompt ==================================
prompt
create sequence DM_SKB.TB_ENTITY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 148
increment by 1
nocache;

prompt
prompt Creating sequence TB_FCOLOR_REGISTRY_ID_SEQ
prompt ===========================================
prompt
create sequence DM_SKB.TB_FCOLOR_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 28
increment by 1
nocache;

prompt
prompt Creating sequence TB_FIELD_REGISTRY_ID_SEQ
prompt ==========================================
prompt
create sequence DM_SKB.TB_FIELD_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 713
increment by 1
nocache;

prompt
prompt Creating sequence TB_FLAGS_POOL_ID_SEQ
prompt ======================================
prompt
create sequence DM_SKB.TB_FLAGS_POOL_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 268
increment by 1
nocache;

prompt
prompt Creating sequence TB_FOPTION_REGISTRY_ID_SEQ
prompt ============================================
prompt
create sequence DM_SKB.TB_FOPTION_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 4569
increment by 1
nocache;

prompt
prompt Creating sequence TB_FORM_REGISTRY_ID_SEQ
prompt =========================================
prompt
create sequence DM_SKB.TB_FORM_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 62
increment by 1
nocache;

prompt
prompt Creating sequence TB_FPARAM_REGISTRY_ID_SEQ
prompt ===========================================
prompt
create sequence DM_SKB.TB_FPARAM_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 201
increment by 1
nocache;

prompt
prompt Creating sequence TB_LABEL_REGISTRY_ID_SEQ
prompt ==========================================
prompt
create sequence DM_SKB.TB_LABEL_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 65
increment by 1
nocache;

prompt
prompt Creating sequence TB_LABROLE_REGISTRY_ID_SEQ
prompt ============================================
prompt
create sequence DM_SKB.TB_LABROLE_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 22
increment by 1
nocache;

prompt
prompt Creating sequence TB_MNG_TASK_ID_SEQ
prompt ====================================
prompt
create sequence DM_SKB.TB_MNG_TASK_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 11
increment by 1
nocache;

prompt
prompt Creating sequence TB_PLSQL_REGISTRY_ID_SEQ
prompt ==========================================
prompt
create sequence DM_SKB.TB_PLSQL_REGISTRY_ID_SEQ
minvalue 1
maxvalue 9999999999999999999999999
start with 1
increment by 1
nocache;

prompt
prompt Creating sequence TB_QACTION_REGISTRY_ID_SEQ
prompt ============================================
prompt
create sequence DM_SKB.TB_QACTION_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 30
increment by 1
nocache;

prompt
prompt Creating sequence TB_QPARAM_REGISTRY_ID_SEQ
prompt ===========================================
prompt
create sequence DM_SKB.TB_QPARAM_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 74
increment by 1
nocache;

prompt
prompt Creating sequence TB_QROLE_REGISTRY_ID_SEQ
prompt ==========================================
prompt
create sequence DM_SKB.TB_QROLE_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 16
increment by 1
nocache;

prompt
prompt Creating sequence TB_QUERY_REGISTRY_ID_SEQ
prompt ==========================================
prompt
create sequence DM_SKB.TB_QUERY_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 152
increment by 1
nocache;

prompt
prompt Creating sequence TB_REPFORM_REGISTRY_ID_SEQ
prompt ============================================
prompt
create sequence DM_SKB.TB_REPFORM_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 13
increment by 1
nocache;

prompt
prompt Creating sequence TB_ROLE_REGISTRY_ID_SEQ
prompt =========================================
prompt
create sequence DM_SKB.TB_ROLE_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 12
increment by 1
nocache;

prompt
prompt Creating sequence TB_SEQ_REGISTRY_ID_SEQ
prompt ========================================
prompt
create sequence DM_SKB.TB_SEQ_REGISTRY_ID_SEQ
minvalue 1
maxvalue 9999999999999999999999999
start with 46
increment by 1
nocache;

prompt
prompt Creating sequence TB_SIGNS_ANLT_ID_SEQ
prompt ======================================
prompt
create sequence DM_SKB.TB_SIGNS_ANLT_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 127
increment by 1
nocache;

prompt
prompt Creating sequence TB_SIGNS_ANLT_SPEC_ID_SEQ
prompt ===========================================
prompt
create sequence DM_SKB.TB_SIGNS_ANLT_SPEC_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 229460
increment by 1
nocache;

prompt
prompt Creating sequence TB_SIGNS_CALC_STAT_ID_SEQ
prompt ===========================================
prompt
create sequence DM_SKB.TB_SIGNS_CALC_STAT_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 3053108
increment by 1
nocache;

prompt
prompt Creating sequence TB_SIGNS_GROUP_ID_SEQ
prompt =======================================
prompt
create sequence DM_SKB.TB_SIGNS_GROUP_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 73
increment by 1
nocache;

prompt
prompt Creating sequence TB_SIGNS_HISTORY_ID_SEQ
prompt =========================================
prompt
create sequence DM_SKB.TB_SIGNS_HISTORY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 22006
increment by 1
nocache;

prompt
prompt Creating sequence TB_SIGNS_JOB_ID_SEQ
prompt =====================================
prompt
create sequence DM_SKB.TB_SIGNS_JOB_ID_SEQ
minvalue 1
maxvalue 9999999
start with 79812
increment by 1
nocache
cycle;

prompt
prompt Creating sequence TB_SIGNS_LOG_ID_SEQ
prompt =====================================
prompt
create sequence DM_SKB.TB_SIGNS_LOG_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 7790458
increment by 1
nocache;

prompt
prompt Creating sequence TB_SIGNS_POOL_ID_SEQ
prompt ======================================
prompt
create sequence DM_SKB.TB_SIGNS_POOL_ID_SEQ
minvalue 1
maxvalue 9999
start with 975
increment by 1
nocache;

prompt
prompt Creating sequence TB_SIGNS_2_GROUP_ID_SEQ
prompt =========================================
prompt
create sequence DM_SKB.TB_SIGNS_2_GROUP_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 1098
increment by 1
nocache;

prompt
prompt Creating sequence TB_SIGN_2_ANLT_ID_SEQ
prompt =======================================
prompt
create sequence DM_SKB.TB_SIGN_2_ANLT_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 677
increment by 1
nocache;

prompt
prompt Creating sequence TB_SIGN_2_SIGN_ID_SEQ
prompt =======================================
prompt
create sequence DM_SKB.TB_SIGN_2_SIGN_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 1272
increment by 1
nocache;

prompt
prompt Creating sequence TB_TABLEKEY_REGISTRY_ID_SEQ
prompt =============================================
prompt
create sequence DM_SKB.TB_TABLEKEY_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 166
increment by 1
nocache;

prompt
prompt Creating sequence TB_TABLES_REGISTRY_ID_SEQ
prompt ===========================================
prompt
create sequence DM_SKB.TB_TABLES_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 48
increment by 1
nocache;

prompt
prompt Creating sequence TB_TATTR_ID_SEQ
prompt =================================
prompt
create sequence DM_SKB.TB_TATTR_ID_SEQ
minvalue 1
maxvalue 9999999999999999999999999
start with 1
increment by 1
nocache;

prompt
prompt Creating sequence TB_TFIELD_REGISTRY_ID_SEQ
prompt ===========================================
prompt
create sequence DM_SKB.TB_TFIELD_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 343
increment by 1
nocache;

prompt
prompt Creating sequence TB_TFOPTION_REGISTRY_ID_SEQ
prompt =============================================
prompt
create sequence DM_SKB.TB_TFOPTION_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 997
increment by 1
nocache;

prompt
prompt Creating sequence TB_UROLE_REGISTRY_ID_SEQ
prompt ==========================================
prompt
create sequence DM_SKB.TB_UROLE_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 1477
increment by 1
nocache;

prompt
prompt Creating sequence TB_USER_REGISTRY_ID_SEQ
prompt =========================================
prompt
create sequence DM_SKB.TB_USER_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 380
increment by 1
nocache;

prompt
prompt Creating sequence TB_VARIABLE_REGISTRY_ID_SEQ
prompt =============================================
prompt
create sequence DM_SKB.TB_VARIABLE_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 15
increment by 1
nocache;

prompt
prompt Creating sequence TB_VERSION_REGISTRY_ID_SEQ
prompt ============================================
prompt
create sequence DM_SKB.TB_VERSION_REGISTRY_ID_SEQ
minvalue 1
maxvalue 999999999999
start with 12
increment by 1
nocache;

prompt
prompt Creating sequence T_LOG_ID_SEQ
prompt ==============================
prompt
create sequence DM_SKB.T_LOG_ID_SEQ
minvalue 1
maxvalue 9999999999999999999999999999
start with 4627288
increment by 1
nocache;

prompt
prompt Creating package PKG_ETL_CTR_SIGNS
prompt ==================================
prompt
CREATE OR REPLACE PACKAGE DM_SKB.pkg_etl_ctr_signs
/*
КРАТКАЯ ИНСТРУКЦИЯ ПО ДОБАВЛЕНИЮ НОВОГО ПОКАЗАТЕЛЯ

1. Добавить новый показатель в таблицу  dm_skb.tb_signs_pool по аналогии с предыдущими.

2. Расчитать новый показатель (примеры PLSQL - блоков для запуска расчета):
   -- сначала для одной даты (только при таком расчете добавляется партиция с показателем)
   BEGIN 
     dm_clant.pkg_etl_ctr_signs.load(to_date('31.05.2016','DD.MM.YYYY'),'ACCOUNT_SUM_COLLATERAL'); 
   END;
   -- затем за период (если это необходимо)
   BEGIN 
     dm_clant.pkg_etl_ctr_signs.mass_load(to_date('01.05.2016','DD.MM.YYYY'),to_date('31.05.2016','DD.MM.YYYY'),'ACCOUNT_SUM_COLLATERAL'); 
   END;

3. Enjoy.
*/
  IS
    TYPE recCtrSignsH IS RECORD
      ( start_date           DATE,
        end_date             DATE,
        effective_start      DATE,
        effective_end        DATE,
        contract_sid         NUMBER,
        source_system_id     NUMBER,
        abs_department_sid   NUMBER,
        ctr_idx              VARCHAR2(255),
        ctr_val              VARCHAR2(4000),
        client_sid           NUMBER
      );
    TYPE tabCtrSignsH IS TABLE OF recCtrSignsH;
    
    TYPE recCredits IS RECORD
      (
       as_of_date DATE
      ,contract_gid NUMBER
      ,source_system_id NUMBER
      ,uc_id NUMBER
      ,overdue_principal NUMBER
      ,overdue_principal_eqv NUMBER
      ,overdue_interest NUMBER
      ,overdue_interest_eqv NUMBER
      ,account_sum_91311 NUMBER
      ,account_num_91311 VARCHAR2(4000)
      ,account_name_91311 VARCHAR2(4000)
      ,account_sum_91312 NUMBER
      ,account_num_91312 VARCHAR2(4000)
      ,account_name_91312 VARCHAR2(4000)
      ,account_sum_91313 NUMBER
      ,account_num_91313 VARCHAR2(4000)
      ,account_name_91313 VARCHAR2(4000)
      ,account_sum_91314 NUMBER
      ,account_num_91314 VARCHAR2(4000)
      ,account_name_91314 VARCHAR2(4000)
      ,account_sum_91414 NUMBER
      ,account_num_91414 VARCHAR2(4000)
      ,account_name_91414 VARCHAR2(4000)
      ,creditline_id NUMBER
      ,creditline_no VARCHAR2(4000)
      ,credit_state VARCHAR2(4000)
      ,credit_status VARCHAR2(4000)
      ,interest_rate_open_date NUMBER
      ,reg_region VARCHAR2(4000)
      ,cnt_contr_for_client NUMBER
      ,commiss_monthly NUMBER
      ,interest_rate_acgn2 NUMBER
      ,pr_transh NUMBER
      ,main_payment NUMBER
      ,prc_payment NUMBER
      ,okved VARCHAR2(4000)
      ,business VARCHAR2(4000)
      ,sum_first_turn NUMBER
      ,date_first_turn DATE
      ,off_date_vnb DATE
      ,prc_main_vnb_amount NUMBER
      ,prc_debt_vnb_amount NUMBER
      ,unused_credit_limit_eqv NUMBER
      ,unused_credit_limit NUMBER
      ,pr_defolt_client NUMBER
      ,pr_problem_client NUMBER
      ,credit_state_ul VARCHAR2(4000)
      ,provis_percent NUMBER
      ,provis_percent_client NUMBER
      ,overdue_client NUMBER
      ,claim_gid NUMBER
      ,account_sum_91802 NUMBER
      ,account_sum_91803 NUMBER
      ,account_sum_91704 NUMBER
      ,account_sum_91604 NUMBER
      ,account_sum_91604_client NUMBER
      ,open_abs_dep_code VARCHAR2(4000)
      ,open_abs_dep_name VARCHAR2(4000)
      ,serv_department_code VARCHAR2(4000)
      ,serv_department_name VARCHAR2(4000)
      ,serv_department_city VARCHAR2(4000)
      ,serv_department_region VARCHAR2(4000)
      ,serv_dep_branch_name VARCHAR2(4000)
      ,serv_dep_branch_code VARCHAR2(4000)
      ,open_dep_branch_name VARCHAR2(4000)
      ,open_dep_branch_code VARCHAR2(4000)
      ,adv_account VARCHAR2(4000)
      ,type_restruct VARCHAR2(4000)
      ,rate_first_day NUMBER
      ,sum_contr_for_client NUMBER
      ,cl_ogrn VARCHAR2(4000)
      ,pr_annuitet_pay NUMBER
      ,pr_differ_pay NUMBER
      ,over_principal NUMBER
      ,cnt_pays_od_on_debt NUMBER
      ,amount_eqv NUMBER
      ,amount NUMBER
      ,prc_to_main NUMBER
      ,amount_debt NUMBER
      ,amount_pay_eqv NUMBER
      ,fee_eqv NUMBER
      ,cnt_overdue_client NUMBER
      ,interest NUMBER
      ,interest_eqv NUMBER
      ,sum_pay_od_main NUMBER
      ,sum_pay_od_debt NUMBER
      ,max_sum_overdue_client NUMBER
      ,max_cnt_day_overdue_client NUMBER
      ,max_fifo_for_client NUMBER
      );
    TYPE tabCredits IS TABLE OF recCredits;

-- Витрина ЮЛ за дату
FUNCTION GetCredits (InDate IN DATE) RETURN tabCredits PIPELINED;

-- Служебные процедуры
PROCEDURE compress_hist_table(inTable IN VARCHAR2, vOut OUT VARCHAR2);

--  ******************  КОНЕЧНЫЕ ПРОЦЕДУРЫ ДЛЯ ЗАПУСКА РАСЧЕТОВ *****************
--  ******************  ДЛЯ ИСПОЛЬЗОВАНИЯ В РАБОЧЕМ ПОРЯДКЕ *********************
PROCEDURE load_creds_new(inBegDate IN DATE,inEndDate IN DATE);
-- Загрузка пула привязок счетов к договорам (без учета периода действия, все привязки, какие были когда-либо)
PROCEDURE load_a2c;
-- Загрузка пула закрытых договоров за дату
--PROCEDURE load_creds_closed(inBegDate IN DATE, inEndDate IN DATE);
-- Массовая загрузка по mass_sql
PROCEDURE mass_sql_load(inBegDate IN DATE,inEndDate IN DATE,inSign IN VARCHAR2,inForceTruncPart IN BOOLEAN DEFAULT FALSE);
-- параллельная заливка указанных показателей за одну дату
-- если параметр inSign не указан, то параллельная заливка ВСЕХ показателей за одну дату
-- пример параметра inSign:  'ACCOUNT_CUM_COLATERAL,ACCOUNT_SUM_61312,ACOUNT_SUM_91414'
-- *******************************************************************************
-- *******************************************************************************

-- Процедуры для массового расчета FCT -> HIST показателей
--PROCEDURE val_fct_to_hist(inBegDate IN DATE, inEndDate IN DATE,inFromSign IN VARCHAR2,inToSign IN VARCHAR2);

-- Процедура остановки jobs для task
PROCEDURE stop_task_jobs(task_name IN VARCHAR2);
-- Процедура исправления максимального значения effective_end на 31.12.5999 
-- по историческому показателю
--PROCEDURE tb_ctr_signs_upd_eff_end(v_ctr_idx IN VARCHAR2);
PROCEDURE load_scoring(inBegDate DATE,inEndDate DATE);

END pkg_etl_ctr_signs;
/

prompt
prompt Creating package PKG_ETL_SIGNS
prompt ==============================
prompt
CREATE OR REPLACE PACKAGE DM_SKB.pkg_etl_signs
  IS
    TYPE recStr IS RECORD (ord NUMBER,str VARCHAR2(4000));
    TYPE tabStr IS TABLE OF recStr;
    TYPE TRec IS RECORD
      (obj_gid NUMBER
      ,source_system_id NUMBER
      ,sign_name VARCHAR2(256)
      ,sign_val VARCHAR2(4000));
    TYPE TTab IS TABLE OF TRec;
    TYPE TRecMass IS RECORD
      (effective_start DATE
      ,effective_end DATE
      ,obj_gid NUMBER
      ,source_system_id NUMBER
      ,sign_name VARCHAR2(256)
      ,sign_val VARCHAR2(4000));
    TYPE TTabMass IS TABLE OF TRecMass;
    TYPE TRecCHBuilder IS RECORD
      (Id VARCHAR2(256),Parent_id VARCHAR2(256),Unit VARCHAR2(256),Params VARCHAR2(4000),Skip NUMBER);
    TYPE TTabCHBuilder IS TABLE OF TRecCHBuilder;
    TYPE TRecTree IS RECORD (Id VARCHAR2(4000),ParentId VARCHAR2(4000));
    TYPE TTabTree IS TABLE OF TRecTree;
    TYPE TRecAnltSpecImp IS RECORD
      (val VARCHAR2(4000)
      ,parent_val VARCHAR2(4000)
      ,name VARCHAR2(4000)
      ,condition CLOB/*VARCHAR2(32700)*/);
    TYPE TTabAnltSpecImp IS TABLE OF TRecAnltSpecImp;
    TYPE TRecLabels IS RECORD
      (id NUMBER,parent_id NUMBER,caption VARCHAR2(4000), ord NUMBER, form_id NUMBER);
    TYPE TTabLabels IS TABLE OF TRecLabels;
    TYPE TRecReports IS RECORD (id NUMBER,query_name VARCHAR2(256), query_descr VARCHAR2(4000), ord NUMBER);
    TYPE TTabReports IS TABLE OF TRecReports;

  FUNCTION GetLabels(inOSUser VARCHAR2) RETURN TTabLabels PIPELINED;
  FUNCTION GetReports(inOSUser VARCHAR2,inFormID NUMBER) RETURN TTabReports PIPELINED;
  PROCEDURE pr_log_write(inUnit IN VARCHAR2,inMessage IN VARCHAR2);
  PROCEDURE pr_stat_write(inSignName IN VARCHAR2,inAnltCode IN VARCHAR2,inSec NUMBER,inAction VARCHAR2);
  FUNCTION get_ti_as_hms (inInterval IN NUMBER /*интервал в днях*/) RETURN VARCHAR2;
  FUNCTION parse_str(inStr VARCHAR2,inSeparator IN VARCHAR2) RETURN tabStr PIPELINED;
  FUNCTION isEqual(n1 IN NUMBER,n2 IN NUMBER) RETURN NUMBER;
  FUNCTION isEqual(v1 IN VARCHAR2,v2 IN VARCHAR2) RETURN NUMBER;
  FUNCTION isEqual(d1 IN DATE,d2 IN DATE) RETURN NUMBER;
  FUNCTION isEqual(c1 IN CLOB,c2 IN CLOB) RETURN NUMBER;
  FUNCTION DBLinkReady(inDBLinkName VARCHAR2) RETURN BOOLEAN;
  FUNCTION GetConditionResult(inCondition IN CLOB) RETURN NUMBER;
  PROCEDURE mass_load_parallel_by_date_pe(inBeg IN DATE, inEnd IN DATE, inUnit IN VARCHAR2 DEFAULT NULL
    ,inParams IN VARCHAR2 DEFAULT NULL);
  PROCEDURE mass_load_parallel_by_month (inBegDate IN DATE, inEndDate IN DATE, inProcedure IN VARCHAR2
    ,inParams VARCHAR2 DEFAULT NULL);
  PROCEDURE mass_load_parallel_by_ydate_pe
    (inBegDate IN DATE, inEndDate IN DATE, inUnit IN VARCHAR2
    ,inParams IN VARCHAR2 DEFAULT NULL
    ,inLastDay BOOLEAN DEFAULT TRUE
    ,inMonthlyDay VARCHAR2 DEFAULT NULL);
  PROCEDURE mass_load_parallel_by_year
    (inBegDate IN DATE, inEndDate IN DATE, inProcedure IN VARCHAR2
    ,inParams VARCHAR2 DEFAULT NULL
    ,inLastDay BOOLEAN DEFAULT TRUE
    ,inMonthlyDay VARCHAR2 DEFAULT NULL
    ,inYearParallel BOOLEAN DEFAULT FALSE
    ,inHeadJobName IN VARCHAR2 DEFAULT NULL);
  PROCEDURE MyExecute(inScript IN VARCHAR2);
  PROCEDURE AnyExecute(inScript IN CLOB,inParams IN VARCHAR2 DEFAULT NULL);
  PROCEDURE prepare_entity(inID IN NUMBER,outRes OUT CLOB);
  PROCEDURE prepare_log_table(outRes OUT VARCHAR2);
  FUNCTION get_sign(inSign IN VARCHAR2,inDate IN DATE, inSQL IN VARCHAR2 DEFAULT NULL) RETURN TTab PIPELINED;
  FUNCTION get_sign_anlt(inSign IN VARCHAR2,inDate IN DATE, inAnltCode IN VARCHAR2, inReverse NUMBER DEFAULT 0) RETURN TTab PIPELINED;
  FUNCTION get_anlt_spec_imp(inDate IN DATE, inAnltCode IN VARCHAR2) RETURN TTabAnltSpecImp PIPELINED;
  FUNCTION get_sign_mass(inSign IN VARCHAR2,inDate IN DATE) RETURN TTabMass PIPELINED;
  -- Подготовка субпартиций в таблицах
  FUNCTION CheckSubpartition(inBegDate IN DATE,inEndDate IN DATE,inSign IN VARCHAR2,inAnltCode IN VARCHAR2) RETURN VARCHAR2;
  PROCEDURE CheckSubpartition(inBegDate IN DATE,inEndDate IN DATE,inSign IN VARCHAR2,inAnltCode IN VARCHAR2);
  FUNCTION CompressSubpartition(inDate IN DATE,inSign IN VARCHAR2,inAnltCode IN VARCHAR2) RETURN VARCHAR2;
  PROCEDURE CompressSubpartition(inBegDate IN DATE,inEndDate IN DATE,inSign IN VARCHAR2,inAnltCode IN VARCHAR2);
  --
  PROCEDURE tb_load_daily(inBegDate IN DATE,inEndDate IN DATE,inSign VARCHAR2,inAnltCode IN VARCHAR2);
  PROCEDURE ptb_load_daily(inBegDate IN DATE,inEndDate IN DATE,inSign VARCHAR2,inAnltCode IN VARCHAR2);
  PROCEDURE load_sign(inBegDate IN DATE,inEndDate IN DATE,inSign IN VARCHAR2,inAnltCode IN VARCHAR2,inPrepareSegments NUMBER);
  --  ******************  КОНЕЧНЫЕ ПРОЦЕДУРЫ ДЛЯ ЗАПУСКА РАСЧЕТОВ *****************
  --  ******************  ДЛЯ ИСПОЛЬЗОВАНИЯ В РАБОЧЕМ ПОРЯДКЕ *********************
  -- параллельная заливка указанных показателей за одну дату
  -- если параметр inSign не указан, то параллельная заливка ВСЕХ показателей за одну дату
  -- пример параметра inSign:  'ACCOUNT_CUM_COLATERAL,ACCOUNT_SUM_61312,ACOUNT_SUM_91414'
  PROCEDURE load_new(inSQL IN CLOB,inJobName IN VARCHAR2 DEFAULT NULL,inCalcPoolId NUMBER DEFAULT NULL);
  PROCEDURE load (inBegDate IN DATE,inEndDate IN DATE);
  -- *******************************************************************************
  -- *******************************************************************************
  -- Массовая загрузка показателя
  PROCEDURE mass_load(inBegDate IN DATE,inEndDate IN DATE,inSign IN VARCHAR2,inAnltCode IN VARCHAR2,inPrepareSegments NUMBER);
  -- Склеивание периодов в исторических показателях
  --(необходимо например после "раздельно - массовой" загрузки исторического показателя)
  PROCEDURE sign_gluing(inSign IN VARCHAR2,inAnltCode IN VARCHAR2,inMask IN VARCHAR2 DEFAULT '111');
  PROCEDURE tmp_load_prev(inBegDate IN DATE,inEndDate IN DATE,inSign IN VARCHAR2,inAnltCode IN VARCHAR2);
  PROCEDURE tmp_load_daily(inBegDate IN DATE,inEndDate IN DATE,inSign VARCHAR2,inAnltCode IN VARCHAR2);
  PROCEDURE tb_upd_eff_end(inSign IN VARCHAR2,inAnltCode IN VARCHAR2,inDate IN DATE DEFAULT NULL);
  PROCEDURE tb_load_mass(inBegDate IN DATE,inEndDate IN DATE,inSign IN VARCHAR2,inAnltCode IN VARCHAR2
    ,inMask IN VARCHAR2 DEFAULT '111111');
  /***************************************************************
   * Расшифровка маски:                                          *
   *  1-й символ: Предварительная загрузка 1-х чисел месяца      *
   *              в промежуточную тиаблицу                       *
   *  2-й символ: Прогрузка данных в промежуточной таблице       *
   *              за каждое число месяца, начиная со 2-го        *
   *  3-й символ: Очистка целевой партиции (если 0 то происходит *
   *              подгонка effective_start и effective_end       *
   *              по началу и окончанию периода)                 *
   *  4-й символ: Загрузка данных в целевую таблицу              *
   *  5-й символ: Сжатие данных и перестроение индексов в        *
   *              целевой таблице                                *
   *  6-й символ: Сбор статистики по целевой таблице             *
   ***************************************************************/
  PROCEDURE SignExtProcessing(inSign IN VARCHAR2,inDate IN DATE);
  FUNCTION get_empty_sign_id RETURN NUMBER;
  FUNCTION DropSignPartitions(inSign IN VARCHAR2) RETURN VARCHAR2;
  PROCEDURE drop_sign(inSign IN VARCHAR2,outRes OUT VARCHAR2);
  FUNCTION GetTreeList(inSQL IN CLOB) RETURN TTabTree PIPELINED;
  FUNCTION GetChainList(inSQL IN CLOB) RETURN TTabCHBuilder PIPELINED;
  FUNCTION GetTreeSQL(inFullSQL IN CLOB
                   ,inStartSQL IN CLOB
                   ,inIncludeChilds IN INTEGER DEFAULT 0)
    RETURN CLOB;
  FUNCTION ChainBuilder(/*inID VARCHAR2,*/inSQL CLOB) RETURN VARCHAR2;
  FUNCTION ChainStarter(inChainName IN VARCHAR2,inHeadJobName IN VARCHAR2 DEFAULT NULL) RETURN VARCHAR2;
  PROCEDURE ChainKiller(inChainName VARCHAR2);
  PROCEDURE calc(inBegDate IN DATE,inEndDate IN DATE);
  PROCEDURE CalcSignsByGroup(inBegDate IN DATE,inEndDate IN DATE,inGroupID IN NUMBER,inJobName VARCHAR2);
  PROCEDURE CalcSignsByStar(inBegDate IN DATE,inEndDate IN DATE,inGroupID IN NUMBER,inJobName VARCHAR2);
  PROCEDURE CalcAnltByGroup(inBegDate IN DATE,inEndDate IN DATE,inGroupID IN NUMBER,inJobName VARCHAR2);
  PROCEDURE CalcAnltByStar(inBegDate IN DATE,inEndDate IN DATE,inGroupID IN NUMBER,inJobName VARCHAR2);
  /*********  ИМПОРТ - ЭКСПОРТ *************/
  FUNCTION AnltSpecImpGetCondition(inSignName VARCHAR2,inIds VARCHAR2 DEFAULT NULL,inProduct IN NUMBER DEFAULT 0) RETURN CLOB; -- 0 - показатель; 1 - продукт
  PROCEDURE AnltSpecImport(inDate IN DATE,inAnltCode IN VARCHAR2);
 /******  ЗВЁЗДЫ И ВСЁ ЧТО С НИМИ СВЯЗАНО ***************************/
  FUNCTION  GetAnltLineSQL(inSQL IN CLOB,inIDName IN VARCHAR2
    ,inPIDName IN VARCHAR2,inName IN VARCHAR2,inValue IN VARCHAR2) RETURN CLOB;
  PROCEDURE StarPrepareDim(inDate IN DATE,inGroupID IN NUMBER,inEntityID IN NUMBER);
  PROCEDURE StarPrepareFct(inDate IN DATE,inGroupID IN NUMBER);
  PROCEDURE StarFctOnDate(inDate IN DATE,inGroupID IN NUMBER,inEntityID IN NUMBER); -- таблица фактов за дату
  PROCEDURE StarDimOnDate(inDate IN DATE,inGroupID IN NUMBER,inEntityID IN NUMBER); -- таблица измерения за дату
  PROCEDURE StarAnltOnDate(inDate IN DATE,inGroupID IN NUMBER,inAnltAlias IN VARCHAR2); -- таблица измерения - аналитики за дату

  PROCEDURE StarPrepare(inBegDate IN DATE,inEndDate IN DATE,inGroupID IN NUMBER); -- подготовка таблиц за период
  PROCEDURE StarClear(inBegDate IN DATE,inEndDate IN DATE,inGroupID IN NUMBER); -- очистка звезды за период
  PROCEDURE
  /************************************
   Описание маски (0 - не выполнять, 1 - выполнять):
   1-й символ - предварительный пересчет всех показателей по кубу
   2-й символ - предварительный пересчет всех аналитик по кубу
  ************************************/
    StarExpand(inBegDate IN DATE,inEndDate IN DATE,inGroupID IN NUMBER,inMask VARCHAR2 DEFAULT '00',inCalcPoolId NUMBER DEFAULT NULL); -- разворачивание звезды за период
  PROCEDURE StarCompress(inBegDate IN DATE,inEndDate IN DATE,inGroupID IN NUMBER); -- сжатие звезды за период
  PROCEDURE StarDropOldParts(inDate IN DATE,inGroupID IN NUMBER);
  /********************************************************************/
  /************************ Техническое обслуживание ******************/
  PROCEDURE HistTableService(inTableName IN VARCHAR2,inMask IN VARCHAR2,inSign IN VARCHAR2 DEFAULT NULL);
  /***************************************************************
   * Расшифровка маски:                                          *
   *  1-й символ: Сжатие данных                                  *
   *  2-й символ: Перестроение индексов                          *
   *  3-й символ: Сбор статистики                                *
   ***************************************************************/
  /********************************************************************/
  FUNCTION GetVarCLOBValue(inVarName VARCHAR2) RETURN CLOB DETERMINISTIC;
  FUNCTION GetVarValue(inVarName VARCHAR2) RETURN VARCHAR2 DETERMINISTIC;
  /********************************************************************/
  FUNCTION call_hist(inTable IN VARCHAR2, inID IN VARCHAR2,inAction VARCHAR2) RETURN VARCHAR2;
  FUNCTION CanHaveHistory(inTable IN VARCHAR2) RETURN BOOLEAN;
  PROCEDURE SetFlag(inName IN VARCHAR2,inDate IN DATE,inVal IN VARCHAR2 DEFAULT NULL,inAction NUMBER DEFAULT 1); -- 1 - UPSERT, 0 - DELETE
  FUNCTION GetFlag(inFlagName IN VARCHAR2, inDate IN DATE) RETURN VARCHAR2;
  -- Грубый анализатор объектов на наличие персональных данных
  FUNCTION PDCA(inObj IN VARCHAR2, inAnalyzeContent IN NUMBER DEFAULT 0) RETURN VARCHAR2;
  FUNCTION SQLasHTML(inSQL IN CLOB,inColNames IN VARCHAR2,inColAliases IN VARCHAR2,inStyle IN VARCHAR2 DEFAULT NULL,inShowLogo BOOLEAN DEFAULT FALSE,inTabHeader VARCHAR2 DEFAULT NULL) RETURN CLOB;
END pkg_etl_signs;
/

prompt
prompt Creating package PKG_REP_AGGR
prompt =============================
prompt
CREATE OR REPLACE PACKAGE DM_SKB.pkg_rep_aggr
AS
TYPE recGetPtbBbalanceFact IS RECORD
  (as_of_date DATE,
   dim_key skb_ecc.ecc_rule.dim_key%TYPE,
   rule_id skb_ecc.ecc_rule.rule_id%TYPE,
   abs_department_id skb_ecc.ecc_dm_1.abs_department_id%TYPE,
   cur_id skb_ecc.ecc_dm_1.cur_id%TYPE,
   product_id skb_ecc.ecc_dimension_item.dimension_item_id%TYPE,
   dim2_id skb_ecc.ecc_dimension_item.dimension_item_id%TYPE,
   val NUMBER,
   val_prev NUMBER,
   val_mb NUMBER,
   source_system_id NUMBER
  );

TYPE tabGetPtbBbalanceFact IS TABLE OF recGetPtbBbalanceFact;

TYPE recGetPrevAggForHier IS RECORD
  (hierarchy_id skb_ecc.ecc_hierarchy.hierarchy_id%TYPE,
   product_id skb_ecc.ecc_dimension_item_hier.dimension_item_id%TYPE,
   di_name skb_ecc.ecc_dimension_item.name%TYPE,
   parent_product_id skb_ecc.ecc_dimension_item_hier.parent_dimension_item_id%TYPE,
   dim2 skb_ecc.ecc_dimension_item.dimension_item_id%TYPE,
   abs_department_id skb_ecc.ecc_dm_1.abs_department_id%TYPE,
   cur_id skb_ecc.ecc_dm_1.cur_id%TYPE,
   as_of_date DATE,
   val NUMBER,
   distance INTEGER,
   isleaf INTEGER
  );

TYPE tabGetPrevAggForHier IS TABLE OF recGetPrevAggForHier;

-- Получение данных
FUNCTION get_ptb_bbalance_fact (inDate DATE) RETURN tabGetPtbBbalanceFact PIPELINED;

-- Измерения
PROCEDURE tb_ref_client_actual_all;
PROCEDURE tb_ref_client_actual;
PROCEDURE tb_ref_account;
PROCEDURE tb_rep_uclient_fact;
PROCEDURE mv_rep_product_dim;
--PROCEDURE mv_rep_department_line_dim;
PROCEDURE mv_ref_city;
-- Факты
PROCEDURE ptb_bbalance_fact (inBegDt IN DATE, inEndDt IN DATE);
PROCEDURE tb_3card_ibso_d_fact (inBegDt IN DATE, inEndDt IN DATE);
-- Процедуры запуска загрузки
PROCEDURE load (inBeg IN DATE, inEnd IN DATE, inUnit IN VARCHAR2 DEFAULT NULL);

END pkg_rep_aggr;
/

prompt
prompt Creating package PKG_SKB_PARSER
prompt ===============================
prompt
CREATE OR REPLACE PACKAGE DM_SKB.pkg_skb_parser
IS
TYPE rec_ldv_fin_datal IS RECORD
  (v1 VARCHAR2(255)
  ,v2 VARCHAR2(4000)
  );
TYPE tab_ldv_fin_datal IS TABLE OF rec_ldv_fin_datal;
TYPE recStr IS RECORD (Str VARCHAR2(4000));
TYPE tabStr IS TABLE OF recStr;

FUNCTION parse_ldv_fin_datal (inStr LONG) RETURN tab_ldv_fin_datal PIPELINED;
FUNCTION parse_str(inStr VARCHAR2,inSeparator IN VARCHAR2) RETURN tabStr PIPELINED;

END pkg_skb_parser;
/

prompt
prompt Creating function GET_OSUSER
prompt ============================
prompt
CREATE OR REPLACE FUNCTION DM_SKB.get_osuser RETURN VARCHAR2 DETERMINISTIC
  IS
BEGIN
  RETURN sys_context('userenv','OS_USER');
END;
/

prompt
prompt Creating function GET_PD_ACCESS
prompt ===============================
prompt
CREATE OR REPLACE FUNCTION DM_SKB.get_pd_access (inUser IN VARCHAR2, inRepsystemId IN NUMBER)
  RETURN INTEGER DETERMINISTIC
  IS
    vCou INTEGER;
BEGIN
  SELECT COUNT(1) INTO vCou
    FROM dm_skb.user_2_system
    WHERE source_system_id = -1 AND repsystem_id = inRepsystemId AND u_login = LOWER(inUser);

  RETURN SIGN(vCou);
END get_pd_access;
/

prompt
prompt Creating function GET_TI_AS_HMS
prompt ===============================
prompt
CREATE OR REPLACE FUNCTION DM_SKB.get_ti_as_hms (inInterval IN NUMBER /*интервал в днях*/) RETURN VARCHAR2
  IS
BEGIN
  RETURN TO_CHAR(TRUNC(inInterval*24*60*60/3600))||'h '||TO_CHAR(TRUNC(MOD(inInterval*24*60*60,3600)/60))||'m '||TO_CHAR(ROUND(MOD(MOD(inInterval*24*60*60,3600),60),0))||'s';
END get_ti_as_hms;
/

prompt
prompt Creating function LONGTOVARCHAR
prompt ===============================
prompt
create or replace function dm_skb.LongToVarchar(a varchar2) return varchar2 is
   x varchar2(32767);
 begin
   select val into x from LDV_FIN_DATAL@ptk fdl where fdl.rowid = a;
   return substr(x, 1, 1000);
 end;
/

prompt
prompt Creating procedure PR_LOG_WRITE
prompt ===============================
prompt
create or replace procedure dm_skb.pr_log_write(
            c_unit       in varchar2,
            c_message    in varchar2,
            c_cmp        in integer default 0
  ) as
    pragma autonomous_transaction;
  begin
     insert into dm_skb.t_log
            (dat, unit, message, pr_cmp)
      values
        (sysdate,
         c_unit,
         c_message,
         c_cmp);
      commit;
  end;
/

prompt
prompt Creating procedure MASS_LOAD_PARALLEL_BY_DATE_PE
prompt ================================================
prompt
CREATE OR REPLACE PROCEDURE DM_SKB.mass_load_parallel_by_date_pe(inBeg IN DATE, inEnd IN DATE, inUnit IN VARCHAR2 DEFAULT NULL, inParams IN VARCHAR2 DEFAULT NULL)
  IS
    vMes VARCHAR2(2000);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    --vTIBegin DATE;
    --vBeg VARCHAR2(255) := 'to_date('''||to_char(inBeg,'DD.MM.YYYY')||''',''DD.MM.YYYY'')';
    --vEnd VARCHAR2(255) := 'to_date('''||to_char(inEnd,'DD.MM.YYYY')||''',''DD.MM.YYYY'')';
    vPLev NUMBER;
    vTry NUMBER;
    vStatus NUMBER;
    vTask VARCHAR2(255) := dbms_parallel_execute.generate_task_name;
    vParams VARCHAR2(32700);
BEGIN
  vMes := 'START :: Procedure "dm_skb.mass_load_parallel_by_date_pe" started.';
  dm_skb.pr_log_write('dm_skb.mass_load_parallel_by_date_pe',vMes);

  -- Формирование строки доп. параметров
  IF inParams IS NOT NULL THEN
    FOR idx IN (
      SELECT SUBSTR(str,1,INSTR(str,' ',1,1)-1) AS param_type
            ,SUBSTR(str,INSTR(str,' ',1,1)+1) AS param_value
      FROM TABLE(dm_skb.pkg_skb_parser.parse_str(inParams,'::'))  
    ) LOOP
      vParams := vParams||
        CASE idx.param_type 
          WHEN 'VARCHAR2' THEN ''''''||idx.param_value||''''''
          WHEN 'DATE' THEN 'to_date('''''||idx.param_value||''''',''''DD.MM.YYYY'''')'
        ELSE idx.param_value END||',';
    END LOOP;
    vParams := SUBSTR(vParams,1,LENGTH(vParams) - 1)  ;
  END IF;  
  --Вычисление количества потоков
  --SELECT COUNT(1) INTO vPlev FROM dual CONNECT BY ROWNUM <= inEnd - inBeg + 1;
  SELECT TRUNC(to_number(VALUE)/5*4) INTO vPLev FROM v$parameter WHERE NAME = 'job_queue_processes';

  -- Создание временной таблицы
  EXECUTE IMMEDIATE 'CREATE TABLE dm_skb.tmp_'||vTask||' (id NUMBER,exec_sql VARCHAR2(2000))';
  FOR idx IN (SELECT rownum AS id
             ,'begin '||inUnit||'(to_date('''''||to_char(inBeg+rownum-1,'DD.MM.YYYY')||''''',''''DD.MM.YYYY''''),to_date('''''||to_char(inBeg+rownum-1,'DD.MM.YYYY')||''''',''''DD.MM.YYYY'''')'||NVL2(vParams,','||vParams,'')||'); end;' AS vSQL
    FROM dual CONNECT BY ROWNUM <= inEnd - inBeg + 1)
  LOOP
    EXECUTE IMMEDIATE
    --dbms_output.put_line(
    'INSERT INTO dm_skb.tmp_'||vTask||' (id,exec_sql)
      VALUES ('||idx.id||','''||idx.vsql||''')'
    --)
    ;
    --dbms_output.put_line(idx.vSQL);
  END LOOP;


    --Наименование задачи
    DBMS_PARALLEL_EXECUTE.CREATE_TASK(task_name => vTask);
    --Раскладка по потокам
    DBMS_PARALLEL_EXECUTE.CREATE_CHUNKS_BY_SQL
      (task_name => vTask
      ,sql_stmt =>'SELECT id,id FROM dm_skb.tmp_'||vTask||' ORDER BY 1'
      ,by_rowid => FALSE
      );
    --Запуск задачи на выполнение
    DBMS_PARALLEL_EXECUTE.RUN_TASK (task_name => vTask,
       sql_stmt => 'declare
                      vSQL VARCHAR2(4000);
                    begin
                       SELECT exec_sql INTO vSQL
                         FROM dm_skb.tmp_'||vTask||'
                         WHERE id = :start_id AND id = :end_id
                       ;
                      execute immediate vSQL;
                      commit;
                    end;'
       ,language_flag => DBMS_SQL.NATIVE
       , parallel_level => vPLev );

    --Финишный контроль и удаление задачи
    vTry := 0;
    vStatus := DBMS_PARALLEL_EXECUTE.task_status(vTask);

    WHILE(vTry < 2 and vStatus != DBMS_PARALLEL_EXECUTE.FINISHED)
    LOOP
      vTry := vTry + 1;
      DBMS_PARALLEL_EXECUTE.resume_task(vTask);
      vStatus := DBMS_PARALLEL_EXECUTE.task_status(vTask);
    END LOOP;

    DBMS_PARALLEL_EXECUTE.drop_task(vTask);

    -- Удаление временной таблицы
  EXECUTE IMMEDIATE 'DROP TABLE dm_skb.tmp_'||vTask;

  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "dm_skb.mass_load_parallel_by_date_pe" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' successfully.';
  dm_skb.pr_log_write('dm_skb.mass_load_parallel_by_date_pe',vMes);
EXCEPTION WHEN OTHERS THEN
  DBMS_PARALLEL_EXECUTE.drop_task(vTask);
  vEndTime := SYSDATE;
  vMes := 'ERROR :: '||SQLERRM;
  dm_skb.pr_log_write('dm_skb.mass_load_parallel_by_date_pe',vMes);
  vMes := 'FINISH :: Procedure "dm_skb.mass_load_parallel_by_date_pe" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' with errors.';
  dm_skb.pr_log_write('dm_skb.mass_load_parallel_by_date_pe',vMes);
END mass_load_parallel_by_date_pe;
/

prompt
prompt Creating procedure MASS_LOAD_PARALLEL_BY_MONTH
prompt ==============================================
prompt
CREATE OR REPLACE PROCEDURE DM_SKB.mass_load_parallel_by_month (inBegDate IN DATE, inEndDate IN DATE, inProcedure IN VARCHAR2, inParams VARCHAR2 DEFAULT NULL)
  IS
BEGIN
  FOR idx IN (SELECT MIN(TRUNC(InEndDate,'DD') - ROWNUM +1) min_dt
                    ,MAX(TRUNC(InEndDate,'DD') - ROWNUM +1) max_dt
                    ,'
                      BEGIN
                        dm_skb.mass_load_parallel_by_date_pe(to_date('''||TO_CHAR(MIN(TRUNC(InEndDate,'DD') - ROWNUM +1),'DD.MM.YYYY')||''',''DD.MM.YYYY'')
                                                           ,to_date('''||TO_CHAR(MAX(TRUNC(InEndDate,'DD') - ROWNUM +1),'DD.MM.YYYY')||''',''DD.MM.YYYY'')
                                                           ,'''||inProcedure||''','''||inParams||'''
                                                           );
                      END;
                    ' as exec_sql
                  FROM DUAL CONNECT BY ROWNUM < TRUNC(InEndDate,'DD') - TRUNC(inBegDate,'DD') + 2
                  GROUP BY TRUNC(TRUNC(InEndDate,'DD')- ROWNUM +1,'MM')
              ORDER BY 1
             )
  LOOP
    EXECUTE IMMEDIATE idx.exec_sql;
  END LOOP;
END mass_load_parallel_by_month;
/

prompt
prompt Creating procedure MASS_LOAD_PARALLEL_BY_YDATE_PE
prompt =================================================
prompt
CREATE OR REPLACE PROCEDURE DM_SKB.mass_load_parallel_by_ydate_pe
  (inBegDate IN DATE, inEndDate IN DATE, inUnit IN VARCHAR2
  ,inParams IN VARCHAR2 DEFAULT NULL
  ,inLastDay BOOLEAN DEFAULT TRUE
  ,inMonthlyDay VARCHAR2 DEFAULT NULL)
  IS
    vMes VARCHAR2(2000);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vPLev NUMBER;
    vTry NUMBER;
    vStatus NUMBER;
    vTask VARCHAR2(255) := dbms_parallel_execute.generate_task_name;
    vParams VARCHAR2(4000);
BEGIN
  vMes := 'START :: Procedure "dm_skb.mass_load_parallel_by_ydate_pe" started.';
  dm_skb.pr_log_write('dm_skb.mass_load_parallel_by_ydate_pe',vMes);

  -- Формирование строки доп. параметров
  IF inParams IS NOT NULL THEN
    FOR idx IN (
      SELECT SUBSTR(str,1,INSTR(str,' ',1,1)-1) AS param_type
            ,SUBSTR(str,INSTR(str,' ',1,1)+1) AS param_value
      FROM TABLE(dm_skb.pkg_skb_parser.parse_str(inParams,'::'))
    ) LOOP
      vParams := vParams||
        CASE idx.param_type
          WHEN 'VARCHAR2' THEN ''''''||idx.param_value||''''''
          WHEN 'DATE' THEN 'to_date('''''||idx.param_value||''''',''''DD.MM.YYYY'''')'
        ELSE idx.param_value END||',';
    END LOOP;
    vParams := SUBSTR(vParams,1,LENGTH(vParams) - 1)  ;
  END IF;

  --Создание временной таблицы
  EXECUTE IMMEDIATE 'CREATE TABLE dm_skb.tmp_'||vTask||' (id NUMBER,exec_sql VARCHAR2(2000))';

  IF inLastDay AND NVL(to_number(inMonthlyDay, 'FM99', 'nls_numeric_characters='', '''),0) = 0 THEN
    FOR idx IN (SELECT ROWNUM AS ID
                      ,'BEGIN
                       '||inUnit||'(to_date('''''||TO_CHAR(LAST_DAY(ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1)),'DD.MM.YYYY')||''''',''''DD.MM.YYYY''''),to_date('''''||TO_CHAR(LAST_DAY(ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1)),'DD.MM.YYYY')||''''',''''DD.MM.YYYY'''')'||NVL2(vParams,','||vParams,'')||'); END;' as exec_sql
                  FROM DUAL CONNECT BY ROWNUM <= MONTHS_BETWEEN(TRUNC(InEndDate,'MM'),TRUNC(inBegDate,'MM')) + 1
                    --GROUP BY LAST_DAY(ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1))
                ORDER BY 1
               )
    LOOP
      EXECUTE IMMEDIATE
      --dbms_output.put_line(
      'INSERT INTO dm_skb.tmp_'||vTask||' (id,exec_sql)
        VALUES ('||idx.id||','''||idx.exec_sql||''')'
      --)
      ;
    END LOOP;
  ELSIF NOT inLastDay AND NVL(to_number(inMonthlyDay, 'FM99', 'nls_numeric_characters='', '''),0) = 0 THEN
    FOR idx IN (SELECT ROWNUM AS ID
                      ,'BEGIN
                         '||inUnit||'(to_date('''''||TO_CHAR(ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1),'DD.MM.YYYY')||''''',''''DD.MM.YYYY''''),to_date('''''||TO_CHAR(ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1),'DD.MM.YYYY')||''''',''''DD.MM.YYYY'''')'||NVL2(vParams,','||vParams,'')||'); END;' AS exec_sql
                    FROM DUAL CONNECT BY ROWNUM <= MONTHS_BETWEEN(TRUNC(InEndDate,'MM'),TRUNC(inBegDate,'MM')) + 1
                    --GROUP BY ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1)
                ORDER BY 1
               )
    LOOP
      EXECUTE IMMEDIATE
      --dbms_output.put_line(
      'INSERT INTO dm_skb.tmp_'||vTask||' (id,exec_sql)
        VALUES ('||idx.id||','''||idx.exec_sql||''')'
      --)
      ;
    END LOOP;
  ELSE
    FOR idx IN (SELECT ROWNUM AS ID
                      ,CASE WHEN EXTRACT(MONTH FROM ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1)) = EXTRACT(MONTH FROM ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1) + NVL(to_number(inMonthlyDay, 'FM99', 'nls_numeric_characters='', '''),0) - 1) THEN
                         'BEGIN
                         '||inUnit||'(to_date('''''||TO_CHAR(ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1) + NVL(to_number(inMonthlyDay, 'FM99', 'nls_numeric_characters='', '''),0) - 1,'DD.MM.YYYY')||''''',''''DD.MM.YYYY''''),to_date('''''||TO_CHAR(ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1) + NVL(to_number(inMonthlyDay, 'FM99', 'nls_numeric_characters='', '''),0) - 1,'DD.MM.YYYY')||''''',''''DD.MM.YYYY'''')'||NVL2(vParams,','||vParams,'')||'); END;'
                       ELSE 'BEGIN dm_skb.pr_log_write('''''||inUnit||''''',''''INFORMATION :: "'||inMonthlyDay||'.'||TRIM(to_char(EXTRACT(MONTH FROM ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1)),'00')||'.'||EXTRACT(YEAR FROM ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1)))||'" - дата отсутствует в указанном месяце. Расчет не требуется''''); END;'
                       END AS exec_sql
                    FROM DUAL CONNECT BY ROWNUM <= MONTHS_BETWEEN(TRUNC(InEndDate,'MM'),TRUNC(inBegDate,'MM')) + 1
                    --GROUP BY ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1) + NVL(to_number(inMonthlyDay, 'FM99', 'nls_numeric_characters='', '''),0) - 1
                ORDER BY 1
               )
    LOOP
      BEGIN
      vMes :=
      --dbms_output.put_line(
      'INSERT INTO dm_skb.tmp_'||vTask||' (id,exec_sql)
        VALUES ('||idx.id||','''||idx.exec_sql||''')'
      --)
      ;
      EXECUTE IMMEDIATE vMes;
      EXCEPTION WHEN OTHERS THEN
        dm_skb.pr_log_write(inUnit,SQLERRM||Chr(10)||vMes);
      END;
    END LOOP;
  END IF;

  --Вычисление количества потоков
  --SELECT COUNT(1) INTO vPlev FROM dual CONNECT BY ROWNUM <= MONTHS_BETWEEN(TRUNC(InEndDate,'MM'),TRUNC(inBegDate,'MM')) + 1;
  SELECT TRUNC(to_number(VALUE)/5*4) INTO vPLev FROM v$parameter WHERE NAME = 'job_queue_processes';

  --Наименование задачи
  DBMS_PARALLEL_EXECUTE.CREATE_TASK(task_name => vTask);
  --Раскладка по потокам
  DBMS_PARALLEL_EXECUTE.CREATE_CHUNKS_BY_SQL
    (task_name => vTask
    ,sql_stmt =>'SELECT id,id FROM dm_skb.tmp_'||vTask||' ORDER BY 1'
    ,by_rowid => FALSE
    );
  --Запуск задачи на выполнение
  DBMS_PARALLEL_EXECUTE.RUN_TASK (task_name => vTask,
     sql_stmt => 'declare
                    vSQL VARCHAR2(4000);
                  begin
                     SELECT exec_sql INTO vSQL
                       FROM dm_skb.tmp_'||vTask||'
                       WHERE id = :start_id AND id = :end_id
                     ;
                    execute immediate vSQL;
                    commit;
                  end;'
     ,language_flag => DBMS_SQL.NATIVE
     , parallel_level => vPLev );

  --Финишный контроль и удаление задачи
  vTry := 0;
  vStatus := DBMS_PARALLEL_EXECUTE.task_status(vTask);

  WHILE(vTry < 2 and vStatus != DBMS_PARALLEL_EXECUTE.FINISHED)
  LOOP
    vTry := vTry + 1;
    DBMS_PARALLEL_EXECUTE.resume_task(vTask);
    vStatus := DBMS_PARALLEL_EXECUTE.task_status(vTask);
  END LOOP;

  DBMS_PARALLEL_EXECUTE.drop_task(vTask);

  -- Удаление временной таблицы
  EXECUTE IMMEDIATE 'DROP TABLE dm_skb.tmp_'||vTask;

  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "dm_skb.mass_load_parallel_by_ydate_pe" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' successfully.';
  dm_skb.pr_log_write('dm_skb.mass_load_parallel_by_ydate_pe',vMes);
EXCEPTION WHEN OTHERS THEN
  DBMS_PARALLEL_EXECUTE.drop_task(vTask);
  vEndTime := SYSDATE;
  vMes := 'ERROR :: '||SQLERRM;
  dm_skb.pr_log_write('dm_skb.mass_load_parallel_by_ydate_pe',vMes);
  vMes := 'FINISH :: Procedure "dm_skb.mass_load_parallel_by_ydate_pe" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' with errors.';
  dm_skb.pr_log_write('dm_skb.mass_load_parallel_by_ydate_pe',vMes);
END mass_load_parallel_by_ydate_pe;
/

prompt
prompt Creating procedure MASS_LOAD_PARALLEL_BY_YEAR
prompt =============================================
prompt
CREATE OR REPLACE PROCEDURE DM_SKB.mass_load_parallel_by_year
  (inBegDate IN DATE, inEndDate IN DATE, inProcedure IN VARCHAR2
  ,inParams VARCHAR2 DEFAULT NULL
  ,inLastDay BOOLEAN DEFAULT TRUE
  ,inMonthlyDay VARCHAR2 DEFAULT NULL
  ,inYearParallel BOOLEAN DEFAULT FALSE)
  IS
    vLstDay VARCHAR2(5);
    vTask VARCHAR2(256);
    vTry NUMBER;
    vStatus NUMBER;
    vPLev NUMBER;
    vSQL_stmt VARCHAR2(32700);
BEGIN
  IF inLastDay THEN vLstDay := 'TRUE'; ELSE vLstDay := 'FALSE'; END IF;
  IF inYearParallel THEN
    --Наименование задачи
    vTask := dbms_parallel_execute.generate_task_name;
    --Создание задачи
    DBMS_PARALLEL_EXECUTE.CREATE_TASK(task_name => vTask);

   -- Вычисление количества потоков
    SELECT TRUNC(to_number(VALUE)/5*4) INTO vPLev FROM v$parameter WHERE NAME = 'job_queue_processes';

    --Раскладка по потокам
    DBMS_PARALLEL_EXECUTE.CREATE_CHUNKS_BY_SQL
      (task_name => vTask
      ,sql_stmt =>
        'SELECT ROWNUM AS ID,ROWNUM as ID FROM (
          SELECT EXTRACT(YEAR FROM to_date('''||to_char(inEndDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') - ROWNUM + 1) as y
            FROM dual CONNECT BY ROWNUM <= to_date('''||to_char(inEndDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') - to_date('''||to_char(inBegDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') + 1
          GROUP BY EXTRACT(YEAR FROM to_date('''||to_char(inEndDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') - ROWNUM + 1)
          ORDER BY 1
        )'
      ,by_rowid => FALSE
      );
      
     vSql_stmt := 'declare
                    vSQL VARCHAR2(4000);
                  begin
                    WITH
                      y as (
                        SELECT ROWNUM AS ID,y_beg,y_end FROM (
                          SELECT MIN(to_date('''||to_char(inEndDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') - ROWNUM + 1) AS y_beg
                                ,MAX(to_date('''||to_char(inEndDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') - ROWNUM + 1) AS y_end
                            FROM dual CONNECT BY ROWNUM <= to_date('''||to_char(inEndDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') - to_date('''||to_char(inBegDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') + 1
                          GROUP BY EXTRACT(YEAR FROM to_date('''||to_char(inEndDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') - ROWNUM + 1)
                          ORDER BY 1
                        )
                      )
                     SELECT ''
                      BEGIN
                        dm_skb.mass_load_parallel_by_ydate_pe(to_date(''''''||to_char(y.y_beg,''DD.MM.YYYY'')||'''''',''''DD.MM.YYYY'''')
                                                             ,to_date(''''''||to_char(y.y_end,''DD.MM.YYYY'')||'''''',''''DD.MM.YYYY'''')
                                                             ,'''''||inProcedure||'''''
                                                             ,'||CASE WHEN inParams IS NOT NULL THEN ''''''||inParams||'''''' ELSE 'NULL' END||'
                                                             ,'||vLstDay||CASE WHEN inMonthlyDay IS NOT NULL THEN ','''''||inMonthlyDay||'''''' ELSE NULL END||'
                                                             );
                      END;
                    '' as exec_sql 
                       INTO vSQL
                       FROM y
                       WHERE id = :start_id AND id = :end_id
                     ;
                    execute immediate vSQL;
                    commit;
                  end;';
    --dbms_output.put_line(sql_stmt);              
    --Запуск задачи на выполнение
    DBMS_PARALLEL_EXECUTE.RUN_TASK (task_name => vTask
       ,sql_stmt => vSql_stmt
       ,language_flag => DBMS_SQL.NATIVE
       , parallel_level => vPLev );

    --Финишный контроль и удаление задачи
    vTry := 0;
    vStatus := DBMS_PARALLEL_EXECUTE.task_status(vTask);

    WHILE(vTry < 2 and vStatus != DBMS_PARALLEL_EXECUTE.FINISHED)
    LOOP
      vTry := vTry + 1;
      DBMS_PARALLEL_EXECUTE.resume_task(vTask);
      vStatus := DBMS_PARALLEL_EXECUTE.task_status(vTask);
    END LOOP;

    DBMS_PARALLEL_EXECUTE.drop_task(vTask);

  ELSE
    FOR idx IN (SELECT GREATEST(TRUNC(add_months(inEndDate,-(ROWNUM-1)*12),'YYYY'),inBegDate) AS min_dt
                      ,LEAST(add_months(TRUNC(add_months(inEndDate,-(ROWNUM-1)*12),'YYYY'),12) - 1,inEndDate) AS max_dt
                      ,'BEGIN'||Chr(10)||
                       '   dm_skb.mass_load_parallel_by_ydate_pe(to_date('''||TO_CHAR(GREATEST(TRUNC(add_months(inEndDate,-(ROWNUM-1)*12),'YYYY'),inBegDate),'DD.MM.YYYY')||''',''DD.MM.YYYY'')'||Chr(10)||
                       '                                       ,to_date('''||TO_CHAR(LEAST(add_months(TRUNC(add_months(inEndDate,-(ROWNUM-1)*12),'YYYY'),12) - 1,inEndDate),'DD.MM.YYYY')||''',''DD.MM.YYYY'')'||Chr(10)||
                       '                                       ,'''||inProcedure||''''||Chr(10)||
                       '                                       ,'||CASE WHEN inParams IS NOT NULL THEN ''''||inParams||'''' ELSE 'NULL' END||Chr(10)||
                       '                                       ,'||vLstDay||NVL2(inMonthlyDay,','''||inMonthlyDay||'''',NULL)||');'||Chr(10)||
                       'END;' AS exec_sql
                      
                    FROM DUAL CONNECT BY ROWNUM <= CEIL(MONTHS_BETWEEN(inEndDate+1,TRUNC(inBegDate,'YYYY'))/12)
                ORDER BY 1
               )
    LOOP
      
      EXECUTE IMMEDIATE idx.exec_sql;
      --dbms_output.put_line(idx.exec_sql);
    END LOOP;
  END IF; 
EXCEPTION WHEN OTHERS THEN
  BEGIN DBMS_PARALLEL_EXECUTE.drop_task(vTask); EXCEPTION WHEN OTHERS THEN NULL; END;
  --dbms_output.put_line(SQLERRM);
END mass_load_parallel_by_year;
/

prompt
prompt Creating procedure MY_EXECUTE
prompt =============================
prompt
CREATE OR REPLACE PROCEDURE DM_SKB.my_execute (inPLSQLBlock IN VARCHAR2,vOut OUT VARCHAR2)
  IS
BEGIN
  EXECUTE IMMEDIATE inPLSQLBlock;
  vOut := 'Ok';
EXCEPTION WHEN OTHERS THEN
  vOut := SQLERRM;
END my_execute;
/

prompt
prompt Creating procedure STAREXPAND_DPS
prompt =================================
prompt
CREATE OR REPLACE PROCEDURE DM_SKB.starexpand_dps
  (inBegDate IN DATE,inEndDate IN DATE,inUnit IN VARCHAR2)
  IS
    vOwner VARCHAR2(30) := 'DM_SKB';
    --vID VARCHAR2(30) := to_char(SYSDATE,'RRRRMMDDHH24MISS');
    vJobName VARCHAR2(256) := UPPER(vOwner)||'.'||'EXPAND_'||dm_skb.tb_signs_job_id_seq.nextval;

    vBuff VARCHAR2(32700);
BEGIN
  vBuff :=
    'SELECT DISTINCT p.id,c2c.parent_id,p.e_unit AS unit'||CHR(10)||
    '      ,REPLACE(REPLACE(p.params,'':INBEGDATE'','''||to_char(inBegDate,'DD.MM.YYYY')||'''),'':INENDDATE'','''||to_char(inEndDate,'DD.MM.YYYY')||''') AS params'||CHR(10)||
    '      ,CASE WHEN '||vOwner||'.pkg_etl_signs.GetConditionResult(p.condition) = 1 THEN 0 ELSE 1 END AS skip'||CHR(10)||
    q'[  FROM dm_skb.tb_Calc_pool p
              LEFT JOIN dm_skb.tb_calc_2_calc c2c
                ON p.id = c2c.id
       CONNECT BY NOCYCLE PRIOR c2c.PARENT_ID = p.ID
       START WITH p.id IN (73,75,89,63,90,94)]';

  dm_skb.pkg_etl_signs.load_new(vBuff,vJobName);
  --dbms_output.put_line(vBuff);
  --dm_skb.pkg_etl_signs.SetFlag('СКОРИНГ :: SCORE_V002', inBegDate, 'READY', 1);

END starexpand_dps;
/

prompt
prompt Creating package body PKG_ETL_CTR_SIGNS
prompt =======================================
prompt
CREATE OR REPLACE PACKAGE BODY DM_SKB.pkg_etl_ctr_signs
  IS
  
FUNCTION GetCredits (InDate IN DATE) RETURN tabCredits PIPELINED
  IS
    rec recCredits;
BEGIN
  FOR idx IN (
WITH
  ciw AS (
    SELECT inDate AS as_of_date
          ,LEAST(inDate,COALESCE(to_date(cls.sign_val,'DD.MM.RRRR'),inDate)) AS join_date
          ,c.obj_gid
          ,c.source_system_id
      FROM dm_skb.tb_ctr_signs_new c
           LEFT JOIN dm_skb.tb_ctr_signs_new cls
             ON cls.sign_name = 'CTR_CREDIT_CLOSE_FACT_DATE'
                AND cls.obj_gid = c.obj_gid
                AND cls.source_system_id = c.source_system_id
                AND inDate BETWEEN cls.effective_start AND cls.effective_end
      WHERE c.sign_name = 'CTR_IS_CREDIT'
        AND inDate BETWEEN c.effective_start AND c.effective_end
  )
 ,tb AS (
    SELECT as_of_date
          ,obj_gid
          ,source_system_id
          ,to_number(uc_id,'FM999999999999999D999999999','nls_numeric_characters='', ''')                             AS uc_id
          ,to_number(NVL(overdue_principal,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')        AS overdue_principal
          ,to_number(NVL(overdue_principal_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')    AS overdue_principal_eqv
          ,to_number(NVL(overdue_interest,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')         AS overdue_interest
          ,to_number(NVL(overdue_interest_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')     AS overdue_interest_eqv
          ,to_number(NVL(account_sum_91311,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')        AS account_sum_91311
          ,account_num_91311                                                                                          AS account_num_91311
          ,account_name_91311                                                                                         AS account_name_91311
          ,to_number(NVL(account_sum_91312,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')        AS account_sum_91312
          ,account_num_91312                                                                                          AS account_num_91312
          ,account_name_91312                                                                                         AS account_name_91312
          ,to_number(NVL(account_sum_91313,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')        AS account_sum_91313
          ,account_num_91313                                                                                          AS account_num_91313
          ,account_name_91313                                                                                         AS account_name_91313
          ,to_number(NVL(account_sum_91314,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')        AS account_sum_91314
          ,account_num_91314                                                                                          AS account_num_91314
          ,account_name_91314                                                                                         AS account_name_91314
          ,to_number(NVL(account_sum_91414,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')        AS account_sum_91414
          ,account_num_91414                                                                                          AS account_num_91414
          ,account_name_91414                                                                                         AS account_name_91414
          ,to_number(creditline_id,'FM999999999999999D999999999','nls_numeric_characters='', ''')                     AS creditline_id
          ,creditline_no                                                                                              AS creditline_no
          ,credit_state                                                                                               AS credit_state
          ,credit_status                                                                                              AS credit_status
          ,to_number(NVL(interest_rate_open_date,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')  AS interest_rate_open_date
          ,reg_region                                                                                                 AS reg_region
          ,to_number(NVL(cnt_contr_for_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')     AS cnt_contr_for_client
          ,to_number(NVL(commiss_monthly,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')          AS commiss_monthly
          ,to_number(NVL(interest_rate_acgn2,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')      AS interest_rate_acgn2
          ,to_number(pr_transh,'FM999999999999999D999999999','nls_numeric_characters='', ''')                         AS pr_transh
          ,to_number(NVL(main_payment,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')             AS main_payment
          ,to_number(NVL(prc_payment,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')              AS prc_payment
          ,okved                                                                                                      AS okved
          ,business                                                                                                   AS business
          ,to_number(NVL(sum_first_turn_ibso,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') +
           to_number(NVL(sum_first_turn_3card,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')     AS sum_first_turn
          ,to_date(date_first_turn,'DD.MM.YYYY')                                                                      AS date_first_turn
          ,to_date(residue_vnb,'DD.MM.YYYY')                                                                          AS off_date_vnb
          ,to_number(NVL(prc_main_vnb_amount,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')      AS prc_main_vnb_amount
          ,to_number(NVL(prc_debt_vnb_amount,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')      AS prc_debt_vnb_amount
          ,to_number(NVL(unused_credit_limit_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')  AS unused_credit_limit_eqv
          ,to_number(NVL(unused_credit_limit,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')      AS unused_credit_limit
          ,to_char(to_number(pr_defolt_client,'FM999999999999999D999999999','nls_numeric_characters='', '''))         AS pr_defolt_client
          ,to_char(to_number(pr_problem_client,'FM999999999999999D999999999','nls_numeric_characters='', '''))        AS pr_problem_client
          ,credit_state_ul                                                                                            AS credit_state_ul
          ,to_number(NVL(provis_percent,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')           AS provis_percent
          ,to_number(NVL(provis_percent_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')    AS provis_percent_client
          ,to_number(NVL(overdue_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')           AS overdue_client
          ,to_number(claim_gid,'FM999999999999999D999999999','nls_numeric_characters='', ''')                         AS claim_gid
          ,to_number(NVL(account_sum_91802,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')        AS account_sum_91802
          ,to_number(NVL(account_sum_91803,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')        AS account_sum_91803
          ,to_number(NVL(account_sum_91704,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')        AS account_sum_91704
          ,to_number(NVL(account_sum_91604,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')        AS account_sum_91604
          ,to_number(NVL(account_sum_91604_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91604_client
          ,open_abs_dep_code                                                                                          AS open_abs_dep_code
          ,open_abs_dep_name                                                                                          AS open_abs_dep_name
          ,serv_department_code                                                                                       AS serv_department_code
          ,serv_department_name                                                                                       AS serv_department_name
          ,serv_department_city                                                                                       AS serv_department_city
          ,serv_department_region                                                                                     AS serv_department_region
          ,serv_dep_branch_name                                                                                       AS serv_dep_branch_name
          ,serv_dep_branch_code                                                                                       AS serv_dep_branch_code
          ,open_dep_branch_name                                                                                       AS open_dep_branch_name
          ,open_dep_branch_code                                                                                       AS open_dep_branch_code
          ,adv_account                                                                                                AS adv_account
          ,type_restruct                                                                                              AS type_restruct
          ,to_number(rate_first_day,'FM999999999999999D999999999','nls_numeric_characters='', ''')                    AS rate_first_day
          ,to_number(sum_contr_for_client,'FM999999999999999D999999999','nls_numeric_characters='', ''')              AS sum_contr_for_client
          ,cl_ogrn                                                                                                    AS cl_ogrn
          ,pr_annuitet_pay                                                                                            AS pr_annuitet_pay
          ,pr_differ_pay                                                                                              AS pr_differ_pay
          ,over_principal                                                                                             AS over_principal
      FROM (
        SELECT /*+ parallel(s 16) */
               ciw.as_of_date
              ,s.source_system_id
              ,s.obj_gid
              ,s.sign_name
              ,CASE WHEN s.sign_name = 'RESIDUE_VNB' THEN
                CASE WHEN s.sign_val = '1' THEN to_char(effective_start,'DD.MM.YYYY') ELSE NULL END
               ELSE s.sign_val END AS sign_val
          FROM ciw
               INNER JOIN dm_skb.tb_ctr_signs_new s
                 ON s.sign_name IN ('OVERDUE_PRINCIPAL','OVERDUE_PRINCIPAL_EQV','OVERDUE_INTEREST','OVERDUE_INTEREST_EQV'
                                   ,'ACCOUNT_SUM_91311','ACCOUNT_NUM_91311','ACCOUNT_NAME_91311'
                                   ,'ACCOUNT_SUM_91312','ACCOUNT_NUM_91312','ACCOUNT_NAME_91312'
                                   ,'ACCOUNT_SUM_91313','ACCOUNT_NUM_91313','ACCOUNT_NAME_91313'
                                   ,'ACCOUNT_SUM_91314','ACCOUNT_NUM_91314','ACCOUNT_NAME_91314'
                                   ,'ACCOUNT_SUM_91414','ACCOUNT_NUM_91414','ACCOUNT_NAME_91414'
                                   ,'CREDITLINE_ID','CREDITLINE_NO'
                                   ,'CREDIT_STATE','CREDIT_STATUS','INTEREST_RATE_OPEN_DATE','REG_REGION'
                                   ,'CNT_CONTR_FOR_CLIENT', 'COMMISS_MONTHLY','INTEREST_RATE_ACGN2','PR_TRANSH'
                                   ,'MAIN_PAYMENT','PRC_PAYMENT','OKVED','BUSINESS','SUM_FIRST_TURN','DATE_FIRST_TURN'
                                   ,'PRC_MAIN_VNB_AMOUNT','PRC_DEBT_VNB_AMOUNT','RESIDUE_VNB'
                                   ,'UNUSED_CREDIT_LIMIT_EQV','UNUSED_CREDIT_LIMIT','SUM_FIRST_TURN_IBSO','SUM_FIRST_TURN_3CARD'
                                   ,'UC_ID','PR_DEFOLT_CLIENT','PR_PROBLEM_CLIENT','CREDIT_STATE_UL'
                                   ,'PROVIS_PERCENT','PROVIS_PERCENT_CLIENT','OVERDUE_CLIENT'
                                   ,'CLAIM_GID','ACCOUNT_SUM_91802','ACCOUNT_SUM_91803','ACCOUNT_SUM_91704','ACCOUNT_SUM_91604'
                                   ,'ACCOUNT_SUM_91604_CLIENT'
                                   ,'OPEN_ABS_DEP_CODE','OPEN_ABS_DEP_NAME'
                                   ,'SERV_DEPARTMENT_CODE','SERV_DEPARTMENT_NAME'
                                   ,'SERV_DEPARTMENT_CITY','SERV_DEPARTMENT_REGION','SERV_DEP_BRANCH_NAME','SERV_DEP_BRANCH_CODE'
                                   ,'OPEN_DEP_BRANCH_CODE','OPEN_DEP_BRANCH_NAME'
                                   ,'ADV_ACCOUNT','TYPE_RESTRUCT','RATE_FIRST_DAY','SUM_CONTR_FOR_CLIENT', 'CL_OGRN', 'PR_ANNUITET_PAY', 'PR_DIFFER_PAY', 'OVER_PRINCIPAL'
                                   )
                    AND s.obj_gid = ciw.obj_gid
                    AND s.source_system_id = ciw.source_system_id
                    AND ciw.join_date BETWEEN s.effective_start AND s.effective_end

      ) PIVOT (MAX(sign_val)
          FOR sign_name IN (
            'OVERDUE_PRINCIPAL'        AS        overdue_principal
           ,'OVERDUE_PRINCIPAL_EQV'    AS    overdue_principal_eqv
           ,'OVERDUE_INTEREST'         AS         overdue_interest
           ,'OVERDUE_INTEREST_EQV'     AS     overdue_interest_eqv
           ,'ACCOUNT_SUM_91311'        AS        account_sum_91311
           ,'ACCOUNT_NUM_91311'        AS        account_num_91311
           ,'ACCOUNT_NAME_91311'       AS       account_name_91311
           ,'ACCOUNT_SUM_91312'        AS        account_sum_91312
           ,'ACCOUNT_NUM_91312'        AS        account_num_91312
           ,'ACCOUNT_NAME_91312'       AS       account_name_91312
           ,'ACCOUNT_SUM_91313'        AS        account_sum_91313
           ,'ACCOUNT_NUM_91313'        AS        account_num_91313
           ,'ACCOUNT_NAME_91313'       AS       account_name_91313
           ,'ACCOUNT_SUM_91314'        AS        account_sum_91314
           ,'ACCOUNT_NUM_91314'        AS        account_num_91314
           ,'ACCOUNT_NAME_91314'       AS       account_name_91314
           ,'ACCOUNT_SUM_91414'        AS        account_sum_91414
           ,'ACCOUNT_NUM_91414'        AS        account_num_91414
           ,'ACCOUNT_NAME_91414'       AS       account_name_91414
           ,'CREDITLINE_ID'            AS            creditline_id
           ,'CREDITLINE_NO'            AS            creditline_no
           ,'CREDIT_STATE'             AS             credit_state
           ,'CREDIT_STATUS'            AS            credit_status
           ,'INTEREST_RATE_OPEN_DATE'  AS  interest_rate_open_date
           ,'REG_REGION'               AS               reg_region
           ,'CNT_CONTR_FOR_CLIENT'     AS     cnt_contr_for_client
           ,'COMMISS_MONTHLY'          AS          commiss_monthly
           ,'INTEREST_RATE_ACGN2'      AS      interest_rate_acgn2
           ,'PR_TRANSH'                AS                pr_transh
           ,'MAIN_PAYMENT'             AS             main_payment
           ,'PRC_PAYMENT'              AS              prc_payment
           ,'OKVED'                    AS                    okved
           ,'BUSINESS'                 AS                 business
           ,'SUM_FIRST_TURN_IBSO'      AS      sum_first_turn_ibso
           ,'SUM_FIRST_TURN_3CARD'     AS     sum_first_turn_3card
           ,'DATE_FIRST_TURN'          AS          date_first_turn
           ,'RESIDUE_VNB'              AS residue_vnb
           ,'PRC_MAIN_VNB_AMOUNT'      AS      prc_main_vnb_amount
           ,'PRC_DEBT_VNB_AMOUNT'      AS      prc_debt_vnb_amount
           ,'UNUSED_CREDIT_LIMIT_EQV'  AS  unused_credit_limit_eqv
           ,'UNUSED_CREDIT_LIMIT'      AS      unused_credit_limit
           ,'UC_ID'                    AS                    uc_id
           ,'PR_DEFOLT_CLIENT'         AS         pr_defolt_client
           ,'PR_PROBLEM_CLIENT'        AS        pr_problem_client
           ,'CREDIT_STATE_UL'          AS          credit_state_ul
           ,'PROVIS_PERCENT'           AS           provis_percent
           ,'PROVIS_PERCENT_CLIENT'    AS    provis_percent_client
           ,'OVERDUE_CLIENT'           AS           overdue_client
           ,'CLAIM_GID'                AS                claim_gid
           ,'ACCOUNT_SUM_91802'        AS        account_sum_91802
           ,'ACCOUNT_SUM_91803'        AS        account_sum_91803
           ,'ACCOUNT_SUM_91704'        AS        account_sum_91704
           ,'ACCOUNT_SUM_91604'        AS        account_sum_91604
           ,'ACCOUNT_SUM_91604_CLIENT' AS account_sum_91604_client
           ,'OPEN_ABS_DEP_CODE'        AS open_abs_dep_code
           ,'OPEN_ABS_DEP_NAME'        AS open_abs_dep_name
           ,'SERV_DEPARTMENT_CODE'     AS serv_department_code
           ,'SERV_DEPARTMENT_NAME'     AS serv_department_name
           ,'SERV_DEPARTMENT_CITY'     AS serv_department_city
           ,'SERV_DEPARTMENT_REGION'   AS serv_department_region
           ,'SERV_DEP_BRANCH_NAME'     AS serv_dep_branch_name
           ,'SERV_DEP_BRANCH_CODE'     AS serv_dep_branch_code
           ,'OPEN_DEP_BRANCH_NAME'     AS open_dep_branch_name
           ,'OPEN_DEP_BRANCH_CODE'     AS open_dep_branch_code
           ,'ADV_ACCOUNT'              AS adv_account
           ,'TYPE_RESTRUCT'            AS type_restruct
           ,'RATE_FIRST_DAY'           AS rate_first_day
           ,'SUM_CONTR_FOR_CLIENT'     AS sum_contr_for_client
           ,'CL_OGRN'                  AS        CL_OGRN
           ,'PR_ANNUITET_PAY'          AS pr_annuitet_pay
           ,'PR_DIFFER_PAY'            AS pr_differ_pay
           ,'OVER_PRINCIPAL'           AS OVER_PRINCIPAL
          )
        )
  )
 ,ptb AS (
    SELECT as_of_date
          ,obj_gid
          ,source_system_id
          ,to_number(NVL(cnt_pays_od_on_debt,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')        AS cnt_pays_od_on_debt
          ,to_number(NVL(amount_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                 AS amount_eqv
          ,to_number(NVL(amount,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                     AS amount
          ,to_number(NVL(prc_to_main,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                AS prc_to_main
          ,to_number(NVL(amount_debt,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                AS amount_debt
          ,to_number(NVL(amount_pay_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')             AS amount_pay_eqv
          ,to_number(NVL(fee_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                    AS fee_eqv
          ,to_number(NVL(cnt_overdue_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')         AS cnt_overdue_client
          ,to_number(NVL(interest,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                   AS interest
          ,to_number(NVL(interest_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')               AS interest_eqv
          ,to_number(NVL(sum_pay_od_main,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')            AS sum_pay_od_main
          ,to_number(NVL(sum_pay_od_debt,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')            AS sum_pay_od_debt
          ,to_number(NVL(max_sum_overdue_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')     AS max_sum_overdue_client
          ,to_number(NVL(max_cnt_day_overdue_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS max_cnt_day_overdue_client
          ,to_number(NVL(max_fifo_for_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')        AS max_fifo_for_client
      FROM (
        SELECT /*+ parallel(f 4) */
               f.as_of_date
              ,f.obj_gid
              ,f.source_system_id
              ,f.sign_name
              ,f.sign_val
          FROM dm_skb.ptb_ctr_signs_new f
          WHERE f.sign_name IN ('CNT_PAYS_OD_ON_DEBT'
                               ,'AMOUNT_EQV'
                               ,'AMOUNT'
                               ,'PRC_TO_MAIN'
                               ,'AMOUNT_DEBT'
                               ,'AMOUNT_PAY_EQV'
                               ,'FEE_EQV'
                               ,'CNT_OVERDUE_CLIENT'
                               ,'INTEREST'
                               ,'INTEREST_EQV'
                               ,'SUM_PAY_OD_MAIN'
                               ,'SUM_PAY_OD_DEBT'
                               ,'MAX_SUM_OVERDUE_CLIENT'
                               ,'MAX_CNT_DAY_OVERDUE_CLIENT'
                               ,'MAX_FIFO_FOR_CLIENT')
            AND f.as_of_date = to_date('21.01.2018','DD.MM.YYYY')
      )
          PIVOT (MAX(sign_val)
          FOR sign_name IN (
            'CNT_PAYS_OD_ON_DEBT'        AS cnt_pays_od_on_debt
           ,'AMOUNT_EQV'                 AS amount_eqv
           ,'AMOUNT'                     AS amount
           ,'PRC_TO_MAIN'                AS prc_to_main
           ,'AMOUNT_DEBT'                AS amount_debt
           ,'AMOUNT_PAY_EQV'             AS amount_pay_eqv
           ,'FEE_EQV'                    AS fee_eqv
           ,'CNT_OVERDUE_CLIENT'         AS cnt_overdue_client
           ,'INTEREST'                   AS interest
           ,'INTEREST_EQV'               AS interest_eqv
           ,'SUM_PAY_OD_MAIN'            AS sum_pay_od_main
           ,'SUM_PAY_OD_DEBT'            AS sum_pay_od_debt
           ,'MAX_SUM_OVERDUE_CLIENT'     AS max_sum_overdue_client
           ,'MAX_CNT_DAY_OVERDUE_CLIENT' AS max_cnt_day_overdue_client
           ,'MAX_FIFO_FOR_CLIENT'        AS max_fifo_for_client
          )
        )
  )
  SELECT 
         ciw.as_of_date
        ,ciw.obj_gid AS contract_gid
        ,ciw.source_system_id
        ,tb.uc_id
        ,tb.overdue_principal
        ,tb.overdue_principal_eqv
        ,tb.overdue_interest
        ,tb.overdue_interest_eqv
        ,tb.account_sum_91311
        ,tb.account_num_91311
        ,tb.account_name_91311
        ,tb.account_sum_91312
        ,tb.account_num_91312
        ,tb.account_name_91312
        ,tb.account_sum_91313
        ,tb.account_num_91313
        ,tb.account_name_91313
        ,tb.account_sum_91314
        ,tb.account_num_91314
        ,tb.account_name_91314
        ,tb.account_sum_91414
        ,tb.account_num_91414
        ,tb.account_name_91414
        ,tb.creditline_id
        ,tb.creditline_no
        ,tb.credit_state
        ,tb.credit_status
        ,tb.interest_rate_open_date
        ,tb.reg_region
        ,tb.cnt_contr_for_client
        ,tb.commiss_monthly
        ,tb.interest_rate_acgn2
        ,tb.pr_transh
        ,tb.main_payment
        ,tb.prc_payment
        ,tb.okved
        ,tb.business
        ,tb.sum_first_turn
        ,tb.date_first_turn
        ,tb.off_date_vnb
        ,tb.prc_main_vnb_amount
        ,tb.prc_debt_vnb_amount
        ,tb.unused_credit_limit_eqv
        ,tb.unused_credit_limit
        ,tb.pr_defolt_client
        ,tb.pr_problem_client
        ,tb.credit_state_ul
        ,tb.provis_percent
        ,tb.provis_percent_client
        ,tb.overdue_client
        ,tb.claim_gid
        ,tb.account_sum_91802
        ,tb.account_sum_91803
        ,tb.account_sum_91704
        ,tb.account_sum_91604
        ,tb.account_sum_91604_client
        ,tb.open_abs_dep_code
        ,tb.open_abs_dep_name
        ,tb.serv_department_code
        ,tb.serv_department_name
        ,tb.serv_department_city
        ,tb.serv_department_region
        ,tb.serv_dep_branch_name
        ,tb.serv_dep_branch_code
        ,tb.open_dep_branch_name
        ,tb.open_dep_branch_code
        ,tb.adv_account
        ,tb.type_restruct
        ,tb.rate_first_day
        ,tb.sum_contr_for_client
        ,tb.cl_ogrn
        ,tb.pr_annuitet_pay
        ,tb.pr_differ_pay
        ,tb.over_principal
        ,ptb.cnt_pays_od_on_debt
        ,ptb.amount_eqv
        ,ptb.amount
        ,ptb.prc_to_main
        ,ptb.amount_debt
        ,ptb.amount_pay_eqv
        ,ptb.fee_eqv
        ,ptb.cnt_overdue_client
        ,ptb.interest
        ,ptb.interest_eqv
        ,ptb.sum_pay_od_main
        ,ptb.sum_pay_od_debt
        ,ptb.max_sum_overdue_client
        ,ptb.max_cnt_day_overdue_client
        ,ptb.max_fifo_for_client
    FROM ciw
         LEFT JOIN tb
           ON tb.as_of_date = ciw.as_of_date
              AND tb.obj_gid = ciw.obj_gid
              AND tb.source_system_id = ciw.source_system_id
         LEFT JOIN ptb
           ON ptb.as_of_date = ciw.as_of_date
              AND ptb.obj_gid = ciw.obj_gid
              AND ptb.source_system_id = ciw.source_system_id
  ) LOOP
      rec.as_of_date                 := idx.as_of_date;
      rec.contract_gid               := idx.contract_gid;
      rec.source_system_id           := idx.source_system_id;
      rec.uc_id                      := idx.uc_id;
      rec.overdue_principal          := idx.overdue_principal;
      rec.overdue_principal_eqv      := idx.overdue_principal_eqv;
      rec.overdue_interest           := idx.overdue_interest;
      rec.overdue_interest_eqv       := idx.overdue_interest_eqv;
      rec.account_sum_91311          := idx.account_sum_91311;
      rec.account_num_91311          := idx.account_num_91311;
      rec.account_name_91311         := idx.account_name_91311;
      rec.account_sum_91312          := idx.account_sum_91312;
      rec.account_num_91312          := idx.account_num_91312;
      rec.account_name_91312         := idx.account_name_91312;
      rec.account_sum_91313          := idx.account_sum_91313;
      rec.account_num_91313          := idx.account_num_91313;
      rec.account_name_91313         := idx.account_name_91313;
      rec.account_sum_91314          := idx.account_sum_91314;
      rec.account_num_91314          := idx.account_num_91314;
      rec.account_name_91314         := idx.account_name_91314;
      rec.account_sum_91414          := idx.account_sum_91414;
      rec.account_num_91414          := idx.account_num_91414;
      rec.account_name_91414         := idx.account_name_91414;
      rec.creditline_id              := idx.creditline_id;
      rec.creditline_no              := idx.creditline_no;
      rec.credit_state               := idx.credit_state;
      rec.credit_status              := idx.credit_status;
      rec.interest_rate_open_date    := idx.interest_rate_open_date;
      rec.reg_region                 := idx.reg_region;
      rec.cnt_contr_for_client       := idx.cnt_contr_for_client;
      rec.commiss_monthly            := idx.commiss_monthly;
      rec.interest_rate_acgn2        := idx.interest_rate_acgn2;
      rec.pr_transh                  := idx.pr_transh;
      rec.main_payment               := idx.main_payment;
      rec.prc_payment                := idx.prc_payment;
      rec.okved                      := idx.okved;
      rec.business                   := idx.business;
      rec.sum_first_turn             := idx.sum_first_turn;
      rec.date_first_turn            := idx.date_first_turn;
      rec.off_date_vnb               := idx.off_date_vnb;
      rec.prc_main_vnb_amount        := idx.prc_main_vnb_amount;
      rec.prc_debt_vnb_amount        := idx.prc_debt_vnb_amount;
      rec.unused_credit_limit_eqv    := idx.unused_credit_limit_eqv;
      rec.unused_credit_limit        := idx.unused_credit_limit;
      rec.pr_defolt_client           := idx.pr_defolt_client;
      rec.pr_problem_client          := idx.pr_problem_client;
      rec.credit_state_ul            := idx.credit_state_ul;
      rec.provis_percent             := idx.provis_percent;
      rec.provis_percent_client      := idx.provis_percent_client;
      rec.overdue_client             := idx.overdue_client;
      rec.claim_gid                  := idx.claim_gid;
      rec.account_sum_91802          := idx.account_sum_91802;
      rec.account_sum_91803          := idx.account_sum_91803;
      rec.account_sum_91704          := idx.account_sum_91704;
      rec.account_sum_91604          := idx.account_sum_91604;
      rec.account_sum_91604_client   := idx.account_sum_91604_client;
      rec.open_abs_dep_code          := idx.open_abs_dep_code;
      rec.open_abs_dep_name          := idx.open_abs_dep_name;
      rec.serv_department_code       := idx.serv_department_code;
      rec.serv_department_name       := idx.serv_department_name;
      rec.serv_department_city       := idx.serv_department_city;
      rec.serv_department_region     := idx.serv_department_region;
      rec.serv_dep_branch_name       := idx.serv_dep_branch_name;
      rec.serv_dep_branch_code       := idx.serv_dep_branch_code;
      rec.open_dep_branch_name       := idx.open_dep_branch_name;
      rec.open_dep_branch_code       := idx.open_dep_branch_code;
      rec.adv_account                := idx.adv_account;
      rec.type_restruct              := idx.type_restruct;
      rec.rate_first_day             := idx.rate_first_day;
      rec.sum_contr_for_client       := idx.sum_contr_for_client;
      rec.cl_ogrn                    := idx.cl_ogrn;
      rec.pr_annuitet_pay            := idx.pr_annuitet_pay;
      rec.pr_differ_pay              := idx.pr_differ_pay;
      rec.over_principal             := idx.over_principal;
      rec.cnt_pays_od_on_debt        := idx.cnt_pays_od_on_debt;
      rec.amount_eqv                 := idx.amount_eqv;
      rec.amount                     := idx.amount;
      rec.prc_to_main                := idx.prc_to_main;
      rec.amount_debt                := idx.amount_debt;
      rec.amount_pay_eqv             := idx.amount_pay_eqv;
      rec.fee_eqv                    := idx.fee_eqv;
      rec.cnt_overdue_client         := idx.cnt_overdue_client;
      rec.interest                   := idx.interest;
      rec.interest_eqv               := idx.interest_eqv;
      rec.sum_pay_od_main            := idx.sum_pay_od_main;
      rec.sum_pay_od_debt            := idx.sum_pay_od_debt;
      rec.max_sum_overdue_client     := idx.max_sum_overdue_client;
      rec.max_cnt_day_overdue_client := idx.max_cnt_day_overdue_client;
      rec.max_fifo_for_client        := idx.max_fifo_for_client;
      PIPE ROW(rec);
  END LOOP;
END GetCredits;

PROCEDURE compress_hist_table(inTable IN VARCHAR2, vOut OUT VARCHAR2)
  IS
    vTabOwner VARCHAR2(256);
    vTabName VARCHAR2(256);
    vIdxOwner VARCHAR2(256);
    vIdxName VARCHAR2(256);
    buff VARCHAR2(32700);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vMes VARCHAR2(4000);
BEGIN
  vMes := 'START :: Procedure "dm_skb.pkg_etl_ctr_signs.compress_hist_table" :: Compressing';
  dm_skb.pr_log_write(lower(inTable),vMes);
  -- Вычисление и сохранение в переменные схемы - владельца и наименования таблицы
  SELECT UPPER(SUBSTR(inTable,1,INSTR(inTable,'.') - 1)) AS vTabOwner
        ,UPPER(SUBSTR(inTable,INSTR(inTable,'.') + 1,LENGTH(inTable) - INSTR(inTable,'.'))) AS vTabName
    INTO vTabOwner,vTabName
    FROM dual;
  -- Получение наименования индекса
  BEGIN
    SELECT owner AS idx_owner,index_name AS idx_name
      INTO vIdxOwner,vIdxName 
      FROM all_indexes WHERE table_owner = vTabOwner AND table_name = vTabName;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    vIdxOwner := NULL;
    vIdxName := NULL;
  END;
  -- Формирование SQL
  FOR prt IN (
    SELECT subpartition_name
      FROM all_tab_subpartitions
      WHERE table_owner = vTabOwner AND table_name = vTabName
  ) LOOP
    buff := 'ALTER TABLE '||LOWER(vTabOwner)||'.'||LOWER(vTabName)||' MOVE SUBPARTITION '||prt.subpartition_name||' COMPRESS';
    EXECUTE IMMEDIATE buff;
    buff := 'ALTER INDEX '||LOWER(vIdxOwner)||'.'||LOWER(vIdxName)||' REBUILD SUBPARTITION '||prt.subpartition_name;
    EXECUTE IMMEDIATE buff;
  END LOOP;
  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "dm_skb.pkg_etl_ctr_signs.compress_hist_table" :: Compressing in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' successfully';
  dm_skb.pr_log_write(lower(inTable),vMes);
  vOut := 'Table "'||LOWER(inTable)||'" compressed in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' successfully';
EXCEPTION WHEN OTHERS THEN
  vOut := 'ERROR :: Compressing table "'||LOWER(inTable)||'" :: '||SQLERRM;
END compress_hist_table;  

PROCEDURE load_creds_new(inBegDate IN DATE,inEndDate IN DATE)
  IS
    vDays INTEGER;
    vMes VARCHAR2(2000);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vTIBegin DATE;
BEGIN
  vDays := inEndDate - inBegDate;
  vMes := 'START :: Procedure "dm_skb.pkg_etl_ctr_signs.load_creds_new" started.';
  dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_creds_new',vMes);
  FOR idx IN 0..vDays
  LOOP
    dm_clant.truncate_my_any_table('dm_clant.ptb_creds_in_work',vMes,'P'||to_char(inBegDate+idx,'YYYYMMDD'));
    IF vMes LIKE 'ERROR%ORA%02149%' THEN
      dm_clant.my_execute('ALTER TABLE dm_clant.ptb_creds_in_work ADD PARTITION P'||to_char(inBegDate+idx,'YYYYMMDD')||' VALUES(to_date('''||to_char(inBegDate+idx,'DD.MM.YYYY')||''',''DD.MM.YYYY''))',vMes);   
    END IF;
    IF vMes = 'Ok' THEN
      vMes := 'SUCCESSFULLY :: Table "dm_clant.ptb_creds_in_work" altered. Partition '||to_char(inBegDate+idx,'YYYYMMDD')||' added';
    END IF;      
    dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_creds_new',vMes);
    
    vTIBegin := SYSDATE;
    INSERT INTO dm_clant.ptb_creds_in_work (as_of_date,
                                            contract_gid,
                                            source_system_id,
                                            contract_sid,
                                            client_sid,
                                            abs_department_sid,
                                            open_abs_dep_sid,
                                            serv_department_sid,
                                            created_by_employee_sid,
                                            contract_type_sid,
                                            product_group_sid,
                                            p_id,
                                            rate_of_exchange)
      WITH
        a2c AS (
          SELECT /*+ materialize no_index(tu) */
                 ac.contract_sid
            FROM dwh.ref_contract_new ctr
                 INNER JOIN dm_skb.tb_account_to_credit ac
                   ON ac.contract_sid = ctr.contract_gid*10+ctr.source_system_id
                 LEFT JOIN dwh.fct_account_balance_turn tu
                   ON tu.account_sid = ac.account_sid
                      AND tu.source_system_id = ac.source_system_id
                      AND tu.balance_date = inBegDate+idx
            WHERE ctr.column_name = 'INSTRUMENT_ID'
              AND ctr.end_date = to_date('31.12.5999','DD.MM.YYYY')
              AND inBegDate+idx BETWEEN ctr.effective_start AND ctr.effective_end
              AND (ctr.val_num != 5 OR ctr.val_num = 5 AND TRUNC(ac.link_type_sid/10) in (2, 3, 4, 5, 14, 23, 24, 1576, 1577, 992))
              --AND ctr.contract_gid = 6942027 AND ctr.source_system_id = 2
          GROUP BY ac.contract_sid
          MINUS
            SELECT cat.contract_gid*10+cat.source_system_id AS contract_sid
              FROM dwh.ref_contract_new cat
              WHERE cat.column_name = 'CATEGORIES_ID'
                AND cat.end_date = to_date('31.12.5999','DD.MM.YYYY')
                AND inBegDate+idx BETWEEN cat.effective_start AND cat.effective_end   
                AND cat.val_str = 'BANKS_LOANS'
        )
      SELECT inBegDate+idx AS as_of_date
            ,a.contract_gid
            ,a.source_system_id
            ,a.contract_sid
            ,a.client_sid
            ,a.abs_department_sid
            ,NULL AS open_abs_dep_sid
            ,NVL(dwh.f_get_office_sid(ad.abs_department_gid
                                 ,ad.abs_department_parent_sid
                                 ,ad.source_system_id
                                 ,inBegDate+idx
                                 ,ad.abs_department_name),a.abs_department_sid) AS serv_department_sid
            ,a.created_by_employee_sid
            ,a.contract_type_sid
            ,ct.product_group_sid
            ,c2p.p_id
            ,fcr.rate_of_exchange
        FROM (
      SELECT contract_gid*10+source_system_id AS contract_sid
            ,contract_gid
            ,source_system_id
            ,to_number(client_sid) AS client_sid
            ,to_number(abs_department_sid) AS abs_department_sid
            ,to_number(created_by_employee_sid) AS created_by_employee_sid
            ,to_number(contract_type_sid) AS contract_type_sid
            ,cur_id
        FROM (
      SELECT /*+ parallel(5) */
             ctr.contract_gid
            ,ctr.source_system_id
            ,ctr.column_name
            ,COALESCE(to_char(ctr.val_num),ctr.val_str) AS val_num
        FROM  a2c
              INNER JOIN dwh.ref_contract_new ctr
                ON ctr.column_name IN ('CLIENT_SID','ABS_DEPARTMENT_SID','CREATED_BY_EMPLOYEE_SID','CONTRACT_TYPE_SID','CUR_ID')
                   AND ctr.end_date = to_date('31.12.5999','DD.MM.YYYY')
                   AND ctr.contract_gid = TRUNC(a2c.contract_sid/10)
                   AND ctr.source_system_id = MOD(a2c.contract_sid,10)
                   AND inBegDate+idx BETWEEN ctr.effective_start AND ctr.effective_end
      ) PIVOT (MAX(val_num) FOR column_name IN ('CLIENT_SID' AS client_sid,'ABS_DEPARTMENT_SID' AS abs_department_sid
                                               ,'CREATED_BY_EMPLOYEE_SID' AS created_by_employee_sid
                                               ,'CONTRACT_TYPE_SID' AS contract_type_sid,'CUR_ID' AS cur_id
                                               ))
      ) a LEFT JOIN dwh.ref_contract_type ct
            ON ct.contract_type_gid = TRUNC(a.contract_type_sid/10)
               AND ct.source_system_id = MOD(a.contract_type_sid,10)
               AND ct.end_date = to_date('31.12.5999','DD.MM.YYYY')
               AND inBegDate+idx BETWEEN ct.effective_start AND ct.effective_end
          LEFT JOIN dm_clant.tb_ref_contract_2_product c2p
            ON c2p.contract_sid = a.contract_sid
          LEFT JOIN dwh.fct_cur_rate fcr
            ON fcr.cur_rate_date = inBegDate+idx
               AND fcr.cur_id = a.cur_id
          LEFT JOIN dwh.ref_abs_department ad
            ON ad.abs_department_gid = TRUNC(a.abs_department_sid/10)
               AND ad.source_system_id = MOD(a.abs_department_sid,10)
               AND ad.end_date = to_date('31.12.5999','DD.MM.YYYY')
               AND inBegDate+idx BETWEEN ad.effective_start AND ad.effective_end;

    vEndTime := SYSDATE;
    vMes := 'SUCCESSFULLY :: "'||to_char(inBegDate+idx,'DD.MM.YYYY')||'" '||SQL%ROWCOUNT||' rows inserted into table "dm_clant.ptb_creds_in_work" in '||dm_skb.get_ti_as_hms(vEndTime - vTIBegin);
    dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_creds_new',vMes);
    
    dm_clant.compress_my_any_table('dm_clant.ptb_creds_in_work',vMes,'P'||to_char(inBegDate+idx,'YYYYMMDD'));
    dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_creds_new',vMes);
    
    
  END LOOP;
  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "dm_skb.pkg_etl_ctr_signs.load_creds_new" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' successfully';
  dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_creds_new',vMes);
EXCEPTION
  WHEN OTHERS THEN
    vEndTime := SYSDATE;
    vMes := 'ERROR :: Table "dm_clant.ptb_creds_in_work" aggregation failed :: '||SQLERRM;
    dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_creds_new',vMes);
    vMes := 'FINISH :: Procedure "dm_skb.pkg_etl_ctr_signs.load_creds_new" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' with errors';
    dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_creds_new',vMes);
END load_creds_new;    

PROCEDURE load_a2c
  IS
    vMes VARCHAR2(2000);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
BEGIN
  vMes := 'START :: Procedure "dm_skb.pkg_etl_ctr_signs.load_a2c" started.';
  dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_a2c',vMes);

  dm_skb.my_execute('TRUNCATE TABLE dm_skb.tb_account_to_credit',vMes);
  IF vMes = 'Ok' THEN
    vMes := 'SUCCESSFULLY :: Table "dm_skb.tb_account_to_credit" truncated';
  ELSE
    RAISE_APPLICATION_ERROR(-20000,vMes);
  END IF;    
  
  INSERT /*+ APPEND */ 
    INTO dm_skb.tb_account_to_credit (account_sid,contract_sid,source_system_id,link_type_sid)
    SELECT /*+ parallel(4) */
           account_sid,contract_sid,source_system_id,link_type_sid 
    FROM (
      SELECT a.account_sid,a.contract_sid,a.link_type_sid,a.source_system_id
        FROM dwh.ref_account_to_contract a
             INNER JOIN dm_clant.tb_cl_credits c
                ON c.contract_sid = a.contract_sid
        WHERE a.end_date = to_date('31.12.5999','DD.MM.YYYY')
      UNION ALL
      SELECT a.account_sid,a.contract_sid,a.link_type_sid,a.source_system_id
        FROM dwh.ref_account_to_contract2 a
             INNER JOIN dm_clant.tb_cl_credits c
                ON c.contract_sid = a.contract_sid
        WHERE a.end_date = to_date('31.12.5999','DD.MM.YYYY')
    ) GROUP BY account_sid,contract_sid,source_system_id,link_type_sid;
    
  vEndTime := SYSDATE;
  vMes := 'SUCCESSFULLY :: '||SQL%ROWCOUNT||' rows inserted into table "dm_skb.tb_account_to_credit" in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime);
  dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_a2c',vMes);
EXCEPTION
  WHEN OTHERS THEN
    vEndTime := SYSDATE;
    vMes := 'ERROR :: Table "dm_skb.tb_account_to_credit" aggregation failed :: '||SQLERRM;
    dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_a2c',vMes);
    vMes := 'FINISH :: Procedure "dm_skb.pkg_etl_ctr_signs.load_a2c" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' with errors';
    dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_a2c',vMes);
END load_a2c;

PROCEDURE load_creds_closed(inBegDate IN DATE, inEndDate IN DATE)  -- не используется
  IS
    vDays INTEGER;
    vMes VARCHAR2(2000);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vTIBegin DATE;
BEGIN
--автоматически не запускается, см Job и процедуру dm_skb.load_creds_closed
  vDays := inEndDate - inBegDate;
  vMes := 'START :: Procedure "dm_skb.pkg_etl_ctr_signs.load_creds_closed" started.';
  dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_creds_closed',vMes);
  FOR idx IN 0..vDays
  LOOP
  
  
  MERGE INTO dm_skb.tb_ciw_closed dest
  USING (
WITH
   
      cr_line AS (
        SELECT /*+ materialize */
               contract_sid
              ,MIN(effective_start) AS effective_start
              ,MAX(effective_end) AS effective_end
          FROM dwh.ref_credit_transh
          WHERE end_date = to_date('31.12.5999','DD.MM.YYYY')
        GROUP BY contract_sid
      )
     ,tb AS (
        SELECT close_fact_date
              ,obj_gid
              ,source_system_id
              ,to_number(uc_id,'FM999999999999999D999999999','nls_numeric_characters='', ''') AS uc_id
              ,to_number(NVL(overdue_principal,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS overdue_principal
              ,to_number(NVL(overdue_principal_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS overdue_principal_eqv
              ,to_number(NVL(overdue_interest,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS overdue_interest
              ,to_number(NVL(overdue_interest_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS overdue_interest_eqv
              ,to_number(NVL(account_sum_91311,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91311
              ,account_num_91311
              ,account_name_91311
              ,to_number(NVL(account_sum_91312,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91312
              ,account_num_91312
              ,account_name_91312
              ,to_number(NVL(account_sum_91313,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91313
              ,account_num_91313
              ,account_name_91313
              ,to_number(NVL(account_sum_91314,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91314
              ,account_num_91314
              ,account_name_91314
              ,to_number(NVL(account_sum_91414,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91414
              ,account_num_91414
              ,account_name_91414
              ,to_number(creditline_id,'FM999999999999999D999999999','nls_numeric_characters='', ''') AS creditline_id
              ,creditline_no
              ,credit_state
              ,credit_status
              ,to_number(NVL(interest_rate_open_date,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS interest_rate_open_date
              ,reg_region
              ,to_number(NVL(cnt_contr_for_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS cnt_contr_for_client
              ,to_number(NVL(commiss_monthly,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS commiss_monthly
              ,to_number(NVL(interest_rate_acgn2,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS interest_rate_acgn2
              ,to_number(pr_transh,'FM999999999999999D999999999','nls_numeric_characters='', ''') AS pr_transh
              ,to_number(NVL(main_payment,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS main_payment
              ,to_number(NVL(prc_payment,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS prc_payment
              ,okved
              ,business
              ,to_number(NVL(sum_first_turn_ibso,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') +
               to_number(NVL(sum_first_turn_3card,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS sum_first_turn
              ,to_date(date_first_turn,'DD.MM.YYYY') AS date_first_turn
              ,to_date(off_date_vnb,'DD.MM.YYYY') AS off_date_vnb
              ,to_number(NVL(prc_main_vnb_amount,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS prc_main_vnb_amount
              ,to_number(NVL(prc_debt_vnb_amount,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS prc_debt_vnb_amount
              ,to_number(NVL(unused_credit_limit_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS unused_credit_limit_eqv
              ,to_number(NVL(unused_credit_limit,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS unused_credit_limit
              ,to_char(to_number(pr_defolt_client,'FM999999999999999D999999999','nls_numeric_characters='', ''')) AS pr_defolt_client
              ,to_char(to_number(pr_problem_client,'FM999999999999999D999999999','nls_numeric_characters='', ''')) AS pr_problem_client
              ,credit_state_ul
              ,to_number(NVL(max_fifo_for_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS max_fifo_for_client
              ,to_number(NVL(provis_percent,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS provis_percent
              ,to_number(NVL(provis_percent_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS provis_percent_client
              ,to_number(NVL(overdue_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS overdue_client
              ,to_number(claim_gid,'FM999999999999999D999999999','nls_numeric_characters='', ''') AS claim_gid
              ,to_number(NVL(account_sum_91802,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91802
              ,to_number(NVL(account_sum_91803,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91803
              ,to_number(NVL(account_sum_91704,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91704
              ,to_number(NVL(account_sum_91604,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91604
              ,to_number(NVL(account_sum_91604_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91604_client
              ,open_abs_dep_code
              ,open_abs_dep_name
              ,serv_department_code
              ,serv_department_name
              ,serv_department_city
              ,serv_department_region
              ,serv_dep_branch_name
              ,serv_dep_branch_code
              ,open_dep_branch_name
              ,open_dep_branch_code
              ,adv_account
              ,type_restruct
              ,to_number(rate_first_day,'FM999999999999999D999999999','nls_numeric_characters='', ''') AS rate_first_day
              ,cl_ogrn
              ,pr_annuitet_pay
              ,pr_differ_pay
              ,OVER_PRINCIPAL
          FROM (
            SELECT c.close_fact_date
                  ,s.source_system_id
                  ,s.obj_gid
                  ,s.sign_name
                  ,s.sign_val
              FROM dm_skb.tb_ctr_signs_new s
                   INNER JOIN dm_skb.tb_cl_credits_closed c
                     ON s.sign_name IN ('OVERDUE_PRINCIPAL','OVERDUE_PRINCIPAL_EQV','OVERDUE_INTEREST','OVERDUE_INTEREST_EQV'
                                     ,'ACCOUNT_SUM_91311','ACCOUNT_NUM_91311','ACCOUNT_NAME_91311'
                                     ,'ACCOUNT_SUM_91312','ACCOUNT_NUM_91312','ACCOUNT_NAME_91312'
                                     ,'ACCOUNT_SUM_91313','ACCOUNT_NUM_91313','ACCOUNT_NAME_91313'
                                     ,'ACCOUNT_SUM_91314','ACCOUNT_NUM_91314','ACCOUNT_NAME_91314'
                                     ,'ACCOUNT_SUM_91414','ACCOUNT_NUM_91414','ACCOUNT_NAME_91414'
                                     ,'CREDITLINE_ID','CREDITLINE_NO'
                                     ,'CREDIT_STATE','CREDIT_STATUS','INTEREST_RATE_OPEN_DATE','REG_REGION'
                                     ,'CNT_CONTR_FOR_CLIENT', 'COMMISS_MONTHLY','INTEREST_RATE_ACGN2','PR_TRANSH'
                                     ,'MAIN_PAYMENT','PRC_PAYMENT','OKVED','BUSINESS','SUM_FIRST_TURN','DATE_FIRST_TURN'
                                     ,'PRC_MAIN_VNB_AMOUNT','PRC_DEBT_VNB_AMOUNT','OFF_DATE_VNB'
                                     ,'UNUSED_CREDIT_LIMIT_EQV','UNUSED_CREDIT_LIMIT','SUM_FIRST_TURN_IBSO','SUM_FIRST_TURN_3CARD'
                                     ,'UC_ID','PR_DEFOLT_CLIENT','PR_PROBLEM_CLIENT','CREDIT_STATE_UL','MAX_FIFO_FOR_CLIENT'
                                     ,'PROVIS_PERCENT','PROVIS_PERCENT_CLIENT','OVERDUE_CLIENT'
                                     ,'CLAIM_GID','ACCOUNT_SUM_91802','ACCOUNT_SUM_91803','ACCOUNT_SUM_91704','ACCOUNT_SUM_91604'
                                     ,'ACCOUNT_SUM_91604_CLIENT'
                                     ,'OPEN_ABS_DEP_CODE','OPEN_ABS_DEP_NAME'
                                     ,'SERV_DEPARTMENT_CODE','SERV_DEPARTMENT_NAME'
                                     ,'SERV_DEPARTMENT_CITY','SERV_DEPARTMENT_REGION','SERV_DEP_BRANCH_NAME','SERV_DEP_BRANCH_CODE'
                                     ,'OPEN_DEP_BRANCH_CODE','OPEN_DEP_BRANCH_NAME'
                                     ,'ADV_ACCOUNT','TYPE_RESTRUCT','RATE_FIRST_DAY', 'CL_OGRN', 'PR_ANNUITET_PAY', 'PR_DIFFER_PAY', 'OVER_PRINCIPAL'
                                     )
                        AND s.obj_gid = c.contract_gid
                        AND c.source_system_id = c.source_system_id
                        AND c.close_fact_date BETWEEN s.effective_start AND s.effective_end
                        AND c.close_fact_date = inBegDate + idx
          ) PIVOT (MAX(sign_val)
              FOR sign_name IN (
                'OVERDUE_PRINCIPAL' AS        overdue_principal
               ,'OVERDUE_PRINCIPAL_EQV' AS    overdue_principal_eqv
               ,'OVERDUE_INTEREST' AS         overdue_interest
               ,'OVERDUE_INTEREST_EQV' AS     overdue_interest_eqv
               ,'ACCOUNT_SUM_91311' AS        account_sum_91311
               ,'ACCOUNT_NUM_91311' AS        account_num_91311
               ,'ACCOUNT_NAME_91311' AS       account_name_91311
               ,'ACCOUNT_SUM_91312' AS        account_sum_91312
               ,'ACCOUNT_NUM_91312' AS        account_num_91312
               ,'ACCOUNT_NAME_91312' AS       account_name_91312
               ,'ACCOUNT_SUM_91313' AS        account_sum_91313
               ,'ACCOUNT_NUM_91313' AS        account_num_91313
               ,'ACCOUNT_NAME_91313' AS       account_name_91313
               ,'ACCOUNT_SUM_91314' AS        account_sum_91314
               ,'ACCOUNT_NUM_91314' AS        account_num_91314
               ,'ACCOUNT_NAME_91314' AS       account_name_91314
               ,'ACCOUNT_SUM_91414' AS        account_sum_91414
               ,'ACCOUNT_NUM_91414' AS        account_num_91414
               ,'ACCOUNT_NAME_91414' AS       account_name_91414
               ,'CREDITLINE_ID' AS            creditline_id
               ,'CREDITLINE_NO' AS            creditline_no
               ,'CREDIT_STATE' AS             credit_state
               ,'CREDIT_STATUS' AS            credit_status
               ,'INTEREST_RATE_OPEN_DATE' AS  interest_rate_open_date
               ,'REG_REGION' AS               reg_region
               ,'CNT_CONTR_FOR_CLIENT' AS     cnt_contr_for_client
               ,'COMMISS_MONTHLY' AS          commiss_monthly
               ,'INTEREST_RATE_ACGN2' AS      interest_rate_acgn2
               ,'PR_TRANSH' AS                pr_transh
               ,'MAIN_PAYMENT' AS             main_payment
               ,'PRC_PAYMENT' AS              prc_payment
               ,'OKVED' AS                    okved
               ,'BUSINESS' AS                 business
               ,'SUM_FIRST_TURN_IBSO' AS      sum_first_turn_ibso
               ,'SUM_FIRST_TURN_3CARD' AS     sum_first_turn_3card
               ,'DATE_FIRST_TURN' AS          date_first_turn
               ,'OFF_DATE_VNB' AS             off_date_vnb
               ,'PRC_MAIN_VNB_AMOUNT' AS      prc_main_vnb_amount
               ,'PRC_DEBT_VNB_AMOUNT' AS      prc_debt_vnb_amount
               ,'UNUSED_CREDIT_LIMIT_EQV' AS  unused_credit_limit_eqv
               ,'UNUSED_CREDIT_LIMIT' AS      unused_credit_limit
               ,'UC_ID' AS                    uc_id
               ,'PR_DEFOLT_CLIENT' AS         pr_defolt_client
               ,'PR_PROBLEM_CLIENT' AS        pr_problem_client
               ,'CREDIT_STATE_UL' AS          credit_state_ul
               ,'MAX_FIFO_FOR_CLIENT' AS      max_fifo_for_client
               ,'PROVIS_PERCENT' AS           provis_percent
               ,'PROVIS_PERCENT_CLIENT' AS    provis_percent_client
               ,'OVERDUE_CLIENT' AS           overdue_client
               ,'CLAIM_GID' AS                claim_gid
               ,'ACCOUNT_SUM_91802' AS        account_sum_91802
               ,'ACCOUNT_SUM_91803' AS        account_sum_91803
               ,'ACCOUNT_SUM_91704' AS        account_sum_91704
               ,'ACCOUNT_SUM_91604' AS        account_sum_91604
               ,'ACCOUNT_SUM_91604_CLIENT' AS account_sum_91604_client
               ,'OPEN_ABS_DEP_CODE'        AS open_abs_dep_code
               ,'OPEN_ABS_DEP_NAME'        AS open_abs_dep_name
               ,'SERV_DEPARTMENT_CODE'     AS serv_department_code
               ,'SERV_DEPARTMENT_NAME'     AS serv_department_name
               ,'SERV_DEPARTMENT_CITY'     AS serv_department_city
               ,'SERV_DEPARTMENT_REGION'   AS serv_department_region
               ,'SERV_DEP_BRANCH_NAME'     AS serv_dep_branch_name
               ,'SERV_DEP_BRANCH_CODE'     AS serv_dep_branch_code
               ,'OPEN_DEP_BRANCH_NAME'     AS open_dep_branch_name
               ,'OPEN_DEP_BRANCH_CODE'     AS open_dep_branch_code
               ,'ADV_ACCOUNT'              AS adv_account
               ,'TYPE_RESTRUCT'            AS type_restruct
               ,'RATE_FIRST_DAY'           AS rate_first_day
               ,'CL_OGRN' AS        CL_OGRN        
               ,'PR_ANNUITET_PAY' as pr_annuitet_pay
               ,'PR_DIFFER_PAY' as pr_differ_pay
               ,'OVER_PRINCIPAL' as OVER_PRINCIPAL
              )
            )
      )
     ,ptb AS (
        SELECT as_of_date
              ,obj_gid
              ,source_system_id
              ,to_number(NVL(cnt_pays_od_on_debt,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')        AS cnt_pays_od_on_debt
              ,to_number(NVL(amount_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                 AS amount_eqv
              ,to_number(NVL(amount,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                     AS amount
              ,to_number(NVL(prc_to_main,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                AS prc_to_main
              ,to_number(NVL(amount_debt,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                AS amount_debt
              ,to_number(NVL(amount_pay_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')             AS amount_pay_eqv
              ,to_number(NVL(fee_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                    AS fee_eqv
              ,to_number(NVL(cnt_overdue_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')         AS cnt_overdue_client
              ,to_number(NVL(interest,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                   AS interest
              ,to_number(NVL(interest_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')               AS interest_eqv
              ,to_number(NVL(sum_pay_od_main,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')            AS sum_pay_od_main
              ,to_number(NVL(sum_pay_od_debt,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')            AS sum_pay_od_debt
              ,to_number(NVL(max_sum_overdue_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')     AS max_sum_overdue_client
              ,to_number(NVL(max_cnt_day_overdue_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS max_cnt_day_overdue_client
          FROM (
            SELECT s.as_of_date
                  ,s.obj_gid
                  ,s.source_system_id
                  ,s.sign_name
                  ,s.sign_val
            FROM dm_skb.tb_cl_credits_closed c
                 INNER JOIN dm_skb.ptb_ctr_signs_new s
                   ON s.sign_name IN ('CNT_PAYS_OD_ON_DEBT','AMOUNT_EQV','AMOUNT'
                                     ,'PRC_TO_MAIN'
                                     ,'AMOUNT_DEBT','AMOUNT_PAY_EQV'
                                     ,'FEE_EQV','CNT_OVERDUE_CLIENT','INTEREST','INTEREST_EQV','SUM_PAY_OD_MAIN','SUM_PAY_OD_DEBT'
                                     ,'MAX_SUM_OVERDUE_CLIENT','MAX_CNT_DAY_OVERDUE_CLIENT'
                                     )
                      AND s.obj_gid = c.contract_gid --ИСПРАВЛЕНО YAI 02/02/2018
                      AND s.source_system_id = c.source_system_id
                      AND s.as_of_date = c.close_fact_date
                      AND c.close_fact_date = inBegDate + idx
          ) PIVOT (MAX(sign_val)
              FOR sign_name IN (
                'CNT_PAYS_OD_ON_DEBT'        AS cnt_pays_od_on_debt
               ,'AMOUNT_EQV'                 AS amount_eqv
               ,'AMOUNT'                     AS amount
               ,'PRC_TO_MAIN'                AS prc_to_main
               ,'AMOUNT_DEBT'                AS amount_debt
               ,'AMOUNT_PAY_EQV'             AS amount_pay_eqv
               ,'FEE_EQV'                    AS fee_eqv
               ,'CNT_OVERDUE_CLIENT'         AS cnt_overdue_client
               ,'INTEREST'                   AS interest
               ,'INTEREST_EQV'               AS interest_eqv
               ,'SUM_PAY_OD_MAIN'            AS sum_pay_od_main
               ,'SUM_PAY_OD_DEBT'            AS sum_pay_od_debt
               ,'MAX_SUM_OVERDUE_CLIENT'     AS max_sum_overdue_client
               ,'MAX_CNT_DAY_OVERDUE_CLIENT' AS max_cnt_day_overdue_client
              )
            )
      )
     ,v AS (
        SELECT as_of_date
              ,contract_gid
              ,source_system_id
              ,off_main_debt_vnb
              ,off_prc_vnb
              ,off_other_pays_vnb
          FROM (
            SELECT s.as_of_date
                  ,s.contract_gid
                  ,s.source_system_id
                  ,s.code AS ctr_idx
                  ,s.value_ AS ctr_val
            FROM dm_skb.tb_cl_credits_closed c
                 INNER JOIN dm_skb.dm_creds_in_work_values_val s
                   ON s.code IN ('OFF_MAIN_DEBT_VNB','OFF_PRC_VNB','OFF_OTHER_PAYS_VNB')
                      AND s.contract_gid = c.contract_gid
                      AND s.source_system_id = c.source_system_id
                      AND s.as_of_date = c.close_fact_date
                      AND c.close_fact_date = inBegDate + idx
          ) PIVOT (MAX(ctr_val)
              FOR ctr_idx IN (
                'OFF_MAIN_DEBT_VNB'  AS off_main_debt_vnb
               ,'OFF_PRC_VNB'        AS off_prc_vnb
               ,'OFF_OTHER_PAYS_VNB' AS off_other_pays_vnb
              )
            )
      )
     ,c AS (
        SELECT contract_gid
              ,source_system_id
              ,to_date(open_date,'DD.MM.YYYY') AS open_date
            
            --2017-10  
          /* ,case
           when ctr.source_system_id = 2 then
             case
               when c.instrument_id = 5 or pg.PRODUCT_GROUP_NAME in ('Экспресс-кредиты','Потребительский кредит') then        coalesce(new_date_info.dtef, new_date_info.dtst)
               when pg.PRODUCT_GROUP_NAME in ('Овердрафты') then           coalesce(new_date_info.ovef, new_date_info.dtef, new_date_info.dtst)
             end 
           else to_date(open_date,'DD.MM.YYYY') 
         end open_date*/
            --2017-10  
           ,to_date(close_date,'DD.MM.YYYY') AS close_date            
          /*,case
           when ctr.source_system_id = 2 then
             case
               when c.instrument_id = 5 or  pg.product_group_name in ('Экспресс-кредиты','Потребительский кредит') then   new_date_info.dtex
               when pg.product_group_name in ('Овердрафты') then         coalesce(new_date_info.ovex, new_date_info.dtex)
             end 
           else to_date(close_date,'DD.MM.YYYY')
         end close_date*/

              ,close_fact_date
              ,to_number(cur_id) AS cur_id
              ,to_number(principal) AS principal
              ,contract_no
              ,to_number(NVL(interest_rate_of_agreement,'0')) AS interest_rate_of_agreement
              ,to_number(loan_quality_cod) AS loan_quality_cod
              ,to_number(contract_type_sid) AS contract_type_sid
              ,loan_type
              ,to_number(restruct_code) AS restruct_code
              ,to_number(created_by_employee_sid) AS created_by_employee_sid
              ,to_number(client_sid) AS client_sid
              ,to_number(abs_department_sid) AS abs_department_sid
          FROM (
            SELECT c.close_fact_date
                  ,s.contract_gid
                  ,s.source_system_id
                  ,s.column_name AS ctr_idx
                  ,COALESCE(to_char(s.val_num),s.val_str,to_char(s.val_date,'DD.MM.YYYY')) AS ctr_val
                FROM dm_skb.tb_cl_credits_closed c
                     INNER JOIN dwh.ref_contract_new s
                       ON s.column_name IN ('OPEN_DATE','CLOSE_DATE','CONTRACT_TYPE_SID','LOAN_TYPE'
                                           ,'CUR_ID','PRINCIPAL','CONTRACT_NO','INTEREST_RATE_OF_AGREEMENT','LOAN_QUALITY_COD'
                                           ,'RESTRUCT_CODE','CREATED_BY_EMPLOYEE_SID','CLIENT_SID','ABS_DEPARTMENT_SID'
                                           )
                          AND s.end_date = to_date('31.12.5999','DD.MM.YYYY')
                          AND s.contract_gid = c.contract_gid
                          AND s.source_system_id = c.source_system_id
                          AND c.close_fact_date BETWEEN s.effective_start AND s.effective_end
                          AND c.close_fact_date = inBegDate + idx
          ) PIVOT (MAX(ctr_val)
              FOR ctr_idx IN (
                'OPEN_DATE' AS                       open_date
               ,'CLOSE_DATE' AS                      close_date
               ,'CUR_ID' AS                          cur_id
               ,'PRINCIPAL' AS                       principal
               ,'CONTRACT_NO' AS                     contract_no
               ,'INTEREST_RATE_OF_AGREEMENT' AS      interest_rate_of_agreement
               ,'LOAN_QUALITY_COD' AS                loan_quality_cod
               ,'CONTRACT_TYPE_SID' AS               contract_type_sid
               ,'LOAN_TYPE' AS                       loan_type
               ,'RESTRUCT_CODE' AS                   restruct_code
               ,'CREATED_BY_EMPLOYEE_SID' AS         created_by_employee_sid
               ,'CLIENT_SID' AS                      client_sid
               ,'ABS_DEPARTMENT_SID' AS              abs_department_sid
              )
            )
      )
     ,cl AS (
        SELECT close_fact_date
              ,client_gid
              ,source_system_id
              ,tin
              ,client_type_flg
              ,name
              ,short_name
              ,ogrn
              ,okopf
              ,okato
              ,fin_state
          FROM (
            SELECT c.close_fact_date
                  ,s.client_gid
                  ,s.source_system_id
                  ,s.column_name AS ctr_idx
                  ,COALESCE(to_char(s.val_num),s.val_str,to_char(s.val_date,'DD.MM.YYYY')) AS ctr_val
                FROM dm_skb.tb_cl_credits_closed c
                     INNER JOIN dwh.ref_client_new s
                       ON s.column_name IN ('TIN','CLIENT_TYPE_FLG','NAME','SHORT_NAME','OGRN','OKOPF','OKATO','FIN_STATE')
                          AND s.end_date = to_date('31.12.5999','DD.MM.YYYY')
                          AND s.client_gid = c.client_gid
                          AND s.source_system_id = c.source_system_id
                          AND c.close_fact_date BETWEEN s.effective_start AND s.effective_end
                          AND c.close_fact_date = inBegDate + idx
          ) PIVOT (MAX(ctr_val)
              FOR ctr_idx IN (
                'TIN' AS               tin
               ,'CLIENT_TYPE_FLG' AS   client_type_flg
               ,'NAME' AS              name
               ,'SHORT_NAME' AS        short_name
               ,'OGRN' AS              ogrn
               ,'OKOPF' AS             okopf
               ,'OKATO' AS             okato
               ,'FIN_STATE' AS         fin_state
              )
            )
      )
     ,spec AS (
        SELECT close_fact_date
              ,contract_gid
              ,source_system_id
              ,to_date(delinq_date_fifo,'DD.MM.YYYY') AS delinq_date_fifo
              ,to_date(delinq_date_lifo,'DD.MM.YYYY') AS delinq_date_lifo
              ,to_date(delinquency_interest_date,'DD.MM.YYYY') AS delinquency_interest_date
              ,to_number(NVL(rez_percent,'0')) AS rez_percent
              ,to_number(NVL(interest_rate,'0')) AS interest_rate
              ,to_number(loan_quality_cod_spec) AS loan_quality_cod_spec
              ,to_number(NVL(account_interest_rate,'0')) AS account_interest_rate
              ,to_number(NVL(effective_rate,'0')) AS effective_rate
              ,to_number(port_sid) AS port_sid
              ,to_number(loan_source_sid) AS loan_source_sid
              ,to_number(loan_object_sid) AS loan_object_sid
              ,to_number(loan_state) AS loan_state
              ,to_number(fin_state) AS fin_state
          FROM (
            SELECT c.close_fact_date
                  ,s.contract_gid
                  ,s.source_system_id
                  ,CASE s.column_name
                     WHEN 'FIFO_DELINQUENCY_DATE' THEN 'DELINQ_DATE_FIFO'
                     WHEN 'DELINQUENCY_DATE' THEN 'DELINQ_DATE_LIFO'
                     WHEN 'LOAN_QUALITY_COD' THEN 'LOAN_QUALITY_COD_SPEC'
                   ELSE s.column_name
                   END AS ctr_idx
                  ,COALESCE(to_char(s.val_num),s.val_str,to_char(s.val_date,'DD.MM.YYYY')) AS ctr_val
              FROM dm_skb.tb_cl_credits_closed c
                   INNER JOIN dwh.ref_contract_spec_new s
                     ON s.column_name IN ('FIFO_DELINQUENCY_DATE','DELINQUENCY_DATE','DELINQUENCY_INTEREST_DATE','REZ_PERCENT'
                                     ,'INTEREST_RATE','LOAN_QUALITY_COD','ACCOUNT_INTEREST_RATE','EFFECTIVE_RATE','PORT_SID'
                                     ,'LOAN_SOURCE_SID','LOAN_OBJECT_SID','LOAN_STATE','FIN_STATE'
                                     )
                        AND s.end_date = to_date('31.12.5999','DD.MM.YYYY')
                        AND s.contract_gid = c.contract_gid
                        AND s.source_system_id = c.source_system_id
                        AND c.close_fact_date BETWEEN s.effective_start AND s.effective_end
                        AND c.close_fact_date = inBegDate + idx
          ) PIVOT (MAX(ctr_val)
              FOR ctr_idx IN (
                'DELINQ_DATE_FIFO'          AS delinq_date_fifo
               ,'DELINQ_DATE_LIFO'          AS delinq_date_lifo
               ,'DELINQUENCY_INTEREST_DATE' AS delinquency_interest_date
               ,'REZ_PERCENT'               AS rez_percent
               ,'INTEREST_RATE'             AS interest_rate
               ,'LOAN_QUALITY_COD_SPEC'     AS loan_quality_cod_spec
               ,'ACCOUNT_INTEREST_RATE'     AS account_interest_rate
               ,'EFFECTIVE_RATE'            AS effective_rate
               ,'PORT_SID'                  AS port_sid
               ,'LOAN_SOURCE_SID'           AS loan_source_sid
               ,'LOAN_OBJECT_SID'           AS loan_object_sid
               ,'LOAN_STATE'                AS loan_state
               ,'FIN_STATE'                 AS fin_state
              )
            )
      )
     ,emp AS (
        SELECT /*+ result_cache */
               employee_gid
              ,source_system_id
              ,val_str
              ,effective_start
              ,effective_end
          FROM dwh.ref_employees_for_dm
          WHERE column_name = 'EMPLOYEE_NAME'
            AND end_date = to_date('31.12.5999','DD.MM.YYYY')
      )
     ,spec_first_fin AS (
        SELECT /*+ result_cache */ DISTINCT 
               s.contract_gid
              ,s.source_system_id
              ,s.val_num AS ctr_val
              ,s.effective_start
              ,s.effective_end
          FROM dwh.ref_contract_spec_new s
               INNER JOIN dm_skb.tb_cl_credits_closed c
                 ON s.column_name = 'FIN_STATE'
                    AND s.end_date = to_date('31.12.5999','DD.MM.YYYY')
                    AND s.contract_gid = c.contract_gid
                    AND s.source_system_id = c.source_system_id
                    AND c.close_fact_date BETWEEN s.effective_start AND s.effective_end
      )
     ,spec_first_loan AS (
        SELECT /*+ result_cache */ DISTINCT
               s.contract_gid
              ,s.source_system_id
              ,s.val_num AS ctr_val
              ,s.effective_start
              ,s.effective_end
          FROM dwh.ref_contract_spec_new s
               INNER JOIN dm_skb.tb_cl_credits_closed c
                 ON s.column_name = 'LOAN_STATE'
                    AND s.end_date = to_date('31.12.5999','DD.MM.YYYY')
                    AND s.contract_gid = c.contract_gid
                    AND s.source_system_id = c.source_system_id
                    AND c.close_fact_date BETWEEN s.effective_start AND s.effective_end
      )
     ,spec_first_lq AS (
        SELECT /*+ result_cache */ DISTINCT
               s.contract_gid
              ,s.source_system_id
              ,s.val_num AS ctr_val
              ,s.effective_start
              ,s.effective_end
          FROM dwh.ref_contract_spec_new s
               INNER JOIN dm_skb.tb_cl_credits_closed c
                 ON s.column_name = 'LOAN_QUALITY_COD'
                    AND s.end_date = to_date('31.12.5999','DD.MM.YYYY')
                    AND s.contract_gid = c.contract_gid
                    AND s.source_system_id = c.source_system_id
                    AND c.close_fact_date BETWEEN s.effective_start AND s.effective_end
      )
     ,cl_first_fin AS (
        SELECT /*+ result_cache */
               s.client_gid
              ,s.source_system_id
              ,s.val_str AS ctr_val
              ,s.effective_start
              ,s.effective_end
          FROM dwh.ref_client_new s
               INNER JOIN dm_skb.tb_cl_credits_closed c
                 ON column_name = 'FIN_STATE'
                    AND end_date = to_date('31.12.5999','DD.MM.YYYY')
                    AND s.client_gid = c.client_gid
                    AND s.source_system_id = c.source_system_id
                    AND c.close_fact_date BETWEEN s.effective_start AND s.effective_end
      )
     ,con_first AS (
        SELECT /*+ result_cache */
               s.contract_gid
              ,s.source_system_id
              ,s.val_num AS ctr_val
              ,s.effective_start
              ,s.effective_end
          FROM dwh.ref_contract_new s
               INNER JOIN dm_skb.tb_cl_credits_closed c
                 ON s.column_name = 'LOAN_QUALITY_COD'
                    AND s.end_date = to_date('31.12.5999','DD.MM.YYYY')
                    AND s.contract_gid = c.contract_gid
                    AND s.source_system_id = c.source_system_id
                    AND c.close_fact_date BETWEEN s.effective_start AND s.effective_end
      )
     ,type_restr_date AS (
        SELECT /*+ result_cache */
               s.obj_gid*10+s.source_system_id AS contract_sid
              ,s.source_system_id
              ,s.sign_val
              ,s.effective_start
              ,s.effective_end
          FROM dm_skb.tb_ctr_signs_new s
               INNER JOIN dm_skb.tb_cl_credits_closed c
                 ON s.sign_name = 'TYPE_RESTRUCT'
                    AND s.obj_gid = TRUNC(c.contract_gid/10)
                    AND s.source_system_id = c.source_system_id
                    AND c.close_fact_date BETWEEN s.effective_start AND s.effective_end
      )
    SELECT ctr.close_fact_date AS as_of_date
          ,ctr.source_system_id
          ,TRUNC(ctr.client_sid/10) client_gid
          ,tb.uc_id
          ,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' THEN 'Ф' ELSE 'Ю' END AS client_type_flg
           --2017-10
          /*
          ,CASE WHEN ctr.source_system_id IN (2,4) OR
                    (INSTR(prt.code,'ФЛ')> 0 ) THEN 'Кредиты ФЛ'
                WHEN INSTR(ct.contract_type_name,'МСБ') > 0 THEN 'Кредиты МСБ'
                WHEN INSTR(ct.contract_type_name,'Корп') > 0 THEN 'Кредиты ЮЛ'
                WHEN INSTR(prt.code,'M6') > 0 OR INSTR(prt.code,'М6') > 0  THEN
                   CASE WHEN c.open_date < to_date('08.02.2012','DD.MM.YYYY') THEN 'Кредиты МСБ' ELSE 'Кредиты ЮЛ' END
                WHEN INSTR(prt.code,'K') > 0 OR INSTR(prt.code,'К') > 0 THEN 'Кредиты ЮЛ'
                WHEN INSTR(prt.code,'M') > 0 OR INSTR(prt.code,'М') > 0 THEN 'Кредиты МСБ'
             ELSE 'Кредиты ФЛ'
           END AS type_of_business
           */
            ,CASE WHEN ctr.contract_sid = 183457045231 THEN 'Кредиты ЮЛ'
                WHEN ctr.source_system_id IN (2,4) OR  (INSTR(prt.code,'ФЛ')> 0 and INSTR(prt.code,'M')=0 and INSTR(prt.code,'М'/*русская М */)=0) THEN 'Кредиты ФЛ'
                WHEN INSTR(ct.contract_type_name,'МСБ') > 0 THEN 'Кредиты МСБ'
                WHEN INSTR(ct.contract_type_name,'Корп') > 0 THEN 'Кредиты ЮЛ'
                WHEN INSTR(prt.code,'M6') > 0 OR INSTR(prt.code,'М6'/*русская М */) > 0  THEN 
                CASE WHEN c.open_date < to_date('08.02.2012','DD.MM.YYYY') THEN 'Кредиты МСБ' ELSE 'Кредиты ЮЛ' END
                WHEN INSTR(prt.code,'K') > 0 OR INSTR(prt.code,'К'/*русская К */) > 0 THEN 'Кредиты ЮЛ'
                WHEN INSTR(prt.code,'M') > 0 OR INSTR(prt.code,'М'/*русская М */) > 0 THEN 'Кредиты МСБ'
                
                ELSE CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' THEN 'Кредиты ФЛ'
                     ELSE CASE WHEN INSTR(prt.code,'M')= 1 
                          OR INSTR(prt.code,'М'/*русская М */) = 1 
                          OR INSTR(COALESCE(tb.creditline_no,c.contract_no),'M')= 1 
                          OR INSTR(COALESCE(tb.creditline_no,c.contract_no),'М'/*русская М */) = 1 
                          OR c.contract_no like '%М%'   THEN 'Кредиты МСБ' 
                          ELSE 'Кредиты ЮЛ'
                       END
                  END
           END AS type_of_business

          ,cl.name AS full_name
          ,cl.short_name
          --2017-10
          --,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 THEN 'Запрещено ДЭБ' ELSE cl.tin END AS tin
          --,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 THEN 'Запрещено ДЭБ' ELSE cl.ogrn END AS ogrn
          --,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 THEN 'Запрещено ДЭБ' ELSE tb.okved END AS okved
          --,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 THEN 'Запрещено ДЭБ' ELSE tb.business END AS business
          --,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 THEN 'Запрещено ДЭБ' ELSE cl.okopf END AS okopf
          --,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 THEN 'Запрещено ДЭБ' ELSE cl.okato END AS okato
          ,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 and cl.tin is not null THEN 'Запрещено ДЭБ' 
                WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 and cl.tin is null THEN null
                 ELSE cl.tin END AS tin
          ,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 and tb.cl_ogrn is not null THEN 'Запрещено ДЭБ' 
                WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 and tb.cl_ogrn is null THEN null
                 ELSE tb.cl_ogrn END AS ogrn
          ,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 and tb.okved is not null THEN 'Запрещено ДЭБ' 
                WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 and tb.okved is null THEN null
                 ELSE tb.okved END AS okved                 
          ,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 and tb.business is not null THEN 'Запрещено ДЭБ' 
                WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 and tb.business is null THEN null
                 ELSE tb.business END AS business                                  
          ,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 and okpf.short_name is not null THEN 'Запрещено ДЭБ' 
                WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 and okpf.short_name is null THEN null
                 ELSE okpf.short_name END AS okopf
          ,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 and cl.okato is not null THEN 'Запрещено ДЭБ' 
                WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 and cl.okato is null THEN null
                 ELSE cl.okato END AS okato

          ,tb.reg_region
          ,tb.overdue_client - tb.account_sum_91604_client AS sum_contr_for_client
          ,tb.cnt_contr_for_client
          ,tb.pr_defolt_client
          ,tb.pr_problem_client
          ,tb.claim_gid AS claim_id
          ,clm.target
          ,clm.claim_user_fio
          ,clm.claim_accept_bbr_fio AS fio_bbr
          ,clm.claim_accept_sb_fio  AS fio_deb
          ,clm.claim_accept_drb_fio AS fio_drb
          ,clm.claim_accept_user    AS fio_decision_claim
          ,COALESCE(tb.creditline_id,tb.obj_gid) AS id_contr
          ,NVL2(tb.creditline_id,tb.obj_gid,NULL) AS transh_gid
          ,COALESCE(tb.creditline_no,c.contract_no) AS contract_no
          ,NVL2(tb.creditline_no,c.contract_no,NULL) AS transh_no
          ,NVL(tb.pr_transh,'0') AS pr_transh
          ,ctr.source_system_id AS source_id_dog
          ,c.cur_id AS CODE
          --ранее до 19.12.2017
          --,to_number(c.principal) AS principal
          --,to_number(c.principal) * NVL(fcr.rate_of_exchange,1) AS principal_rur
          
           --после 19.12.2017
                    ,CASE  when ctr.source_system_id  in (2,4) AND pg.PRODUCT_GROUP_NAME in ('Овердрафты') THEN NVL(to_number(over_principal), to_number(c.principal)) 
                 when ctr.source_system_id in (1,3) AND (lower(ct.contract_type_name) like '%кред%лин%' or lower(ct.contract_type_name) like '%транш%' or lower(ct.contract_type_name) like '%овердрафт%') THEN NVL(to_number(over_principal) ,to_number(c.principal))
                 ELSE to_number(c.principal) END            
          AS principal
          
          
          ,CASE  when ctr.source_system_id  in (2,4) AND pg.PRODUCT_GROUP_NAME in ('Овердрафты') THEN NVL(to_number(over_principal) * NVL(fcr.rate_of_exchange,1), to_number(c.principal) * NVL(fcr.rate_of_exchange,1))
                 when ctr.source_system_id in (1,3) AND (lower(ct.contract_type_name) like '%кред%лин%' or lower(ct.contract_type_name) like '%транш%' or lower(ct.contract_type_name) like '%овердрафт%') THEN NVL(to_number(over_principal) * NVL(fcr.rate_of_exchange,1), to_number(c.principal) * NVL(fcr.rate_of_exchange,1))
                 ELSE to_number(c.principal) * NVL(fcr.rate_of_exchange,1) END            
          AS principal_rur
          
          ,CASE
             WHEN NVL(to_number(c.principal),0) = 0
             THEN
               GREATEST(tb.sum_first_turn,(ptb.amount_eqv + tb.overdue_principal_eqv + tb.unused_credit_limit_eqv))
             ELSE c.principal * NVL(fcr.rate_of_exchange,1)
          END calc_sum_credit
          ,CASE WHEN tb.date_first_turn > ctr.close_fact_date THEN 0 ELSE tb.sum_first_turn END AS sum_first_turn
          ,CASE WHEN tb.date_first_turn > ctr.close_fact_date THEN NULL ELSE tb.date_first_turn END AS date_first_turn
          ,NVL(ctr.close_fact_date,c.close_date)  - CASE WHEN tb.date_first_turn > ctr.close_fact_date THEN NULL ELSE tb.date_first_turn END AS life_term_contr
          ,ctr.close_fact_date - CASE WHEN tb.date_first_turn > ctr.close_fact_date THEN NULL ELSE tb.date_first_turn END AS valid_contr
          --,prod.name_lv0 AS hier_product_name
          ,prod.name_lv0 AS hier_product_name_f
          ,prod.name_lv2 AS business_name_f
          ,prod.name_lv3 AS product_group_name_f
          ,prod.name_lv4 AS product_name_f
          ,c2p.p_id
          ,pg.product_group_name AS group_contract_type
          ,ct.contract_type_name AS contract_type
          ,c.loan_type
          ,so.loan_source_name as loan_source_name
          ,ob.loan_object_name as loan_object_name
          ,c.open_date
          ,CASE WHEN tb.pr_transh = 2 THEN tr.d_beg ELSE NULL END AS open_date_transh
          ,c.close_date
          ,CASE WHEN c.close_fact_date <= ctr.close_fact_date THEN c.close_fact_date ELSE NULL END AS close_fact_date
          ,NVL(tb.main_payment,0) AS main_payment
          ,NVL(tb.prc_payment,0) AS prc_payment
          ,CASE
             WHEN ctr.source_system_id in (2,4) then
               CASE
                 WHEN pg.product_group_name = 'Экспресс-кредиты' THEN 'Аннуитетный'
                 ELSE 'Дифференцированный'
               END
             ELSE
               --'Дифференцированный'
               CASE WHEN pr_annuitet_pay=1 then 'Аннуитетный' 
                    WHEN pr_differ_pay=1 then 'Дифференцированный'
               ELSE null END
           END AS type_payment
          ,NVL(tb.interest_rate_open_date,0) AS interest_rate_open_date
          ,NVL(COALESCE(tb.interest_rate_acgn2,spec.account_interest_rate,spec.interest_rate,0),0) AS interest_rate
          ,tb.rate_first_day
          ,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' THEN
             NVL(tb.commiss_monthly,'0')
           ELSE 0
           END sum_komiss_month
          ,NVL(spec.effective_rate,0) AS effective_rate
          ,CASE WHEN tb.type_restruct IS NOT NULL THEN 1 ELSE 0 END AS pr_restruct
          ,c.restruct_code AS restruct_code
          ,type_restr_date.effective_start AS date_restruct
          ,tb.type_restruct
          ,CASE
            WHEN NVL(c.close_fact_date,to_date('31.12.5999','DD.MM.YYYY')) <= ctr.close_fact_date THEN 'Закрыт'
            WHEN NVL(tb.account_sum_91802,0) + NVL(tb.account_sum_91803,0) + NVL(tb.account_sum_91704,0) + NVL(tb.account_sum_91604,0) > 0
                   AND NVL(ptb.amount_eqv,0) + NVL(tb.overdue_principal_eqv,0) <= 0
              THEN 'На внебалансе'
            ELSE 'Работает'
           END AS status
          ,CASE WHEN tb.credit_state_ul IN ('Кредит действующий','Кредит погашен') THEN NULL ELSE tb.credit_state_ul END AS state
          ,emp.val_str  AS created_by_employee_dog
          ,tb.open_abs_dep_code AS department_code_dog_open
          ,tb.open_abs_dep_name AS department_name_dog_open
          ,tb.serv_department_code AS department_code_dog_issue
          ,tb.serv_department_name AS department_name_dog_issue
          ,tb.open_dep_branch_code AS branch_code_dog_open
          ,tb.open_dep_branch_name AS branch_name_dog_open
          ,tb.serv_dep_branch_code AS branch_code_dog_issue
          ,tb.serv_dep_branch_name AS branch_name_dog_issue
          ,tb.serv_department_city AS serv_dog_city
          ,tb.serv_department_region AS serv_dog_region
          ,tb.adv_account
          ,NVL2(to_char(cr_line.contract_sid),tb.adv_account,NULL) AS adv_account_transh
          ,NVL(ptb.amount,0) AS amount
          ,NVL(ptb.amount_eqv,0) AS amount_eqv
          ,NVL(tb.overdue_principal,0) AS overdue_principal
          ,NVL(tb.overdue_principal_eqv,0) AS overdue_principal_eqv
          ,NVL(ptb.amount,0) + NVL(tb.overdue_principal,0) AS sum_dolg
          ,NVL(ptb.amount_eqv,0) + NVL(tb.overdue_principal_eqv,0) AS sum_dolg_rur
          ,CASE
             WHEN CASE
                    WHEN ctr.source_system_id IN (2,4) OR
                         (INSTR(prt.code,'ФЛ')> 0 /*and INSTR(prt.code,'M')=0 and INSTR(prt.code,'М'\*русская М *\)=0*/) THEN 'Кредиты ФЛ'
                    WHEN INSTR(ct.contract_type_name,'МСБ') > 0 THEN 'Кредиты МСБ'
                    WHEN INSTR(ct.contract_type_name,'Корп') > 0 THEN 'Кредиты ЮЛ'
                    WHEN INSTR(prt.code,'M6') > 0 OR INSTR(prt.code,'М6'/*русская М */) > 0  THEN
                      CASE WHEN c.open_date < to_date('08.02.2012','DD.MM.YYYY') THEN 'Кредиты МСБ' ELSE 'Кредиты ЮЛ' END
                    WHEN INSTR(prt.code,'K') > 0 OR INSTR(prt.code,'К'/*русская К */) > 0 THEN 'Кредиты ЮЛ'
                    WHEN INSTR(prt.code,'M') > 0 OR INSTR(prt.code,'М'/*русская М */) > 0 THEN 'Кредиты МСБ'
                  ELSE 'Кредиты ФЛ'
                  END = 'Кредиты ФЛ' then
               CASE
                 WHEN ctr.close_fact_date - spec.delinq_date_fifo >= 0 THEN
                   NVL(ptb.amount_eqv,0) + NVL(tb.overdue_principal_eqv,0)
                 ELSE
                   0
               END
           ELSE
             CASE
               WHEN NVL(tb.max_fifo_for_client,0) > 0 THEN
                 NVL(ptb.amount_eqv,'0') + NVL(tb.overdue_principal_eqv,'0')
               ELSE
                 0
             END
           END AS PROBLEM_DEBT
           
           --2017-10
          /*,CASE
             WHEN CASE
                    WHEN ctr.source_system_id IN (2,4) OR
                         (INSTR(prt.code,'ФЛ')> 0 ) THEN 'Кредиты ФЛ'
                    WHEN INSTR(ct.contract_type_name,'МСБ') > 0 THEN 'Кредиты МСБ'
                    WHEN INSTR(ct.contract_type_name,'Корп') > 0 THEN 'Кредиты ЮЛ'
                    WHEN INSTR(prt.code,'M6') > 0 OR INSTR(prt.code,'М6') > 0  THEN
                      CASE WHEN c.open_date < to_date('08.02.2012','DD.MM.YYYY') THEN 'Кредиты МСБ' ELSE 'Кредиты ЮЛ' END
                    WHEN INSTR(prt.code,'K') > 0 OR INSTR(prt.code,'К') > 0 THEN 'Кредиты ЮЛ'
                    WHEN INSTR(prt.code,'M') > 0 OR INSTR(prt.code,'М') > 0 THEN 'Кредиты МСБ'
                  ELSE 'Кредиты ФЛ'
                  END = 'Кредиты ЮЛ' then
               CASE
                 WHEN ctr.close_fact_date - spec.delinq_date_fifo >= 30 THEN
                   NVL(ptb.amount_eqv,'0') + NVL(tb.overdue_principal_eqv,0)
                 ELSE
                   0
               END
           ELSE
             CASE
               WHEN NVL(tb.max_fifo_for_client,0) > 30 THEN
                 NVL(ptb.amount_eqv,0) + NVL(tb.overdue_principal_eqv,0)
               ELSE
                 0
             END
           END AS PROBLEM_DEBT_30
           */
            ,CASE
             WHEN CASE
                    WHEN ctr.contract_sid = 183457045231 THEN 'Кредиты ЮЛ'
                    WHEN ctr.source_system_id IN (2,4) OR
                         (INSTR(prt.code,'ФЛ')> 0 and INSTR(prt.code,'M')=0 and INSTR(prt.code,'М'/*русская М */)=0) THEN 'Кредиты ФЛ'
                    WHEN INSTR(ct.contract_type_name,'МСБ') > 0 THEN 'Кредиты МСБ'
                    WHEN INSTR(ct.contract_type_name,'Корп') > 0 THEN 'Кредиты ЮЛ'
                    WHEN INSTR(prt.code,'M6') > 0 OR INSTR(prt.code,'М6'/*русская М */) > 0  THEN
                      CASE WHEN c.open_date < to_date('08.02.2012','DD.MM.YYYY') THEN 'Кредиты МСБ' ELSE 'Кредиты ЮЛ' END
                    WHEN INSTR(prt.code,'K') > 0 OR INSTR(prt.code,'К'/*русская К */) > 0 THEN 'Кредиты ЮЛ'
                    WHEN INSTR(prt.code,'M') > 0 OR INSTR(prt.code,'М'/*русская М */) > 0 THEN 'Кредиты МСБ'
             ELSE CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' THEN 'Кредиты ФЛ'
                  ELSE CASE WHEN INSTR(prt.code,'M')= 1 OR INSTR(prt.code,'М'/*русская М */) = 1 OR
                                 INSTR(COALESCE(tb.creditline_no,c.contract_no),'M')= 1 OR INSTR(COALESCE(tb.creditline_no,c.contract_no),'М'/*русская М */) = 1 OR c.contract_no like '%М%' 
                         THEN 'Кредиты МСБ' ELSE 'Кредиты ЮЛ'
                       END
                  END
             END = 'Кредиты ФЛ' then
               CASE
                 WHEN ctr.close_fact_date - spec.delinq_date_fifo >= 30 THEN
                   NVL(ptb.amount_eqv,'0') + NVL(tb.overdue_principal_eqv,0)
                 ELSE
                   0
               END
           ELSE
             CASE
               WHEN NVL(tb.max_fifo_for_client,0) > 30 THEN
                 NVL(ptb.amount_eqv,0) + NVL(tb.overdue_principal_eqv,0)
               ELSE
                 0
             END
           END AS PROBLEM_DEBT_30
           --2017-10
         /* ,CASE
             WHEN CASE
                    WHEN ctr.source_system_id IN (2,4) OR
                         (INSTR(prt.code,'ФЛ')> 0 ) THEN 'Кредиты ФЛ'
                    WHEN INSTR(ct.contract_type_name,'МСБ') > 0 THEN 'Кредиты МСБ'
                    WHEN INSTR(ct.contract_type_name,'Корп') > 0 THEN 'Кредиты ЮЛ'
                    WHEN INSTR(prt.code,'M6') > 0 OR INSTR(prt.code,'М6') > 0  THEN
                      CASE WHEN c.open_date < to_date('08.02.2012','DD.MM.YYYY') THEN 'Кредиты МСБ' ELSE 'Кредиты ЮЛ' END
                    WHEN INSTR(prt.code,'K') > 0 OR INSTR(prt.code,'К') > 0 THEN 'Кредиты ЮЛ'
                    WHEN INSTR(prt.code,'M') > 0 OR INSTR(prt.code,'М') > 0 THEN 'Кредиты МСБ'
                  ELSE 'Кредиты ФЛ'
                  END = 'Кредиты ФЛ' then
               CASE
                 WHEN ctr.close_fact_date - spec.delinq_date_fifo >= 90 THEN
                   NVL(ptb.amount_eqv,0) + NVL(tb.overdue_principal_eqv,0)
                 ELSE
                   0
               END
           ELSE
             CASE
               WHEN NVL(tb.max_fifo_for_client,0) > 90 THEN
                 NVL(ptb.amount_eqv,0) + NVL(tb.overdue_principal_eqv,0)
               ELSE
                 0
             END
           END AS DEFAULTED_DEBT
           */
              ,CASE
             WHEN CASE
                    WHEN ctr.contract_sid = 183457045231 THEN 'Кредиты ЮЛ'
                    WHEN ctr.source_system_id IN (2,4) OR
                         (INSTR(prt.code,'ФЛ')> 0 and INSTR(prt.code,'M')=0 and INSTR(prt.code,'М'/*русская М */)=0) THEN 'Кредиты ФЛ'
                    WHEN INSTR(ct.contract_type_name,'МСБ') > 0 THEN 'Кредиты МСБ'
                    WHEN INSTR(ct.contract_type_name,'Корп') > 0 THEN 'Кредиты ЮЛ'
                    WHEN INSTR(prt.code,'M6') > 0 OR INSTR(prt.code,'М6'/*русская М */) > 0  THEN
                      CASE WHEN c.open_date < to_date('08.02.2012','DD.MM.YYYY') THEN 'Кредиты МСБ' ELSE 'Кредиты ЮЛ' END
                    WHEN INSTR(prt.code,'K') > 0 OR INSTR(prt.code,'К'/*русская К */) > 0 THEN 'Кредиты ЮЛ'
                    WHEN INSTR(prt.code,'M') > 0 OR INSTR(prt.code,'М'/*русская М */) > 0 THEN 'Кредиты МСБ'
             ELSE CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' THEN 'Кредиты ФЛ'
                  ELSE CASE WHEN INSTR(prt.code,'M')= 1 OR INSTR(prt.code,'М'/*русская М */) = 1 OR
                                 INSTR(COALESCE(tb.creditline_no,c.contract_no),'M')= 1 OR INSTR(COALESCE(tb.creditline_no,c.contract_no),'М'/*русская М */) = 1 OR c.contract_no like '%М%' 
                         THEN 'Кредиты МСБ' ELSE 'Кредиты ЮЛ'
                       END
                  END
             END = 'Кредиты ФЛ' then
               CASE
                 WHEN ctr.close_fact_date - spec.delinq_date_fifo >= 90 THEN
                   NVL(ptb.amount_eqv,0) + NVL(tb.overdue_principal_eqv,0)
                 ELSE
                   0
               END
           ELSE
             CASE
               WHEN NVL(tb.max_fifo_for_client,0) > 90 THEN
                 NVL(ptb.amount_eqv,0) + NVL(tb.overdue_principal_eqv,0)
               ELSE
                 0
             END
           END AS DEFAULTED_DEBT

          ,NVL(tb.unused_credit_limit,0) AS unused_credit_limit
          ,NVL(tb.unused_credit_limit_eqv,0) AS unused_credit_limit_eqv
         ,(NVL(ptb.amount_eqv,0) + NVL(tb.overdue_principal_eqv,0)) *
            CASE WHEN NVL(prt.rez_percent,0) > 0 THEN NVL(prt.rez_percent,0)/100
            ELSE NVL(spec.rez_percent,0)/100 END AS principal_res
         ,NVL(tb.unused_credit_limit_eqv,0) *
            CASE WHEN NVL(prt.rez_percent,0) > 0 THEN NVL(prt.rez_percent,0)/100
            ELSE NVL(spec.rez_percent,0)/100 END AS unused_credit_limit_res
         ,(NVL(ptb.interest_eqv,0) + NVL(tb.overdue_interest_eqv,0)) *
            CASE WHEN NVL(prt.rez_percent,0) > 0 THEN NVL(prt.rez_percent,0)/100
            ELSE NVL(spec.rez_percent,0)/100 END AS interest_res
         ,NVL(ptb.fee_eqv,0) *
            CASE WHEN NVL(prt.rez_percent,0) > 0 THEN NVL(prt.rez_percent,0)/100
            ELSE NVL(spec.rez_percent,0)/100 END AS fee_res
          ,NVL(ptb.interest,0) AS interest
          ,NVL(ptb.interest_eqv,0) AS interest_eqv
          ,NVL(tb.overdue_interest,0) AS overdue_interest
          ,NVL(tb.overdue_interest_eqv,0) AS overdue_interest_eqv
          ,NVL(tb.prc_main_vnb_amount,0) AS prc_main_vnb_amount
          ,NVL(tb.prc_debt_vnb_amount,0) AS prc_debt_vnb_amount
          ,CASE
             WHEN NVL(tb.account_sum_91802,0) +
                  NVL(tb.account_sum_91803,0) +
                  NVL(tb.account_sum_91704,0) +
                  NVL(tb.account_sum_91604,0) = 0
               THEN NULL
             ELSE
               tb.off_date_vnb
           END AS off_date_vnb
          ,v.off_main_debt_vnb
          ,v.off_prc_vnb
          ,v.off_other_pays_vnb
          ,NVL(tb.account_sum_91802,0) AS account_sum_91802
          ,NVL(tb.account_sum_91704,0) AS account_sum_91704
          ,NVL(tb.account_sum_91604,0) AS account_sum_91604
          ,NVL(tb.account_sum_91803,0) AS account_sum_91803
          ,spec.delinq_date_fifo
          ,NVL(ctr.close_fact_date - spec.delinq_date_fifo + 1, 0) AS cnt_delinq_date_fifo
          ,LEAST(NVL(spec.delinq_date_lifo,spec.delinquency_interest_date),NVL(spec.delinquency_interest_date,spec.delinq_date_lifo)) AS delinq_date_lifo
          ,NVL(ctr.close_fact_date - LEAST(NVL(spec.delinq_date_lifo,spec.delinquency_interest_date),NVL(spec.delinquency_interest_date,spec.delinq_date_lifo)) + 1,0) AS cnt_delinq_date_lifo
          ,NVL(tb.max_fifo_for_client,0) AS max_fifo_for_client          
          ,prt.code AS code_pos   --2017-10 ( см также code_pos2)                
          ,NVL(spec.rez_percent,0) AS rez_percent
          ,NVL(prt.rez_percent,0) AS calc_prc_reserve
          ,COALESCE(c.loan_quality_cod,spec.loan_quality_cod_spec) AS loan_quality_cod
          ,COALESCE(CASE spec.fin_state
                      WHEN 1 THEN 'Хорошее'
                      WHEN 2 THEN 'Среднее'
                      WHEN 3 THEN 'Плохое'
                    ELSE NULL
                    END
                    ,cl.fin_state) AS fin_state
          ,spec.loan_state as loan_state
          ,COALESCE(CASE spec_first_fin.ctr_val
                      WHEN 1 THEN 'Хорошее'
                      WHEN 2 THEN 'Среднее'
                      WHEN 3 THEN 'Плохое'
                    ELSE NULL
                    END
                    ,cl_first_fin.ctr_val) AS first_fin_state
          ,NVL(con_first.ctr_val,spec_first_lq.ctr_val) as first_loan_quality_cod
          ,spec_first_loan.ctr_val as first_loan_state
          ,NVL(ptb.cnt_overdue_client,0) AS cnt_overdue_client
          ,NVL(ptb.max_cnt_day_overdue_client,0) AS max_cnt_day_overdue_client
          ,NVL(ptb.max_sum_overdue_client,0) AS max_sum_overdue_client
          ,NVL(tb.account_sum_91311,0) +
           NVL(tb.account_sum_91312,0) +
           NVL(tb.account_sum_91313,0) +
           NVL(tb.account_sum_91314,0) AS account_sum_collateral
          ,NVL(tb.account_sum_91311,0) AS account_sum_91311
          ,tb.account_num_91311
          ,tb.account_name_91311
          ,NVL(tb.account_sum_91312,0) AS account_sum_91312
          ,tb.account_num_91312
          ,tb.account_name_91312
          ,NVL(tb.account_sum_91313,0) AS account_sum_91313
          ,tb.account_num_91313
          ,tb.account_name_91313
          ,NVL(tb.account_sum_91314,0) AS account_sum_91314
          ,tb.account_num_91314
          ,tb.account_name_91314
          ,NVL(tb.account_sum_91414,0) AS account_sum_91414
          ,tb.account_num_91414
          ,tb.account_name_91414
          ,NVL(tb.provis_percent,0) AS provis_percent
          ,NVL(tb.provis_percent_client,0) AS provis_percent_client
          ,NVL(clm.cred_dog_cft_bank,clm.cred_dog_in_3card) AS pr_source_refinans
          ,NULL                               AS parent_dog_id_refinans
          ,to_date('01.01.1900','DD.MM.YYYY') AS date_refinans
          ,NULL                               AS sum_main_refinans
          ,NULL                               AS sum_debt_refinans
          ,NULL                               AS fifo_dog_refinans
          ,NULL                               AS fifo_client_refinans
          ,NULL                               AS sum_res_refinans
          ,NULL                               AS first_id_dog_refinans
          ,to_date('01.01.1900','DD.MM.YYYY') AS date_turn_refinans_first
          ,NULL                               AS sum_turn_refinans_first
          ,NULL                               AS last_id_dog_refinans
          ,NULL                               AS sum_turn_refinans_last
          ,to_date('01.01.1900','DD.MM.YYYY') AS date_turn_refinans_last
          ,NULL                               AS dolg_last_dog_refinans
          ,NULL                               AS fifo_last_dog_refinans
          ,NULL                               AS problem_debt_refinans
          ,NULL                               AS recove_res_main_refinans
          ,NULL                               AS recove_res_percent_refinans
          ,NULL                               AS recove_res_usl_refinans
          ,NULL                               AS sum_main_rur_refinans
          ,NULL                               AS sum_debt_od_refinans
          ,NULL                               AS sum_main_prc_refinans
          ,NULL                               AS sum_debt_prc_refinans
          ,NULL                               AS refin_komiss
          ,NULL                               AS refin_debt_komiss
          ,NULL                               AS refin_peny
          ,NULL                               AS refin_debt_vnb
          ,NULL                               AS refin_prc_vnb
          ,NULL                               AS refin_other_vnb
          ,to_date('01.01.1900','DD.MM.YYYY') AS date_price
          ,NULL                               AS sell_price
          ,NULL                               AS calc_prc_reserve_on_sale
          ,NULL                               AS sum_main_sold_debt
          ,NULL                               AS sum_prc_sold_balance
          ,NULL                               AS sum_other_receiv_sold
          ,NULL                               AS x_skb_client_status
          ,NULL                               AS in_work_units
          ,NULL                               AS stage_name
          ,NULL                               AS skb_stage_asgn_flg
          ,NULL                               AS stage_reason
          ,NULL                               AS day_stage
          ,NULL                               AS prev_stage_date
          ,NULL                               AS emp_name
          ,NULL                               AS skb_emp_date
          ,NULL                               AS ka_name
          ,NULL                               AS reg_number
          ,NULL                               AS ka_send_date
          ,NULL                               AS ka_plan_end_date
          ,NULL                               AS ka_count
          ,NULL                               AS reg_count
          ,NULL                               AS ka_deadline
          ,NULL                               AS reason
          ,NULL                               AS collection
          ,NULL                               AS x_skb_hand_last_call
          ,NULL                               AS pr_bankrot
          ,NULL                               AS amount_debt_pay_eqv
          ,NULL                               AS amount_debt_pay_eqv_refin
          ,NULL                               AS principal_res_restore
          ,NULL                               AS interest_res_restore
          ,NULL                               AS interest_res_restore_usl
          ,NULL                               AS payment_un_debt_osn_dolg_prev
          ,NULL                               AS payment_debt_osn_dolg_prev
          ,NULL                               AS payment_un_debt_prcnt_prev
          ,NULL                               AS payment_debt_prcnt_prev
          ,NULL                               AS payment_un_debt_comm_prev
          ,NULL                               AS payment_debt_comm_prev
          ,NULL                               AS payment_penalty_prev
          ,NULL                               AS payment_debt_odvnb_prev
          ,NULL                               AS payment_debt_prcvnb_prev
          ,NULL                               AS payment_debt_othvnb_prev
          ,NULL                               AS pay_gp
          ,NULL                               AS recovery_costs_client
          ,NULL                               AS recovery_court
          ,ctr.contract_sid
          ,ctr.contract_gid
          ,ctr.client_sid
          ,sst.system_name AS dog_system_name
          ,sst.bank_name AS dog_bank_name
          ,DECODE(c.cur_id,'840','Доллар США','978','Евро','810','Российский рубль','643','Российский рубль',NULL) AS code_naim
          ,NVL(ptb.fee_eqv,0) AS fee_eqv
          ,CASE WHEN ctr.source_system_id IN (1,3) THEN knd.code ELSE prt.code END AS code_pos2 --2017-10
      FROM dm_skb.tb_cl_credits_closed ctr
           LEFT JOIN ptb
             ON ptb.as_of_date = ctr.close_fact_date
                AND ptb.obj_gid = ctr.contract_gid
                AND ptb.source_system_id = ctr.source_system_id
           LEFT JOIN v
             ON v.as_of_date = ctr.close_fact_date
                AND v.contract_gid = ctr.contract_gid
                AND v.source_system_id = ctr.source_system_id
           LEFT JOIN tb
             ON tb.close_fact_date = ctr.close_fact_date
                AND tb.obj_gid = ctr.contract_gid
                AND tb.source_system_id = ctr.source_system_id
           LEFT JOIN c
             ON c.close_fact_date = ctr.close_fact_date
                AND c.contract_gid = ctr.contract_gid
                AND c.source_system_id = ctr.source_system_id
           LEFT JOIN spec
             ON spec.close_fact_date = ctr.close_fact_date
                AND spec.contract_gid = ctr.contract_gid
                AND spec.source_system_id = ctr.source_system_id
           LEFT JOIN cl
             ON cl.close_fact_date = ctr.close_fact_date
                AND cl.client_gid = TRUNC(ctr.client_sid/10)
                AND cl.source_system_id = ctr.source_system_id
           LEFT JOIN dwh.ref_contract_type ct
             ON ct.end_date = to_date('31.12.5999','DD.MM.YYYY')
                AND ct.contract_type_sid = c.contract_type_sid
                AND ctr.close_fact_date BETWEEN ct.effective_start AND ct.effective_end
           LEFT JOIN dwh.ref_product_group pg
             ON pg.product_group_gid = TRUNC(ct.product_group_sid/10)
                AND pg.source_system_id = ct.source_system_id
                AND pg.end_date = to_date('31.12.5999','DD.MM.YYYY')
                AND ctr.close_fact_date BETWEEN pg.effective_start AND pg.effective_end
           LEFT JOIN dwh.ref_port prt
             ON prt.end_date = to_date('31.12.5999','DD.MM.YYYY')
                AND prt.port_sid = spec.port_sid
                AND ctr.close_fact_date BETWEEN prt.effective_start AND prt.effective_end
           LEFT JOIN dwh.ref_port_kind knd
             ON knd.end_date = to_date('31.12.5999','DD.MM.YYYY')
                AND knd.port_kind_gid = prt.port_kind_gid
                AND knd.source_system_id = prt.source_system_id
                AND ctr.close_fact_date BETWEEN knd.effective_start AND knd.effective_end
           LEFT JOIN dm_skb.dm_claims clm
             ON clm.claim_id = tb.claim_gid
                AND clm.source_system_id = tb.source_system_id
           LEFT JOIN dwh.fct_cur_rate fcr
             ON fcr.cur_rate_date = ctr.close_fact_date
                AND fcr.cur_id = c.cur_id
           LEFT JOIN dm_clant.tb_ref_contract_2_product c2p
             ON c2p.contract_sid = ctr.contract_sid
           LEFT JOIN dm_skb.mv_rep_product_dim prod
             ON prod.id_lv0 = 4919561 -- Иерархия статей управленческого учета
                AND prod.id_lv4 = c2p.p_id
                AND ctr.close_fact_date BETWEEN prod.start_date_lv1 AND prod.end_date_lv1
                AND ctr.close_fact_date BETWEEN prod.start_date_lv2 AND prod.end_date_lv2
                AND ctr.close_fact_date BETWEEN prod.start_date_lv3 AND prod.end_date_lv3
                AND ctr.close_fact_date BETWEEN prod.start_date_lv4 AND prod.end_date_lv4
           LEFT JOIN (SELECT so.loan_source_gid, so.source_system_id, so.loan_source_name, so.effective_start, so.effective_end
                        FROM dwh.ref_loan_source so
                        WHERE so.end_date = to_date('31.12.5999', 'dd.mm.yyyy')) so
             ON so.loan_source_gid = TRUNC(spec.loan_source_sid/10)
                AND so.source_system_id = spec.source_system_id
                AND ctr.close_fact_date BETWEEN so.effective_start AND so.effective_end
            LEFT JOIN (SELECT ob.loan_object_gid, ob.source_system_id, ob.loan_object_name, ob.effective_start, ob.effective_end
                         FROM dwh.ref_loan_object ob
                        WHERE ob.end_date = to_date('31.12.5999', 'dd.mm.yyyy')) ob
              ON ob.loan_object_gid = TRUNC(spec.loan_object_sid/10)
                 AND ob.source_system_id = spec.source_system_id
                 AND ctr.close_fact_date BETWEEN ob.effective_start AND ob.effective_end
            LEFT JOIN dwh.ref_credit_transh tr
              ON tr.transh_gid = ctr.contract_gid
                 AND tr.source_system_id = ctr.source_system_id
                 AND tr.end_date = to_date('31.12.5999','DD.MM.YYYY')
                 AND ctr.close_fact_date BETWEEN tr.effective_start AND tr.effective_end
            LEFT JOIN cr_line
              ON cr_line.contract_sid = ctr.contract_sid
                 AND ctr.close_fact_date BETWEEN cr_line.effective_start AND cr_line.effective_end
            LEFT JOIN emp
              ON emp.employee_gid = TRUNC(c.created_by_employee_sid/10)
                 AND emp.source_system_id = c.source_system_id
                 AND ctr.close_fact_date BETWEEN emp.effective_start AND emp.effective_end
            LEFT JOIN spec_first_fin
              ON spec_first_fin.contract_gid = ctr.contract_gid
                 AND spec_first_fin.source_system_id = ctr.source_system_id
                 AND tb.date_first_turn BETWEEN spec_first_fin.effective_start AND spec_first_fin.effective_end
            LEFT JOIN spec_first_loan
                ON spec_first_loan.contract_gid = ctr.contract_gid
                 AND spec_first_loan.source_system_id = ctr.source_system_id
                 AND tb.date_first_turn BETWEEN spec_first_loan.effective_start AND spec_first_loan.effective_end
            LEFT JOIN spec_first_lq
              ON spec_first_lq.contract_gid = ctr.contract_gid
                 AND spec_first_lq.source_system_id = ctr.source_system_id
                 AND tb.date_first_turn BETWEEN spec_first_lq.effective_start AND spec_first_lq.effective_end
            LEFT JOIN cl_first_fin
              ON cl_first_fin.client_gid = TRUNC(ctr.client_sid/10)
                 AND cl_first_fin.source_system_id = ctr.source_system_id
                 AND tb.date_first_turn BETWEEN cl_first_fin.effective_start AND spec_first_fin.effective_end
            LEFT JOIN con_first
              ON con_first.contract_gid = ctr.contract_gid
                 AND con_first.source_system_id = ctr.source_system_id
                 AND tb.date_first_turn BETWEEN con_first.effective_start AND con_first.effective_end
            LEFT JOIN type_restr_date
              ON type_restr_date.contract_sid = ctr.contract_sid
                 AND ctr.close_fact_date BETWEEN type_restr_date.effective_start AND type_restr_date.effective_end
            LEFT JOIN dm_skb.mv_rep_system_dim sst
              ON sst.system_id = ctr.source_system_id
             --2017-10
            LEFT JOIN dwh.ref_okopfs okpf
              ON okpf.end_date = to_date('31.12.5999','DD.MM.YYYY')
                 AND okpf.code = cl.okopf
                 AND okpf.source_system_id = cl.source_system_id
                 AND ctr.close_fact_date BETWEEN okpf.effective_start AND okpf.effective_end
                 and ((ctr.close_fact_date BETWEEN dfrom and dto) or (DTO is null) ) --add 14/02/2018
    /*       LEFT JOIN new_date_info on new_date_info.contract_gid= TRUNC(ctr.contract_sid/10)
                          AND new_date_info.source_system_id=ctr.source_system_id
                          AND new_date_info.end_date = to_date('31.12.5999','DD.MM.YYYY')
                          AND ctr.close_fact_date BETWEEN new_date_info.effective_start AND new_date_info.effective_end                     */

 WHERE ctr.close_fact_date = inBegDate + idx
   AND ct.contract_type_name <> 'Потребительский кредит_МФО'
  ) src ON (dest.contract_sid = src.contract_sid AND dest.as_of_date = src.as_of_date)
  WHEN MATCHED THEN
    UPDATE SET
     dest.source_system_id              = src.source_system_id
    ,dest.client_gid                    = src.client_gid
    ,dest.uc_id                         = src.uc_id
    ,dest.client_type_flg               = src.client_type_flg
    ,dest.type_of_business              = src.type_of_business
    ,dest.full_name                     = src.full_name
    ,dest.short_name                    = src.short_name
    ,dest.tin                           = src.tin
    ,dest.ogrn                          = src.ogrn
    ,dest.okved                         = src.okved
    ,dest.business                      = src.business
    ,dest.okopf                         = src.okopf
    ,dest.okato                         = src.okato
    ,dest.reg_region                    = src.reg_region
    ,dest.sum_contr_for_client          = src.sum_contr_for_client
    ,dest.cnt_contr_for_client          = src.cnt_contr_for_client
    ,dest.pr_defolt_client              = src.pr_defolt_client
    ,dest.pr_problem_client             = src.pr_problem_client
    ,dest.claim_id                      = src.claim_id
    ,dest.target                        = src.target
    ,dest.claim_user_fio                = src.claim_user_fio
    ,dest.fio_bbr                       = src.fio_bbr
    ,dest.fio_deb                       = src.fio_deb
    ,dest.fio_drb                       = src.fio_drb
    ,dest.fio_decision_claim            = src.fio_decision_claim
    ,dest.id_contr                      = src.id_contr
    ,dest.transh_gid                    = src.transh_gid
    ,dest.contract_no                   = src.contract_no
    ,dest.transh_no                     = src.transh_no
    ,dest.pr_transh                     = src.pr_transh
    ,dest.source_id_dog                 = src.source_id_dog
    ,dest.code                          = src.code
    ,dest.principal                     = src.principal
    ,dest.principal_rur                 = src.principal_rur
    ,dest.calc_sum_credit               = src.calc_sum_credit
    ,dest.sum_first_turn                = src.sum_first_turn
    ,dest.date_first_turn               = src.date_first_turn
    ,dest.life_term_contr               = src.life_term_contr
    ,dest.valid_contr                   = src.valid_contr
    --,dest.hier_product_name             = src.hier_product_name
    ,dest.hier_product_name_f           = src.hier_product_name_f
    ,dest.business_name_f               = src.business_name_f
    ,dest.product_group_name_f          = src.product_group_name_f
    ,dest.product_name_f                = src.product_name_f
    ,dest.p_id                          = src.p_id
    ,dest.group_contract_type           = src.group_contract_type
    ,dest.contract_type                 = src.contract_type
    ,dest.loan_type                     = src.loan_type
    ,dest.loan_source_name              = src.loan_source_name
    ,dest.loan_object_name              = src.loan_object_name
    ,dest.open_date                     = src.open_date
    ,dest.open_date_transh              = src.open_date_transh
    ,dest.close_date                    = src.close_date
    ,dest.close_fact_date               = src.close_fact_date
    ,dest.main_payment                  = src.main_payment
    ,dest.prc_payment                   = src.prc_payment
    ,dest.type_payment                  = src.type_payment
    ,dest.interest_rate_open_date       = src.interest_rate_open_date
    ,dest.interest_rate                 = src.interest_rate
    ,dest.rate_first_day                = src.rate_first_day
    ,dest.sum_komiss_month              = src.sum_komiss_month
    ,dest.effective_rate                = src.effective_rate
    ,dest.pr_restruct                   = src.pr_restruct
    ,dest.restruct_code                 = src.restruct_code
    ,dest.date_restruct                 = src.date_restruct
    ,dest.type_restruct                 = src.type_restruct
    ,dest.status                        = src.status
    ,dest.state                         = src.state
    ,dest.created_by_employee_dog       = src.created_by_employee_dog
    ,dest.department_code_dog_open      = src.department_code_dog_open
    ,dest.department_name_dog_open      = src.department_name_dog_open
    ,dest.department_code_dog_issue     = src.department_code_dog_issue
    ,dest.department_name_dog_issue     = src.department_name_dog_issue
    ,dest.branch_code_dog_open          = src.branch_code_dog_open
    ,dest.branch_name_dog_open          = src.branch_name_dog_open
    ,dest.branch_code_dog_issue         = src.branch_code_dog_issue
    ,dest.branch_name_dog_issue         = src.branch_name_dog_issue
    ,dest.serv_dog_city                 = src.serv_dog_city
    ,dest.serv_dog_region               = src.serv_dog_region
    ,dest.adv_account                   = src.adv_account
    ,dest.adv_account_transh            = src.adv_account_transh
    ,dest.amount                        = src.amount
    ,dest.amount_eqv                    = src.amount_eqv
    ,dest.overdue_principal             = src.overdue_principal
    ,dest.overdue_principal_eqv         = src.overdue_principal_eqv
    ,dest.sum_dolg                      = src.sum_dolg
    ,dest.sum_dolg_rur                  = src.sum_dolg_rur
    ,dest.problem_debt                  = src.problem_debt
    ,dest.problem_debt_30               = src.problem_debt_30
    ,dest.defaulted_debt                = src.defaulted_debt
    ,dest.unused_credit_limit           = src.unused_credit_limit
    ,dest.unused_credit_limit_eqv       = src.unused_credit_limit_eqv
    ,dest.principal_res                 = src.principal_res
    ,dest.unused_credit_limit_res       = src.unused_credit_limit_res
    ,dest.interest_res                  = src.interest_res
    ,dest.fee_res                       = src.fee_res
    ,dest.interest                      = src.interest
    ,dest.interest_eqv                  = src.interest_eqv
    ,dest.overdue_interest              = src.overdue_interest
    ,dest.overdue_interest_eqv          = src.overdue_interest_eqv
    ,dest.prc_main_vnb_amount           = src.prc_main_vnb_amount
    ,dest.prc_debt_vnb_amount           = src.prc_debt_vnb_amount
    ,dest.off_date_vnb                  = src.off_date_vnb
    ,dest.off_main_debt_vnb             = src.off_main_debt_vnb
    ,dest.off_prc_vnb                   = src.off_prc_vnb
    ,dest.off_other_pays_vnb            = src.off_other_pays_vnb
    ,dest.account_sum_91802             = src.account_sum_91802
    ,dest.account_sum_91704             = src.account_sum_91704
    ,dest.account_sum_91604             = src.account_sum_91604
    ,dest.account_sum_91803             = src.account_sum_91803
    ,dest.delinq_date_fifo              = src.delinq_date_fifo
    ,dest.cnt_delinq_date_fifo          = src.cnt_delinq_date_fifo
    ,dest.delinq_date_lifo              = src.delinq_date_lifo
    ,dest.cnt_delinq_date_lifo          = src.cnt_delinq_date_lifo
    ,dest.max_fifo_for_client           = src.max_fifo_for_client
    ,dest.code_pos                      = src.code_pos
    ,dest.rez_percent                   = src.rez_percent
    ,dest.calc_prc_reserve              = src.calc_prc_reserve
    ,dest.loan_quality_cod              = src.loan_quality_cod
    ,dest.fin_state                     = src.fin_state
    ,dest.loan_state                    = src.loan_state
    ,dest.first_fin_state               = src.first_fin_state
    ,dest.first_loan_quality_cod        = src.first_loan_quality_cod
    ,dest.first_loan_state              = src.first_loan_state
    ,dest.cnt_overdue_client            = src.cnt_overdue_client
    ,dest.max_cnt_day_overdue_client    = src.max_cnt_day_overdue_client
    ,dest.max_sum_overdue_client        = src.max_sum_overdue_client
    ,dest.account_sum_collateral        = src.account_sum_collateral
    ,dest.account_sum_91311             = src.account_sum_91311
    ,dest.account_num_91311             = src.account_num_91311
    ,dest.account_name_91311            = src.account_name_91311
    ,dest.account_sum_91312             = src.account_sum_91312
    ,dest.account_num_91312             = src.account_num_91312
    ,dest.account_name_91312            = src.account_name_91312
    ,dest.account_sum_91313             = src.account_sum_91313
    ,dest.account_num_91313             = src.account_num_91313
    ,dest.account_name_91313            = src.account_name_91313
    ,dest.account_sum_91314             = src.account_sum_91314
    ,dest.account_num_91314             = src.account_num_91314
    ,dest.account_name_91314            = src.account_name_91314
    ,dest.account_sum_91414             = src.account_sum_91414
    ,dest.account_num_91414             = src.account_num_91414
    ,dest.account_name_91414            = src.account_name_91414
    ,dest.provis_percent                = src.provis_percent
    ,dest.provis_percent_client         = src.provis_percent_client
    ,dest.pr_source_refinans            = src.pr_source_refinans
    ,dest.parent_dog_id_refinans        = src.parent_dog_id_refinans
    ,dest.date_refinans                 = src.date_refinans
    ,dest.sum_main_refinans             = src.sum_main_refinans
    ,dest.sum_debt_refinans             = src.sum_debt_refinans
    ,dest.fifo_dog_refinans             = src.fifo_dog_refinans
    ,dest.fifo_client_refinans          = src.fifo_client_refinans
    ,dest.sum_res_refinans              = src.sum_res_refinans
    ,dest.first_id_dog_refinans         = src.first_id_dog_refinans
    ,dest.date_turn_refinans_first      = src.date_turn_refinans_first
    ,dest.sum_turn_refinans_first       = src.sum_turn_refinans_first
    ,dest.last_id_dog_refinans          = src.last_id_dog_refinans
    ,dest.sum_turn_refinans_last        = src.sum_turn_refinans_last
    ,dest.date_turn_refinans_last       = src.date_turn_refinans_last
    ,dest.dolg_last_dog_refinans        = src.dolg_last_dog_refinans
    ,dest.fifo_last_dog_refinans        = src.fifo_last_dog_refinans
    ,dest.problem_debt_refinans         = src.problem_debt_refinans
    ,dest.recove_res_main_refinans      = src.recove_res_main_refinans
    ,dest.recove_res_percent_refinans   = src.recove_res_percent_refinans
    ,dest.recove_res_usl_refinans       = src.recove_res_usl_refinans
    ,dest.sum_main_rur_refinans         = src.sum_main_rur_refinans
    ,dest.sum_debt_od_refinans          = src.sum_debt_od_refinans
    ,dest.sum_main_prc_refinans         = src.sum_main_prc_refinans
    ,dest.sum_debt_prc_refinans         = src.sum_debt_prc_refinans
    ,dest.refin_komiss                  = src.refin_komiss
    ,dest.refin_debt_komiss             = src.refin_debt_komiss
    ,dest.refin_peny                    = src.refin_peny
    ,dest.refin_debt_vnb                = src.refin_debt_vnb
    ,dest.refin_prc_vnb                 = src.refin_prc_vnb
    ,dest.refin_other_vnb               = src.refin_other_vnb
    ,dest.date_price                    = src.date_price
    ,dest.sell_price                    = src.sell_price
    ,dest.calc_prc_reserve_on_sale      = src.calc_prc_reserve_on_sale
    ,dest.sum_main_sold_debt            = src.sum_main_sold_debt
    ,dest.sum_prc_sold_balance          = src.sum_prc_sold_balance
    ,dest.sum_other_receiv_sold         = src.sum_other_receiv_sold
    ,dest.x_skb_client_status           = src.x_skb_client_status
    ,dest.in_work_units                 = src.in_work_units
    ,dest.stage_name                    = src.stage_name
    ,dest.skb_stage_asgn_flg            = src.skb_stage_asgn_flg
    ,dest.stage_reason                  = src.stage_reason
    ,dest.day_stage                     = src.day_stage
    ,dest.prev_stage_date               = src.prev_stage_date
    ,dest.emp_name                      = src.emp_name
    ,dest.skb_emp_date                  = src.skb_emp_date
    ,dest.ka_name                       = src.ka_name
    ,dest.reg_number                    = src.reg_number
    ,dest.ka_send_date                  = src.ka_send_date
    ,dest.ka_plan_end_date              = src.ka_plan_end_date
    ,dest.ka_count                      = src.ka_count
    ,dest.reg_count                     = src.reg_count
    ,dest.ka_deadline                   = src.ka_deadline
    ,dest.reason                        = src.reason
    ,dest.collection                    = src.collection
    ,dest.x_skb_hand_last_call          = src.x_skb_hand_last_call
    ,dest.pr_bankrot                    = src.pr_bankrot
    ,dest.amount_debt_pay_eqv           = src.amount_debt_pay_eqv
    ,dest.amount_debt_pay_eqv_refin     = src.amount_debt_pay_eqv_refin
    ,dest.principal_res_restore         = src.principal_res_restore
    ,dest.interest_res_restore          = src.interest_res_restore
    ,dest.interest_res_restore_usl      = src.interest_res_restore_usl
    ,dest.payment_un_debt_osn_dolg_prev = src.payment_un_debt_osn_dolg_prev
    ,dest.payment_debt_osn_dolg_prev    = src.payment_debt_osn_dolg_prev
    ,dest.payment_un_debt_prcnt_prev    = src.payment_un_debt_prcnt_prev
    ,dest.payment_debt_prcnt_prev       = src.payment_debt_prcnt_prev
    ,dest.payment_un_debt_comm_prev     = src.payment_un_debt_comm_prev
    ,dest.payment_debt_comm_prev        = src.payment_debt_comm_prev
    ,dest.payment_penalty_prev          = src.payment_penalty_prev
    ,dest.payment_debt_odvnb_prev       = src.payment_debt_odvnb_prev
    ,dest.payment_debt_prcvnb_prev      = src.payment_debt_prcvnb_prev
    ,dest.payment_debt_othvnb_prev      = src.payment_debt_othvnb_prev
    ,dest.pay_gp                        = src.pay_gp
    ,dest.recovery_costs_client         = src.recovery_costs_client
    ,dest.recovery_court                = src.recovery_court
    ,dest.contract_gid                  = src.contract_gid
    ,dest.client_sid                    = src.client_sid
    ,dest.dog_system_name               = src.dog_system_name
    ,dest.dog_bank_name                 = src.dog_bank_name
    ,dest.code_naim                     = src.code_naim
    ,dest.fee_eqv                       = src.fee_eqv
    ,dest.code_pos2                     = src.code_pos2
    WHERE
    dwh.pkg_normalize_ref_table.isEqual(dest.source_system_id,src.source_system_id) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.client_gid,src.client_gid) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.uc_id,src.uc_id) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.client_type_flg,src.client_type_flg) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.type_of_business,src.type_of_business) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.full_name,src.full_name) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.short_name,src.short_name) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.tin,src.tin) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.ogrn,src.ogrn) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.okved,src.okved) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.business,src.business) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.okopf,src.okopf) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.okato,src.okato) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.reg_region,src.reg_region) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sum_contr_for_client,src.sum_contr_for_client) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.cnt_contr_for_client,src.cnt_contr_for_client) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.pr_defolt_client,src.pr_defolt_client) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.pr_problem_client,src.pr_problem_client) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.claim_id,src.claim_id) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.target,src.target) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.claim_user_fio,src.claim_user_fio) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.fio_bbr,src.fio_bbr) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.fio_deb,src.fio_deb) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.fio_drb,src.fio_drb) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.fio_decision_claim,src.fio_decision_claim) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.id_contr,src.id_contr) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.transh_gid,src.transh_gid) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.contract_no,src.contract_no) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.transh_no,src.transh_no) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.pr_transh,src.pr_transh) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.source_id_dog,src.source_id_dog) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.code,src.code) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.principal,src.principal) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.principal_rur,src.principal_rur) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.calc_sum_credit,src.calc_sum_credit) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sum_first_turn,src.sum_first_turn) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.date_first_turn,src.date_first_turn) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.life_term_contr,src.life_term_contr) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.valid_contr,src.valid_contr) = 0 OR
    --dwh.pkg_normalize_ref_table.isEqual(dest.hier_product_name,src.hier_product_name) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.hier_product_name_f,src.hier_product_name_f) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.business_name_f,src.business_name_f) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.product_group_name_f,src.product_group_name_f) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.product_name_f,src.product_name_f) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.p_id,src.p_id) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.group_contract_type,src.group_contract_type) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.contract_type,src.contract_type) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.loan_type,src.loan_type) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.loan_source_name,src.loan_source_name) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.loan_object_name,src.loan_object_name) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.open_date,src.open_date) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.open_date_transh,src.open_date_transh) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.close_date,src.close_date) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.close_fact_date,src.close_fact_date) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.main_payment,src.main_payment) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.prc_payment,src.prc_payment) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.type_payment,src.type_payment) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.interest_rate_open_date,src.interest_rate_open_date) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.interest_rate,src.interest_rate) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.rate_first_day,src.rate_first_day) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sum_komiss_month,src.sum_komiss_month) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.effective_rate,src.effective_rate) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.pr_restruct,src.pr_restruct) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.restruct_code,src.restruct_code) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.date_restruct,src.date_restruct) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.type_restruct,src.type_restruct) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.status,src.status) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.state,src.state) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.created_by_employee_dog,src.created_by_employee_dog) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.department_code_dog_open,src.department_code_dog_open) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.department_name_dog_open,src.department_name_dog_open) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.department_code_dog_issue,src.department_code_dog_issue) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.department_name_dog_issue,src.department_name_dog_issue) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.branch_code_dog_open,src.branch_code_dog_open) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.branch_name_dog_open,src.branch_name_dog_open) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.branch_code_dog_issue,src.branch_code_dog_issue) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.branch_name_dog_issue,src.branch_name_dog_issue) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.serv_dog_city,src.serv_dog_city) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.serv_dog_region,src.serv_dog_region) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.adv_account,src.adv_account) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.adv_account_transh,src.adv_account_transh) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.amount,src.amount) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.amount_eqv,src.amount_eqv) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.overdue_principal,src.overdue_principal) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.overdue_principal_eqv,src.overdue_principal_eqv) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sum_dolg,src.sum_dolg) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sum_dolg_rur,src.sum_dolg_rur) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.problem_debt,src.problem_debt) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.problem_debt_30,src.problem_debt_30) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.defaulted_debt,src.defaulted_debt) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.unused_credit_limit,src.unused_credit_limit) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.unused_credit_limit_eqv,src.unused_credit_limit_eqv) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.principal_res,src.principal_res) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.unused_credit_limit_res,src.unused_credit_limit_res) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.interest_res,src.interest_res) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.fee_res,src.fee_res) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.interest,src.interest) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.interest_eqv,src.interest_eqv) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.overdue_interest,src.overdue_interest) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.overdue_interest_eqv,src.overdue_interest_eqv) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.prc_main_vnb_amount,src.prc_main_vnb_amount) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.prc_debt_vnb_amount,src.prc_debt_vnb_amount) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.off_date_vnb,src.off_date_vnb) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.off_main_debt_vnb,src.off_main_debt_vnb) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.off_prc_vnb,src.off_prc_vnb) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.off_other_pays_vnb,src.off_other_pays_vnb) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_sum_91802,src.account_sum_91802) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_sum_91704,src.account_sum_91704) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_sum_91604,src.account_sum_91604) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_sum_91803,src.account_sum_91803) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.delinq_date_fifo,src.delinq_date_fifo) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.cnt_delinq_date_fifo,src.cnt_delinq_date_fifo) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.delinq_date_lifo,src.delinq_date_lifo) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.cnt_delinq_date_lifo,src.cnt_delinq_date_lifo) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.max_fifo_for_client,src.max_fifo_for_client) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.code_pos,src.code_pos) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.code_pos2,src.code_pos2) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.rez_percent,src.rez_percent) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.calc_prc_reserve,src.calc_prc_reserve) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.loan_quality_cod,src.loan_quality_cod) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.fin_state,src.fin_state) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.loan_state,src.loan_state) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.first_fin_state,src.first_fin_state) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.first_loan_quality_cod,src.first_loan_quality_cod) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.first_loan_state,src.first_loan_state) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.cnt_overdue_client,src.cnt_overdue_client) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.max_cnt_day_overdue_client,src.max_cnt_day_overdue_client) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.max_sum_overdue_client,src.max_sum_overdue_client) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_sum_collateral,src.account_sum_collateral) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_sum_91311,src.account_sum_91311) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_num_91311,src.account_num_91311) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_name_91311,src.account_name_91311) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_sum_91312,src.account_sum_91312) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_num_91312,src.account_num_91312) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_name_91312,src.account_name_91312) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_sum_91313,src.account_sum_91313) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_num_91313,src.account_num_91313) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_name_91313,src.account_name_91313) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_sum_91314,src.account_sum_91314) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_num_91314,src.account_num_91314) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_name_91314,src.account_name_91314) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_sum_91414,src.account_sum_91414) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_num_91414,src.account_num_91414) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.account_name_91414,src.account_name_91414) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.provis_percent,src.provis_percent) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.provis_percent_client,src.provis_percent_client) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.pr_source_refinans,src.pr_source_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.parent_dog_id_refinans,src.parent_dog_id_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.date_refinans,src.date_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sum_main_refinans,src.sum_main_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sum_debt_refinans,src.sum_debt_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.fifo_dog_refinans,src.fifo_dog_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.fifo_client_refinans,src.fifo_client_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sum_res_refinans,src.sum_res_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.first_id_dog_refinans,src.first_id_dog_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.date_turn_refinans_first,src.date_turn_refinans_first) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sum_turn_refinans_first,src.sum_turn_refinans_first) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.last_id_dog_refinans,src.last_id_dog_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sum_turn_refinans_last,src.sum_turn_refinans_last) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.date_turn_refinans_last,src.date_turn_refinans_last) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.dolg_last_dog_refinans,src.dolg_last_dog_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.fifo_last_dog_refinans,src.fifo_last_dog_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.problem_debt_refinans,src.problem_debt_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.recove_res_main_refinans,src.recove_res_main_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.recove_res_percent_refinans,src.recove_res_percent_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.recove_res_usl_refinans,src.recove_res_usl_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sum_main_rur_refinans,src.sum_main_rur_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sum_debt_od_refinans,src.sum_debt_od_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sum_main_prc_refinans,src.sum_main_prc_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sum_debt_prc_refinans,src.sum_debt_prc_refinans) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.refin_komiss,src.refin_komiss) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.refin_debt_komiss,src.refin_debt_komiss) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.refin_peny,src.refin_peny) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.refin_debt_vnb,src.refin_debt_vnb) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.refin_prc_vnb,src.refin_prc_vnb) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.refin_other_vnb,src.refin_other_vnb) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.date_price,src.date_price) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sell_price,src.sell_price) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.calc_prc_reserve_on_sale,src.calc_prc_reserve_on_sale) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sum_main_sold_debt,src.sum_main_sold_debt) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sum_prc_sold_balance,src.sum_prc_sold_balance) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.sum_other_receiv_sold,src.sum_other_receiv_sold) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.x_skb_client_status,src.x_skb_client_status) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.in_work_units,src.in_work_units) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.stage_name,src.stage_name) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.skb_stage_asgn_flg,src.skb_stage_asgn_flg) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.stage_reason,src.stage_reason) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.day_stage,src.day_stage) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.prev_stage_date,src.prev_stage_date) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.emp_name,src.emp_name) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.skb_emp_date,src.skb_emp_date) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.ka_name,src.ka_name) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.reg_number,src.reg_number) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.ka_send_date,src.ka_send_date) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.ka_plan_end_date,src.ka_plan_end_date) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.ka_count,src.ka_count) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.reg_count,src.reg_count) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.ka_deadline,src.ka_deadline) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.reason,src.reason) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.collection,src.collection) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.x_skb_hand_last_call,src.x_skb_hand_last_call) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.pr_bankrot,src.pr_bankrot) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.amount_debt_pay_eqv,src.amount_debt_pay_eqv) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.amount_debt_pay_eqv_refin,src.amount_debt_pay_eqv_refin) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.principal_res_restore,src.principal_res_restore) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.interest_res_restore,src.interest_res_restore) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.interest_res_restore_usl,src.interest_res_restore_usl) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.payment_un_debt_osn_dolg_prev,src.payment_un_debt_osn_dolg_prev) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.payment_debt_osn_dolg_prev,src.payment_debt_osn_dolg_prev) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.payment_un_debt_prcnt_prev,src.payment_un_debt_prcnt_prev) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.payment_debt_prcnt_prev,src.payment_debt_prcnt_prev) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.payment_un_debt_comm_prev,src.payment_un_debt_comm_prev) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.payment_debt_comm_prev,src.payment_debt_comm_prev) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.payment_penalty_prev,src.payment_penalty_prev) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.payment_debt_odvnb_prev,src.payment_debt_odvnb_prev) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.payment_debt_prcvnb_prev,src.payment_debt_prcvnb_prev) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.payment_debt_othvnb_prev,src.payment_debt_othvnb_prev) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.pay_gp,src.pay_gp) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.recovery_costs_client,src.recovery_costs_client) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.recovery_court,src.recovery_court) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.contract_gid,src.contract_gid) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.client_sid,src.client_sid) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.dog_system_name,src.dog_system_name) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.dog_bank_name,src.dog_bank_name) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.code_naim,src.code_naim) = 0 OR
    dwh.pkg_normalize_ref_table.isEqual(dest.fee_eqv,src.fee_eqv) = 0
  WHEN NOT MATCHED THEN
    INSERT (dest.as_of_date,
            dest.source_system_id,
            dest.client_gid,
            dest.uc_id,
            dest.client_type_flg,
            dest.type_of_business,
            dest.full_name,
            dest.short_name,
            dest.tin,
            dest.ogrn,
            dest.okved,
            dest.business,
            dest.okopf,
            dest.okato,
            dest.reg_region,
            dest.sum_contr_for_client,
            dest.cnt_contr_for_client,
            dest.pr_defolt_client,
            dest.pr_problem_client,
            dest.claim_id,
            dest.target,
            dest.claim_user_fio,
            dest.fio_bbr,
            dest.fio_deb,
            dest.fio_drb,
            dest.fio_decision_claim,
            dest.id_contr,
            dest.transh_gid,
            dest.contract_no,
            dest.transh_no,
            dest.pr_transh,
            dest.source_id_dog,
            dest.code,
            dest.principal,
            dest.principal_rur,
            dest.calc_sum_credit,
            dest.sum_first_turn,
            dest.date_first_turn,
            dest.life_term_contr,
            dest.valid_contr,
            --dest.hier_product_name,
            dest.hier_product_name_f,
            dest.business_name_f,
            dest.product_group_name_f,
            dest.product_name_f,
            dest.p_id,
            dest.group_contract_type,
            dest.contract_type,
            dest.loan_type,
            dest.loan_source_name,
            dest.loan_object_name,
            dest.open_date,
            dest.open_date_transh,
            dest.close_date,
            dest.close_fact_date,
            dest.main_payment,
            dest.prc_payment,
            dest.type_payment,
            dest.interest_rate_open_date,
            dest.interest_rate,
            dest.rate_first_day,
            dest.sum_komiss_month,
            dest.effective_rate,
            dest.pr_restruct,
            dest.restruct_code,
            dest.date_restruct,
            dest.type_restruct,
            dest.status,
            dest.state,
            dest.created_by_employee_dog,
            dest.department_code_dog_open,
            dest.department_name_dog_open,
            dest.department_code_dog_issue,
            dest.department_name_dog_issue,
            dest.branch_code_dog_open,
            dest.branch_name_dog_open,
            dest.branch_code_dog_issue,
            dest.branch_name_dog_issue,
            dest.serv_dog_city,
            dest.serv_dog_region,
            dest.adv_account,
            dest.adv_account_transh,
            dest.amount,
            dest.amount_eqv,
            dest.overdue_principal,
            dest.overdue_principal_eqv,
            dest.sum_dolg,
            dest.sum_dolg_rur,
            dest.problem_debt,
            dest.problem_debt_30,
            dest.defaulted_debt,
            dest.unused_credit_limit,
            dest.unused_credit_limit_eqv,
            dest.principal_res,
            dest.unused_credit_limit_res,
            dest.interest_res,
            dest.fee_res,
            dest.interest,
            dest.interest_eqv,
            dest.overdue_interest,
            dest.overdue_interest_eqv,
            dest.prc_main_vnb_amount,
            dest.prc_debt_vnb_amount,
            dest.off_date_vnb,
            dest.off_main_debt_vnb,
            dest.off_prc_vnb,
            dest.off_other_pays_vnb,
            dest.account_sum_91802,
            dest.account_sum_91704,
            dest.account_sum_91604,
            dest.account_sum_91803,
            dest.delinq_date_fifo,
            dest.cnt_delinq_date_fifo,
            dest.delinq_date_lifo,
            dest.cnt_delinq_date_lifo,
            dest.max_fifo_for_client,
            dest.code_pos,
            dest.rez_percent,
            dest.calc_prc_reserve,
            dest.loan_quality_cod,
            dest.fin_state,
            dest.loan_state,
            dest.first_fin_state,
            dest.first_loan_quality_cod,
            dest.first_loan_state,
            dest.cnt_overdue_client,
            dest.max_cnt_day_overdue_client,
            dest.max_sum_overdue_client,
            dest.account_sum_collateral,
            dest.account_sum_91311,
            dest.account_num_91311,
            dest.account_name_91311,
            dest.account_sum_91312,
            dest.account_num_91312,
            dest.account_name_91312,
            dest.account_sum_91313,
            dest.account_num_91313,
            dest.account_name_91313,
            dest.account_sum_91314,
            dest.account_num_91314,
            dest.account_name_91314,
            dest.account_sum_91414,
            dest.account_num_91414,
            dest.account_name_91414,
            dest.provis_percent,
            dest.provis_percent_client,
            dest.pr_source_refinans,
            dest.parent_dog_id_refinans,
            dest.date_refinans,
            dest.sum_main_refinans,
            dest.sum_debt_refinans,
            dest.fifo_dog_refinans,
            dest.fifo_client_refinans,
            dest.sum_res_refinans,
            dest.first_id_dog_refinans,
            dest.date_turn_refinans_first,
            dest.sum_turn_refinans_first,
            dest.last_id_dog_refinans,
            dest.sum_turn_refinans_last,
            dest.date_turn_refinans_last,
            dest.dolg_last_dog_refinans,
            dest.fifo_last_dog_refinans,
            dest.problem_debt_refinans,
            dest.recove_res_main_refinans,
            dest.recove_res_percent_refinans,
            dest.recove_res_usl_refinans,
            dest.sum_main_rur_refinans,
            dest.sum_debt_od_refinans,
            dest.sum_main_prc_refinans,
            dest.sum_debt_prc_refinans,
            dest.refin_komiss,
            dest.refin_debt_komiss,
            dest.refin_peny,
            dest.refin_debt_vnb,
            dest.refin_prc_vnb,
            dest.refin_other_vnb,
            dest.date_price,
            dest.sell_price,
            dest.calc_prc_reserve_on_sale,
            dest.sum_main_sold_debt,
            dest.sum_prc_sold_balance,
            dest.sum_other_receiv_sold,
            dest.x_skb_client_status,
            dest.in_work_units,
            dest.stage_name,
            dest.skb_stage_asgn_flg,
            dest.stage_reason,
            dest.day_stage,
            dest.prev_stage_date,
            dest.emp_name,
            dest.skb_emp_date,
            dest.ka_name,
            dest.reg_number,
            dest.ka_send_date,
            dest.ka_plan_end_date,
            dest.ka_count,
            dest.reg_count,
            dest.ka_deadline,
            dest.reason,
            dest.collection,
            dest.x_skb_hand_last_call,
            dest.pr_bankrot,
            dest.amount_debt_pay_eqv,
            dest.amount_debt_pay_eqv_refin,
            dest.principal_res_restore,
            dest.interest_res_restore,
            dest.interest_res_restore_usl,
            dest.payment_un_debt_osn_dolg_prev,
            dest.payment_debt_osn_dolg_prev,
            dest.payment_un_debt_prcnt_prev,
            dest.payment_debt_prcnt_prev,
            dest.payment_un_debt_comm_prev,
            dest.payment_debt_comm_prev,
            dest.payment_penalty_prev,
            dest.payment_debt_odvnb_prev,
            dest.payment_debt_prcvnb_prev,
            dest.payment_debt_othvnb_prev,
            dest.pay_gp,
            dest.recovery_costs_client,
            dest.recovery_court,
            dest.contract_sid,
            dest.contract_gid,
            dest.client_sid,
            dest.dog_system_name,
            dest.dog_bank_name,
            dest.code_naim,
            dest.fee_eqv,
            dest.code_pos2)
  VALUES(src.as_of_date,
         src.source_system_id,
         src.client_gid,
         src.uc_id,
         src.client_type_flg,
         src.type_of_business,
         src.full_name,
         src.short_name,
         src.tin,
         src.ogrn,
         src.okved,
         src.business,
         src.okopf,
         src.okato,
         src.reg_region,
         src.sum_contr_for_client,
         src.cnt_contr_for_client,
         src.pr_defolt_client,
         src.pr_problem_client,
         src.claim_id,
         src.target,
         src.claim_user_fio,
         src.fio_bbr,
         src.fio_deb,
         src.fio_drb,
         src.fio_decision_claim,
         src.id_contr,
         src.transh_gid,
         src.contract_no,
         src.transh_no,
         src.pr_transh,
         src.source_id_dog,
         src.code,
         src.principal,
         src.principal_rur,
         src.calc_sum_credit,
         src.sum_first_turn,
         src.date_first_turn,
         src.life_term_contr,
         src.valid_contr,
         --src.hier_product_name,
         src.hier_product_name_f,
         src.business_name_f,
         src.product_group_name_f,
         src.product_name_f,
         src.p_id,
         src.group_contract_type,
         src.contract_type,
         src.loan_type,
         src.loan_source_name,
         src.loan_object_name,
         src.open_date,
         src.open_date_transh,
         src.close_date,
         src.close_fact_date,
         src.main_payment,
         src.prc_payment,
         src.type_payment,
         src.interest_rate_open_date,
         src.interest_rate,
         src.rate_first_day,
         src.sum_komiss_month,
         src.effective_rate,
         src.pr_restruct,
         src.restruct_code,
         src.date_restruct,
         src.type_restruct,
         src.status,
         src.state,
         src.created_by_employee_dog,
         src.department_code_dog_open,
         src.department_name_dog_open,
         src.department_code_dog_issue,
         src.department_name_dog_issue,
         src.branch_code_dog_open,
         src.branch_name_dog_open,
         src.branch_code_dog_issue,
         src.branch_name_dog_issue,
         src.serv_dog_city,
         src.serv_dog_region,
         src.adv_account,
         src.adv_account_transh,
         src.amount,
         src.amount_eqv,
         src.overdue_principal,
         src.overdue_principal_eqv,
         src.sum_dolg,
         src.sum_dolg_rur,
         src.problem_debt,
         src.problem_debt_30,
         src.defaulted_debt,
         src.unused_credit_limit,
         src.unused_credit_limit_eqv,
         src.principal_res,
         src.unused_credit_limit_res,
         src.interest_res,
         src.fee_res,
         src.interest,
         src.interest_eqv,
         src.overdue_interest,
         src.overdue_interest_eqv,
         src.prc_main_vnb_amount,
         src.prc_debt_vnb_amount,
         src.off_date_vnb,
         src.off_main_debt_vnb,
         src.off_prc_vnb,
         src.off_other_pays_vnb,
         src.account_sum_91802,
         src.account_sum_91704,
         src.account_sum_91604,
         src.account_sum_91803,
         src.delinq_date_fifo,
         src.cnt_delinq_date_fifo,
         src.delinq_date_lifo,
         src.cnt_delinq_date_lifo,
         src.max_fifo_for_client,
         src.code_pos,
         src.rez_percent,
         src.calc_prc_reserve,
         src.loan_quality_cod,
         src.fin_state,
         src.loan_state,
         src.first_fin_state,
         src.first_loan_quality_cod,
         src.first_loan_state,
         src.cnt_overdue_client,
         src.max_cnt_day_overdue_client,
         src.max_sum_overdue_client,
         src.account_sum_collateral,
         src.account_sum_91311,
         src.account_num_91311,
         src.account_name_91311,
         src.account_sum_91312,
         src.account_num_91312,
         src.account_name_91312,
         src.account_sum_91313,
         src.account_num_91313,
         src.account_name_91313,
         src.account_sum_91314,
         src.account_num_91314,
         src.account_name_91314,
         src.account_sum_91414,
         src.account_num_91414,
         src.account_name_91414,
         src.provis_percent,
         src.provis_percent_client,
         src.pr_source_refinans,
         src.parent_dog_id_refinans,
         src.date_refinans,
         src.sum_main_refinans,
         src.sum_debt_refinans,
         src.fifo_dog_refinans,
         src.fifo_client_refinans,
         src.sum_res_refinans,
         src.first_id_dog_refinans,
         src.date_turn_refinans_first,
         src.sum_turn_refinans_first,
         src.last_id_dog_refinans,
         src.sum_turn_refinans_last,
         src.date_turn_refinans_last,
         src.dolg_last_dog_refinans,
         src.fifo_last_dog_refinans,
         src.problem_debt_refinans,
         src.recove_res_main_refinans,
         src.recove_res_percent_refinans,
         src.recove_res_usl_refinans,
         src.sum_main_rur_refinans,
         src.sum_debt_od_refinans,
         src.sum_main_prc_refinans,
         src.sum_debt_prc_refinans,
         src.refin_komiss,
         src.refin_debt_komiss,
         src.refin_peny,
         src.refin_debt_vnb,
         src.refin_prc_vnb,
         src.refin_other_vnb,
         src.date_price,
         src.sell_price,
         src.calc_prc_reserve_on_sale,
         src.sum_main_sold_debt,
         src.sum_prc_sold_balance,
         src.sum_other_receiv_sold,
         src.x_skb_client_status,
         src.in_work_units,
         src.stage_name,
         src.skb_stage_asgn_flg,
         src.stage_reason,
         src.day_stage,
         src.prev_stage_date,
         src.emp_name,
         src.skb_emp_date,
         src.ka_name,
         src.reg_number,
         src.ka_send_date,
         src.ka_plan_end_date,
         src.ka_count,
         src.reg_count,
         src.ka_deadline,
         src.reason,
         src.collection,
         src.x_skb_hand_last_call,
         src.pr_bankrot,
         src.amount_debt_pay_eqv,
         src.amount_debt_pay_eqv_refin,
         src.principal_res_restore,
         src.interest_res_restore,
         src.interest_res_restore_usl,
         src.payment_un_debt_osn_dolg_prev,
         src.payment_debt_osn_dolg_prev,
         src.payment_un_debt_prcnt_prev,
         src.payment_debt_prcnt_prev,
         src.payment_un_debt_comm_prev,
         src.payment_debt_comm_prev,
         src.payment_penalty_prev,
         src.payment_debt_odvnb_prev,
         src.payment_debt_prcvnb_prev,
         src.payment_debt_othvnb_prev,
         src.pay_gp,
         src.recovery_costs_client,
         src.recovery_court,
         src.contract_sid,
         src.contract_gid,
         src.client_sid,
         src.dog_system_name,
         src.dog_bank_name,
         src.code_naim,
         src.fee_eqv,
         src.code_pos2);
         
    /*MERGE INTO dm_skb.tb_ciw_closed dest USING (
       WITH
         ctr_cls AS (
           SELECT --+ materialize 
             contract_gid,source_system_id
             FROM dm_skb.tb_cl_credits_closed
             WHERE close_fact_date = inBegDate + idx
         )
        ,cl_cls AS (
           SELECT DISTINCT 
                  TRUNC(client_sid/10) AS client_gid
                 ,source_system_id
             FROM dm_skb.tb_cl_credits_closed
             WHERE close_fact_date = inBegDate + idx
         ) 
        ,cr_line AS (
            SELECT --+ materialize 
                   contract_sid
                  ,MIN(effective_start) AS effective_start
                  ,MAX(effective_end) AS effective_end
              FROM dwh.ref_credit_transh
              WHERE end_date = to_date('31.12.5999','DD.MM.YYYY')
            GROUP BY contract_sid
          )
         ,tb AS (
            SELECT as_of_date
                  ,obj_gid
                  ,source_system_id
                  ,to_number(uc_id,'FM999999999999999D999999999','nls_numeric_characters='', ''') AS uc_id
                  ,to_number(NVL(overdue_principal,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS overdue_principal
                  ,to_number(NVL(overdue_principal_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS overdue_principal_eqv
                  ,to_number(NVL(overdue_interest,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS overdue_interest
                  ,to_number(NVL(overdue_interest_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS overdue_interest_eqv
                  ,to_number(NVL(account_sum_91311,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91311
                  ,account_num_91311
                  ,account_name_91311
                  ,to_number(NVL(account_sum_91312,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91312
                  ,account_num_91312
                  ,account_name_91312
                  ,to_number(NVL(account_sum_91313,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91313
                  ,account_num_91313
                  ,account_name_91313
                  ,to_number(NVL(account_sum_91314,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91314
                  ,account_num_91314
                  ,account_name_91314
                  ,to_number(NVL(account_sum_91414,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91414
                  ,account_num_91414
                  ,account_name_91414
                  ,to_number(creditline_id,'FM999999999999999D999999999','nls_numeric_characters='', ''') AS creditline_id
                  ,creditline_no
                  ,credit_state
                  ,credit_status
                  ,to_number(NVL(interest_rate_open_date,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS interest_rate_open_date
                  ,reg_region
                  ,to_number(NVL(cnt_contr_for_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS cnt_contr_for_client
                  ,to_number(NVL(commiss_monthly,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS commiss_monthly
                  ,to_number(NVL(interest_rate_acgn2,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS interest_rate_acgn2
                  ,to_number(pr_transh,'FM999999999999999D999999999','nls_numeric_characters='', ''') AS pr_transh
                  ,to_number(NVL(main_payment,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS main_payment
                  ,to_number(NVL(prc_payment,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS prc_payment
                  ,okved
                  ,business
                  ,to_number(NVL(sum_first_turn_ibso,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') +
                   to_number(NVL(sum_first_turn_3card,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS sum_first_turn
                  ,to_date(date_first_turn,'DD.MM.YYYY') AS date_first_turn
                  ,to_date(residue_vnb,'DD.MM.YYYY') AS off_date_vnb
                  ,to_number(NVL(prc_main_vnb_amount,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS prc_main_vnb_amount
                  ,to_number(NVL(prc_debt_vnb_amount,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS prc_debt_vnb_amount
                  ,to_number(NVL(unused_credit_limit_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS unused_credit_limit_eqv
                  ,to_number(NVL(unused_credit_limit,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS unused_credit_limit
                  ,to_char(to_number(pr_defolt_client,'FM999999999999999D999999999','nls_numeric_characters='', ''')) AS pr_defolt_client
                  ,to_char(to_number(pr_problem_client,'FM999999999999999D999999999','nls_numeric_characters='', ''')) AS pr_problem_client
                  ,credit_state_ul
                  ,to_number(NVL(provis_percent,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS provis_percent
                  ,to_number(NVL(provis_percent_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS provis_percent_client
                  ,to_number(NVL(overdue_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS overdue_client
                  ,to_number(claim_gid,'FM999999999999999D999999999','nls_numeric_characters='', ''') AS claim_gid
                  ,to_number(NVL(account_sum_91802,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91802
                  ,to_number(NVL(account_sum_91803,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91803
                  ,to_number(NVL(account_sum_91704,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91704
                  ,to_number(NVL(account_sum_91604,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91604
                  ,to_number(NVL(account_sum_91604_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS account_sum_91604_client
                  ,open_abs_dep_code
                  ,open_abs_dep_name
                  ,serv_department_code
                  ,serv_department_name
                  ,serv_department_city
                  ,serv_department_region
                  ,serv_dep_branch_name
                  ,serv_dep_branch_code
                  ,open_dep_branch_name
                  ,open_dep_branch_code
                  ,adv_account
                  ,type_restruct
                  ,to_number(rate_first_day,'FM999999999999999D999999999','nls_numeric_characters='', ''') AS rate_first_day
                  ,to_number(sum_contr_for_client,'FM999999999999999D999999999','nls_numeric_characters='', ''') AS sum_contr_for_client
              FROM (
                SELECT --+ INDEX(s UIX_3996585)
                       inBegDate + idx AS as_of_date
                      ,s.source_system_id
                      ,s.obj_gid
                      ,s.sign_name
                      ,CASE WHEN s.sign_name = 'RESIDUE_VNB' THEN
                        CASE WHEN s.sign_val = '1' THEN to_char(effective_start,'DD.MM.YYYY') ELSE NULL END
                       ELSE s.sign_val END AS sign_val
                  FROM ctr_cls
                       INNER JOIN dm_skb.tb_ctr_signs_new s
                         ON s.sign_name IN ('OVERDUE_PRINCIPAL','OVERDUE_PRINCIPAL_EQV','OVERDUE_INTEREST','OVERDUE_INTEREST_EQV'
                                           ,'ACCOUNT_SUM_91311','ACCOUNT_NUM_91311','ACCOUNT_NAME_91311'
                                           ,'ACCOUNT_SUM_91312','ACCOUNT_NUM_91312','ACCOUNT_NAME_91312'
                                           ,'ACCOUNT_SUM_91313','ACCOUNT_NUM_91313','ACCOUNT_NAME_91313'
                                           ,'ACCOUNT_SUM_91314','ACCOUNT_NUM_91314','ACCOUNT_NAME_91314'
                                           ,'ACCOUNT_SUM_91414','ACCOUNT_NUM_91414','ACCOUNT_NAME_91414'
                                           ,'CREDITLINE_ID','CREDITLINE_NO'
                                           ,'CREDIT_STATE','CREDIT_STATUS','INTEREST_RATE_OPEN_DATE','REG_REGION'
                                           ,'CNT_CONTR_FOR_CLIENT', 'COMMISS_MONTHLY','INTEREST_RATE_ACGN2','PR_TRANSH'
                                           ,'MAIN_PAYMENT','PRC_PAYMENT','OKVED','BUSINESS','SUM_FIRST_TURN','DATE_FIRST_TURN'
                                           ,'PRC_MAIN_VNB_AMOUNT','PRC_DEBT_VNB_AMOUNT','RESIDUE_VNB'--'OFF_DATE_VNB'
                                           ,'UNUSED_CREDIT_LIMIT_EQV','UNUSED_CREDIT_LIMIT','SUM_FIRST_TURN_IBSO','SUM_FIRST_TURN_3CARD'
                                           ,'UC_ID','PR_DEFOLT_CLIENT','PR_PROBLEM_CLIENT','CREDIT_STATE_UL'
                                           ,'PROVIS_PERCENT','PROVIS_PERCENT_CLIENT','OVERDUE_CLIENT'
                                           ,'CLAIM_GID','ACCOUNT_SUM_91802','ACCOUNT_SUM_91803','ACCOUNT_SUM_91704','ACCOUNT_SUM_91604'
                                           ,'ACCOUNT_SUM_91604_CLIENT'
                                           ,'OPEN_ABS_DEP_CODE','OPEN_ABS_DEP_NAME'
                                           ,'SERV_DEPARTMENT_CODE','SERV_DEPARTMENT_NAME'
                                           ,'SERV_DEPARTMENT_CITY','SERV_DEPARTMENT_REGION','SERV_DEP_BRANCH_NAME','SERV_DEP_BRANCH_CODE'
                                           ,'OPEN_DEP_BRANCH_CODE','OPEN_DEP_BRANCH_NAME'
                                           ,'ADV_ACCOUNT','TYPE_RESTRUCT','RATE_FIRST_DAY','SUM_CONTR_FOR_CLIENT'
                                           )
                            AND s.obj_gid = ctr_cls.contract_gid
                            AND s.source_system_id = ctr_cls.source_system_id
                            AND inBegDate + idx BETWEEN s.effective_start AND s.effective_end
              ) PIVOT (MAX(sign_val)
                  FOR sign_name IN (
                    'OVERDUE_PRINCIPAL' AS        overdue_principal
                   ,'OVERDUE_PRINCIPAL_EQV' AS    overdue_principal_eqv
                   ,'OVERDUE_INTEREST' AS         overdue_interest
                   ,'OVERDUE_INTEREST_EQV' AS     overdue_interest_eqv
                   ,'ACCOUNT_SUM_91311' AS        account_sum_91311
                   ,'ACCOUNT_NUM_91311' AS        account_num_91311
                   ,'ACCOUNT_NAME_91311' AS       account_name_91311
                   ,'ACCOUNT_SUM_91312' AS        account_sum_91312
                   ,'ACCOUNT_NUM_91312' AS        account_num_91312
                   ,'ACCOUNT_NAME_91312' AS       account_name_91312
                   ,'ACCOUNT_SUM_91313' AS        account_sum_91313
                   ,'ACCOUNT_NUM_91313' AS        account_num_91313
                   ,'ACCOUNT_NAME_91313' AS       account_name_91313
                   ,'ACCOUNT_SUM_91314' AS        account_sum_91314
                   ,'ACCOUNT_NUM_91314' AS        account_num_91314
                   ,'ACCOUNT_NAME_91314' AS       account_name_91314
                   ,'ACCOUNT_SUM_91414' AS        account_sum_91414
                   ,'ACCOUNT_NUM_91414' AS        account_num_91414
                   ,'ACCOUNT_NAME_91414' AS       account_name_91414
                   ,'CREDITLINE_ID' AS            creditline_id
                   ,'CREDITLINE_NO' AS            creditline_no
                   ,'CREDIT_STATE' AS             credit_state
                   ,'CREDIT_STATUS' AS            credit_status
                   ,'INTEREST_RATE_OPEN_DATE' AS  interest_rate_open_date
                   ,'REG_REGION' AS               reg_region
                   ,'CNT_CONTR_FOR_CLIENT' AS     cnt_contr_for_client
                   ,'COMMISS_MONTHLY' AS          commiss_monthly
                   ,'INTEREST_RATE_ACGN2' AS      interest_rate_acgn2
                   ,'PR_TRANSH' AS                pr_transh
                   ,'MAIN_PAYMENT' AS             main_payment
                   ,'PRC_PAYMENT' AS              prc_payment
                   ,'OKVED' AS                    okved
                   ,'BUSINESS' AS                 business
                   ,'SUM_FIRST_TURN_IBSO' AS      sum_first_turn_ibso
                   ,'SUM_FIRST_TURN_3CARD' AS     sum_first_turn_3card
                   ,'DATE_FIRST_TURN' AS          date_first_turn
                   ,'RESIDUE_VNB'              AS residue_vnb
                   ,'PRC_MAIN_VNB_AMOUNT' AS      prc_main_vnb_amount
                   ,'PRC_DEBT_VNB_AMOUNT' AS      prc_debt_vnb_amount
                   ,'UNUSED_CREDIT_LIMIT_EQV' AS  unused_credit_limit_eqv
                   ,'UNUSED_CREDIT_LIMIT' AS      unused_credit_limit
                   ,'UC_ID' AS                    uc_id
                   ,'PR_DEFOLT_CLIENT' AS         pr_defolt_client
                   ,'PR_PROBLEM_CLIENT' AS        pr_problem_client
                   ,'CREDIT_STATE_UL' AS          credit_state_ul
                   ,'PROVIS_PERCENT' AS           provis_percent
                   ,'PROVIS_PERCENT_CLIENT' AS    provis_percent_client
                   ,'OVERDUE_CLIENT' AS           overdue_client
                   ,'CLAIM_GID' AS                claim_gid
                   ,'ACCOUNT_SUM_91802' AS        account_sum_91802
                   ,'ACCOUNT_SUM_91803' AS        account_sum_91803
                   ,'ACCOUNT_SUM_91704' AS        account_sum_91704
                   ,'ACCOUNT_SUM_91604' AS        account_sum_91604
                   ,'ACCOUNT_SUM_91604_CLIENT' AS account_sum_91604_client
                   ,'OPEN_ABS_DEP_CODE'        AS open_abs_dep_code
                   ,'OPEN_ABS_DEP_NAME'        AS open_abs_dep_name
                   ,'SERV_DEPARTMENT_CODE'     AS serv_department_code
                   ,'SERV_DEPARTMENT_NAME'     AS serv_department_name
                   ,'SERV_DEPARTMENT_CITY'     AS serv_department_city
                   ,'SERV_DEPARTMENT_REGION'   AS serv_department_region
                   ,'SERV_DEP_BRANCH_NAME'     AS serv_dep_branch_name
                   ,'SERV_DEP_BRANCH_CODE'     AS serv_dep_branch_code
                   ,'OPEN_DEP_BRANCH_NAME'     AS open_dep_branch_name
                   ,'OPEN_DEP_BRANCH_CODE'     AS open_dep_branch_code
                   ,'ADV_ACCOUNT'              AS adv_account
                   ,'TYPE_RESTRUCT'            AS type_restruct
                   ,'RATE_FIRST_DAY'           AS rate_first_day
                   ,'SUM_CONTR_FOR_CLIENT'     AS sum_contr_for_client
                  )
                )
          )
         ,ptb AS (
            SELECT as_of_date
                  ,obj_gid
                  ,source_system_id
                  ,to_number(NVL(cnt_pays_od_on_debt,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')        AS cnt_pays_od_on_debt
                  ,to_number(NVL(amount_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                 AS amount_eqv
                  ,to_number(NVL(amount,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                     AS amount
                  ,to_number(NVL(prc_to_main,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                AS prc_to_main
                  ,to_number(NVL(amount_debt,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                AS amount_debt
                  ,to_number(NVL(amount_pay_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')             AS amount_pay_eqv
                  ,to_number(NVL(fee_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                    AS fee_eqv
                  ,to_number(NVL(cnt_overdue_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')         AS cnt_overdue_client
                  ,to_number(NVL(interest,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')                   AS interest
                  ,to_number(NVL(interest_eqv,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')               AS interest_eqv
                  ,to_number(NVL(sum_pay_od_main,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')            AS sum_pay_od_main
                  ,to_number(NVL(sum_pay_od_debt,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')            AS sum_pay_od_debt
                  ,to_number(NVL(max_sum_overdue_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')     AS max_sum_overdue_client
                  ,to_number(NVL(max_cnt_day_overdue_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''') AS max_cnt_day_overdue_client
                  ,to_number(NVL(max_fifo_for_client,'0'),'FM999999999999999D999999999','nls_numeric_characters='', ''')        AS max_fifo_for_client
              FROM (
                SELECT s.as_of_date
                      ,s.obj_gid
                      ,s.source_system_id
                      ,s.sign_name
                      ,s.sign_val
                FROM dm_skb.ptb_ctr_signs_new s
                     INNER JOIN ctr_cls ON ctr_cls.contract_gid = s.obj_gid AND ctr_cls.source_system_id = s.source_system_id
                WHERE s.sign_name IN ('CNT_PAYS_OD_ON_DEBT','AMOUNT_EQV','AMOUNT'
                                     ,'PRC_TO_MAIN'
                                     ,'AMOUNT_DEBT','AMOUNT_PAY_EQV'
                                     ,'FEE_EQV','CNT_OVERDUE_CLIENT','INTEREST','INTEREST_EQV','SUM_PAY_OD_MAIN','SUM_PAY_OD_DEBT'
                                     ,'MAX_SUM_OVERDUE_CLIENT','MAX_CNT_DAY_OVERDUE_CLIENT','MAX_FIFO_FOR_CLIENT'
                                     )
                  AND s.as_of_date = inBegDate + idx
              ) PIVOT (MAX(sign_val)
                  FOR sign_name IN (
                    'CNT_PAYS_OD_ON_DEBT'        AS cnt_pays_od_on_debt
                   ,'AMOUNT_EQV'                 AS amount_eqv
                   ,'AMOUNT'                     AS amount
                   ,'PRC_TO_MAIN'                AS prc_to_main
                   ,'AMOUNT_DEBT'                AS amount_debt
                   ,'AMOUNT_PAY_EQV'             AS amount_pay_eqv
                   ,'FEE_EQV'                    AS fee_eqv
                   ,'CNT_OVERDUE_CLIENT'         AS cnt_overdue_client
                   ,'INTEREST'                   AS interest
                   ,'INTEREST_EQV'               AS interest_eqv
                   ,'SUM_PAY_OD_MAIN'            AS sum_pay_od_main
                   ,'SUM_PAY_OD_DEBT'            AS sum_pay_od_debt
                   ,'MAX_SUM_OVERDUE_CLIENT'     AS max_sum_overdue_client
                   ,'MAX_CNT_DAY_OVERDUE_CLIENT' AS max_cnt_day_overdue_client
                   ,'MAX_FIFO_FOR_CLIENT'        AS max_fifo_for_client
                  )
                )
          )
         ,v AS (
            SELECT as_of_date
                  ,contract_gid
                  ,source_system_id
                  ,off_main_debt_vnb
                  ,off_prc_vnb
                  ,off_other_pays_vnb
              FROM (
                SELECT s.as_of_date
                      ,s.contract_gid
                      ,s.source_system_id
                      ,s.code AS ctr_idx
                      ,s.value_ AS ctr_val
                FROM dm_skb.dm_creds_in_work_values_val s
                     INNER JOIN ctr_cls ON ctr_cls.contract_gid = s.contract_gid AND ctr_cls.source_system_id = s.source_system_id
                WHERE s.code IN ('OFF_MAIN_DEBT_VNB','OFF_PRC_VNB','OFF_OTHER_PAYS_VNB')
                  AND s.as_of_date = inBegDate + idx
              ) PIVOT (MAX(ctr_val)
                  FOR ctr_idx IN (
                    'OFF_MAIN_DEBT_VNB'  AS off_main_debt_vnb
                   ,'OFF_PRC_VNB'        AS off_prc_vnb
                   ,'OFF_OTHER_PAYS_VNB' AS off_other_pays_vnb
                  )
                )
          )
         ,c AS (
            SELECT as_of_date
                  ,contract_gid
                  ,source_system_id
                  ,to_date(open_date,'DD.MM.YYYY') AS open_date
                  ,to_date(close_date,'DD.MM.YYYY') AS close_date
                  ,to_date(close_fact_date,'DD.MM.YYYY') AS close_fact_date
                  ,to_number(cur_id) AS cur_id
                  ,to_number(principal) AS principal
                  ,contract_no
                  ,to_number(NVL(interest_rate_of_agreement,'0')) AS interest_rate_of_agreement
                  ,to_number(loan_quality_cod) AS loan_quality_cod
                  ,to_number(contract_type_sid) AS contract_type_sid
                  ,to_number(restruct_code) AS restruct_code
                  ,to_number(created_by_employee_sid) AS created_by_employee_sid
                  ,to_number(client_sid) AS client_sid
                  ,to_number(abs_department_sid) AS abs_department_sid
              FROM (
                SELECT --+ INDEX(s UIX_2149873)
                       inBegDate + idx AS as_of_date
                      ,s.contract_gid
                      ,s.source_system_id
                      ,s.column_name AS ctr_idx
                      ,COALESCE(to_char(s.val_num),s.val_str,to_char(s.val_date,'DD.MM.YYYY')) AS ctr_val
                    FROM ctr_cls
                         INNER JOIN dwh.ref_contract_new s
                           ON s.column_name IN ('OPEN_DATE','CLOSE_DATE','CONTRACT_TYPE_SID','CLOSE_FACT_DATE'
                                               ,'CUR_ID','PRINCIPAL','CONTRACT_NO','INTEREST_RATE_OF_AGREEMENT','LOAN_QUALITY_COD'
                                               ,'RESTRUCT_CODE','CREATED_BY_EMPLOYEE_SID','CLIENT_SID','ABS_DEPARTMENT_SID'
                                               )
                              AND s.end_date = to_date('31.12.5999','DD.MM.YYYY')
                              AND s.contract_gid = ctr_cls.contract_gid
                              AND s.source_system_id = ctr_cls.source_system_id
                              AND inBegDate + idx BETWEEN s.effective_start AND s.effective_end
             ) PIVOT (MAX(ctr_val)
                  FOR ctr_idx IN (
                    'OPEN_DATE' AS                       open_date
                   ,'CLOSE_DATE' AS                      close_date
                   ,'CUR_ID' AS                          cur_id
                   ,'PRINCIPAL' AS                       principal
                   ,'CONTRACT_NO' AS                     contract_no
                   ,'INTEREST_RATE_OF_AGREEMENT' AS      interest_rate_of_agreement
                   ,'LOAN_QUALITY_COD' AS                loan_quality_cod
                   ,'CONTRACT_TYPE_SID' AS               contract_type_sid
                   ,'RESTRUCT_CODE' AS                   restruct_code
                   ,'CREATED_BY_EMPLOYEE_SID' AS         created_by_employee_sid
                   ,'CLIENT_SID' AS                      client_sid
                   ,'ABS_DEPARTMENT_SID' AS              abs_department_sid
                   ,'CLOSE_FACT_DATE'    AS              close_fact_date
                  )
                )
          )
         ,cl AS (
            SELECT as_of_date
                  ,client_gid
                  ,source_system_id
                  ,tin
                  ,client_type_flg
                  ,name
                  ,short_name
                  ,ogrn
                  ,okopf
                  ,okato
                  ,fin_state
              FROM (
                SELECT --+ INDEX(s UIX_2149394) 
                       inBegDate + idx AS as_of_date
                      ,s.client_gid
                      ,s.source_system_id
                      ,s.column_name AS ctr_idx
                      ,COALESCE(to_char(s.val_num),s.val_str,to_char(s.val_date,'DD.MM.YYYY')) AS ctr_val
                    FROM cl_cls
                         INNER JOIN dwh.ref_client_new s
                           ON s.column_name IN ('TIN','CLIENT_TYPE_FLG','NAME','SHORT_NAME','OGRN','OKOPF','OKATO','FIN_STATE')
                              AND s.end_date = to_date('31.12.5999','DD.MM.YYYY')
                              AND s.client_gid = cl_cls.client_gid
                              AND s.source_system_id = cl_cls.source_system_id
                              AND inBegDate + idx BETWEEN s.effective_start AND s.effective_end
              ) PIVOT (MAX(ctr_val)
                  FOR ctr_idx IN (
                    'TIN' AS               tin
                   ,'CLIENT_TYPE_FLG' AS   client_type_flg
                   ,'NAME' AS              name
                   ,'SHORT_NAME' AS        short_name
                   ,'OGRN' AS              ogrn
                   ,'OKOPF' AS             okopf
                   ,'OKATO' AS             okato
                   ,'FIN_STATE' AS         fin_state
                  )
                )
          )
         ,spec AS (
            SELECT as_of_date
                  ,contract_gid
                  ,source_system_id
                  ,to_date(delinq_date_fifo,'DD.MM.YYYY') AS delinq_date_fifo
                  ,to_date(delinq_date_lifo,'DD.MM.YYYY') AS delinq_date_lifo
                  ,to_date(delinquency_interest_date,'DD.MM.YYYY') AS delinquency_interest_date
                  ,to_number(NVL(rez_percent,'0')) AS rez_percent
                  ,to_number(NVL(interest_rate,'0')) AS interest_rate
                  ,to_number(loan_quality_cod_spec) AS loan_quality_cod_spec
                  ,to_number(NVL(account_interest_rate,'0')) AS account_interest_rate
                  ,to_number(NVL(effective_rate,'0')) AS effective_rate
                  ,to_number(port_sid) AS port_sid
                  ,to_number(loan_source_sid) AS loan_source_sid
                  ,to_number(loan_object_sid) AS loan_object_sid
                  ,to_number(loan_state) AS loan_state
                  ,to_number(fin_state) AS fin_state
              FROM (
                SELECT --+ INDEX(s UIX_2149781) 
                       inBegDate + idx AS as_of_date
                      ,s.contract_gid
                      ,s.source_system_id
                      ,CASE s.column_name
                         WHEN 'FIFO_DELINQUENCY_DATE' THEN 'DELINQ_DATE_FIFO'
                         WHEN 'DELINQUENCY_DATE' THEN 'DELINQ_DATE_LIFO'
                         WHEN 'LOAN_QUALITY_COD' THEN 'LOAN_QUALITY_COD_SPEC'
                       ELSE s.column_name
                       END AS ctr_idx
                      ,COALESCE(to_char(s.val_num),s.val_str,to_char(s.val_date,'DD.MM.YYYY')) AS ctr_val
                  FROM ctr_cls
                       INNER JOIN dwh.ref_contract_spec_new s
                         ON s.column_name IN ('FIFO_DELINQUENCY_DATE','DELINQUENCY_DATE','DELINQUENCY_INTEREST_DATE','REZ_PERCENT'
                                         ,'INTEREST_RATE','LOAN_QUALITY_COD','ACCOUNT_INTEREST_RATE','EFFECTIVE_RATE','PORT_SID'
                                         ,'LOAN_SOURCE_SID','LOAN_OBJECT_SID','LOAN_STATE','FIN_STATE'
                                         )
                            AND s.end_date = to_date('31.12.5999','DD.MM.YYYY')
                            AND s.contract_gid = ctr_cls.contract_gid
                            AND s.source_system_id = ctr_cls.source_system_id
                            AND inBegDate + idx BETWEEN s.effective_start AND s.effective_end
              ) PIVOT (MAX(ctr_val)
                  FOR ctr_idx IN (
                    'DELINQ_DATE_FIFO'          AS delinq_date_fifo
                   ,'DELINQ_DATE_LIFO'          AS delinq_date_lifo
                   ,'DELINQUENCY_INTEREST_DATE' AS delinquency_interest_date
                   ,'REZ_PERCENT'               AS rez_percent
                   ,'INTEREST_RATE'             AS interest_rate
                   ,'LOAN_QUALITY_COD_SPEC'     AS loan_quality_cod_spec
                   ,'ACCOUNT_INTEREST_RATE'     AS account_interest_rate
                   ,'EFFECTIVE_RATE'            AS effective_rate
                   ,'PORT_SID'                  AS port_sid
                   ,'LOAN_SOURCE_SID'           AS loan_source_sid
                   ,'LOAN_OBJECT_SID'           AS loan_object_sid
                   ,'LOAN_STATE'                AS loan_state
                   ,'FIN_STATE'                 AS fin_state
                  )
                )
          )
         ,emp AS (
            SELECT --+ result_cache 
                   employee_gid
                  ,source_system_id
                  ,val_str
                  ,effective_start
                  ,effective_end
              FROM dwh.ref_employees_for_dm
              WHERE column_name = 'EMPLOYEE_NAME'
                AND end_date = to_date('31.12.5999','DD.MM.YYYY')
          )
         ,spec_first_fin AS (
            SELECT --+ result_cache INDEX(s UIX_2149781) 
                       
                   s.contract_gid
                  ,s.source_system_id
                  ,s.val_num AS ctr_val
                  ,s.effective_start
                  ,s.effective_end
              FROM dwh.ref_contract_spec_new s
                   INNER JOIN ctr_cls ON ctr_cls.contract_gid = s.contract_gid AND ctr_cls.source_system_id = s.source_system_id
              WHERE s.column_name = 'FIN_STATE'
                AND s.end_date = to_date('31.12.5999','DD.MM.YYYY')
          )
         ,spec_first_loan AS (
            SELECT --+ result_cache INDEX(s UIX_2149781) 
                   s.contract_gid
                  ,s.source_system_id
                  ,s.val_num AS ctr_val
                  ,s.effective_start
                  ,s.effective_end
              FROM dwh.ref_contract_spec_new s
                   INNER JOIN ctr_cls ON ctr_cls.contract_gid = s.contract_gid AND ctr_cls.source_system_id = s.source_system_id
              WHERE s.column_name = 'LOAN_STATE'
                AND s.end_date = to_date('31.12.5999','DD.MM.YYYY')
          )
         ,spec_first_lq AS (
            SELECT --+ result_cache INDEX(s UIX_2149781) 
                   s.contract_gid
                  ,s.source_system_id
                  ,s.val_num AS ctr_val
                  ,s.effective_start
                  ,s.effective_end
              FROM dwh.ref_contract_spec_new s
                   INNER JOIN ctr_cls ON ctr_cls.contract_gid = s.contract_gid AND ctr_cls.source_system_id = s.source_system_id
              WHERE s.column_name = 'LOAN_QUALITY_COD'
                AND s.end_date = to_date('31.12.5999','DD.MM.YYYY')
          )
         ,cl_first_fin AS (
            SELECT --+ result_cache INDEX(s UIX_2149781) 
                   s.client_gid
                  ,s.source_system_id
                  ,s.val_str AS ctr_val
                  ,s.effective_start
                  ,s.effective_end
              FROM dwh.ref_client_new s
                   INNER JOIN cl_cls ON cl_cls.client_gid = s.client_gid AND cl_cls.source_system_id = s.source_system_id
              WHERE s.column_name = 'FIN_STATE'
                AND s.end_date = to_date('31.12.5999','DD.MM.YYYY')
          )
         ,con_first AS (
            SELECT --+ result_cache INDEX(s UIX_2149873) 
                   s.contract_gid
                  ,s.source_system_id
                  ,s.val_num AS ctr_val
                  ,s.effective_start
                  ,s.effective_end
              FROM dwh.ref_contract_new s
                   INNER JOIN ctr_cls ON ctr_cls.contract_gid = s.contract_gid AND ctr_cls.source_system_id = s.source_system_id
              WHERE s.column_name = 'LOAN_QUALITY_COD'
                AND s.end_date = to_date('31.12.5999','DD.MM.YYYY')
          )
         ,type_restr_date AS (
            SELECT --*+ result_cache INDEX(s UIX_3996585) 
                   s.obj_gid AS contract_gid
                  ,s.source_system_id
                  ,s.sign_val
                  ,s.effective_start
                  ,s.effective_end
              FROM dm_skb.tb_ctr_signs_new s
                   INNER JOIN ctr_cls ON ctr_cls.contract_gid = s.obj_gid AND ctr_cls.source_system_id = s.source_system_id
              WHERE s.sign_name = 'TYPE_RESTRUCT'
          )
        SELECT ctr.as_of_date
              ,ctr.source_system_id
              ,TRUNC(ctr.client_sid/10) client_gid
              ,tb.uc_id
              ,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' THEN 'Ф' ELSE 'Ю' END AS client_type_flg
              ,CASE WHEN ctr.contract_sid = 183457045231 THEN 'Кредиты ЮЛ'
                    WHEN ctr.source_system_id IN (2,4) OR
                        (INSTR(prt.code,'ФЛ')> 0 and INSTR(prt.code,'M')=0 and INSTR(prt.code,'М')=0) THEN 'Кредиты ФЛ'
                    WHEN INSTR(ct.contract_type_name,'МСБ') > 0 THEN 'Кредиты МСБ'
                    WHEN INSTR(ct.contract_type_name,'Корп') > 0 THEN 'Кредиты ЮЛ'
                    WHEN INSTR(prt.code,'M6') > 0 OR INSTR(prt.code,'М6') > 0  THEN
                       CASE WHEN c.open_date < to_date('08.02.2012','DD.MM.YYYY') THEN 'Кредиты МСБ' ELSE 'Кредиты ЮЛ' END
                    WHEN INSTR(prt.code,'K') > 0 OR INSTR(prt.code,'К') > 0 THEN 'Кредиты ЮЛ'
                    WHEN INSTR(prt.code,'M') > 0 OR INSTR(prt.code,'М') > 0 THEN 'Кредиты МСБ'
                 ELSE CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' THEN 'Кредиты ФЛ'
                      ELSE CASE WHEN INSTR(prt.code,'M')= 1 OR INSTR(prt.code,'М') = 1 OR
                                     INSTR(COALESCE(tb.creditline_no,c.contract_no),'M')= 1 OR INSTR(COALESCE(tb.creditline_no,c.contract_no),'М') = 1  
                             THEN 'Кредиты МСБ' ELSE 'Кредиты ФЛ'
                           END    
                      END
               END AS type_of_business
              ,cl.name AS full_name
              ,cl.short_name
              ,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 THEN 'Запрещено ДЭБ' ELSE cl.tin END AS tin
              ,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 THEN 'Запрещено ДЭБ' ELSE cl.ogrn END AS ogrn
              ,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 THEN 'Запрещено ДЭБ' ELSE tb.okved END AS okved
              ,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 THEN 'Запрещено ДЭБ' ELSE tb.business END AS business
              ,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 THEN 'Запрещено ДЭБ' ELSE okpf.short_name END AS okopf
              ,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' AND dm_skb.get_pd_access(USER, 0) = 0 THEN 'Запрещено ДЭБ' ELSE cl.okato END AS okato
              ,tb.reg_region
              ,NVL(tb.sum_contr_for_client,0) AS sum_contr_for_client
              ,NVL(tb.cnt_contr_for_client,0) AS cnt_contr_for_client
              ,tb.pr_defolt_client
              ,tb.pr_problem_client
              ,tb.claim_gid AS claim_id
              ,clm.target
              ,clm.claim_user_fio
              ,clm.claim_accept_bbr_fio AS fio_bbr
              ,clm.claim_accept_sb_fio  AS fio_deb
              ,clm.claim_accept_drb_fio AS fio_drb
              ,clm.claim_accept_user    AS fio_decision_claim
              ,COALESCE(tb.creditline_id,tb.obj_gid) AS id_contr
              ,NVL2(tb.creditline_id,tb.obj_gid,NULL) AS transh_gid
              ,COALESCE(tb.creditline_no,c.contract_no) AS contract_no
              ,NVL2(tb.creditline_no,c.contract_no,NULL) AS transh_no
              ,NVL(tb.pr_transh,'0') AS pr_transh
              ,ctr.source_system_id AS source_id_dog
              ,c.cur_id AS CODE
              ,to_number(c.principal) AS principal
              ,to_number(c.principal) * NVL(fcr.rate_of_exchange,1) AS principal_rur
              ,CASE
                 WHEN NVL(to_number(c.principal),0) = 0
                 THEN
                   GREATEST(tb.sum_first_turn,(ptb.amount_eqv + tb.overdue_principal_eqv + tb.unused_credit_limit_eqv))
                 ELSE c.principal * NVL(fcr.rate_of_exchange,1)
              END calc_sum_credit
              ,CASE WHEN tb.date_first_turn > ctr.as_of_date THEN 0 ELSE tb.sum_first_turn END AS sum_first_turn
              ,CASE WHEN tb.date_first_turn > ctr.as_of_date THEN NULL ELSE tb.date_first_turn END AS date_first_turn
              ,CASE WHEN c.close_fact_date <= ctr.as_of_date THEN c.close_fact_date ELSE c.close_date END  - CASE WHEN tb.date_first_turn > ctr.as_of_date THEN NULL ELSE tb.date_first_turn END AS life_term_contr
              ,CASE WHEN c.close_fact_date <= ctr.as_of_date THEN c.close_fact_date ELSE ctr.as_of_date END - CASE WHEN tb.date_first_turn > ctr.as_of_date THEN NULL ELSE tb.date_first_turn END AS valid_contr
              ,prod.name_lv0 AS hier_product_name_f
              ,prod.name_lv2 AS business_name_f
              ,prod.name_lv3 AS product_group_name_f
              ,prod.name_lv4 AS product_name_f
              ,c2p.p_id
              ,pg.product_group_name AS group_contract_type
              ,ct.contract_type_name AS contract_type
              ,ct.contract_type_name AS loan_type
              ,so.loan_source_name as loan_source_name
              ,ob.loan_object_name as loan_object_name
              ,c.open_date
              ,CASE WHEN tb.pr_transh = 2 THEN tr.d_beg ELSE NULL END AS open_date_transh
              ,c.close_date
              ,CASE WHEN c.close_fact_date <= ctr.as_of_date THEN c.close_fact_date ELSE NULL END AS close_fact_date
              ,NVL(tb.main_payment,0) AS main_payment
              ,NVL(tb.prc_payment,0) AS prc_payment
              ,CASE
                 WHEN ctr.source_system_id in (2,4) then
                   CASE
                     WHEN pg.product_group_name = 'Экспресс-кредиты' THEN 'Аннуитетный'
                     ELSE 'Дифференцированный'
                   END
                 ELSE
                   'Дифференцированный'
               END AS type_payment
              ,NVL(tb.interest_rate_open_date,0) AS interest_rate_open_date
              ,NVL(COALESCE(tb.interest_rate_acgn2,spec.account_interest_rate,spec.interest_rate,0),0) AS interest_rate
              ,tb.rate_first_day
              ,CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' THEN
                 NVL(tb.commiss_monthly,'0')
               ELSE 0
               END sum_komiss_month
              ,NVL(spec.effective_rate,0) AS effective_rate
              ,CASE WHEN tb.type_restruct IS NOT NULL THEN 1 ELSE 0 END AS pr_restruct
              ,c.restruct_code AS restruct_code
              ,type_restr_date.effective_start AS date_restruct
              ,tb.type_restruct
              ,CASE
                WHEN NVL(c.close_fact_date,to_date('31.12.5999','DD.MM.YYYY')) <= ctr.as_of_date THEN 'Закрыт'
                WHEN NVL(tb.account_sum_91802,0) + NVL(tb.account_sum_91803,0) + NVL(tb.account_sum_91704,0) + NVL(tb.account_sum_91604,0) > 0
                       AND NVL(ptb.amount_eqv,0) + NVL(tb.overdue_principal_eqv,0) <= 0
                  THEN 'На внебалансе'
                ELSE 'Работает'
               END AS status
              ,CASE WHEN tb.credit_state_ul IN ('Кредит действующий','Кредит погашен') THEN NULL ELSE tb.credit_state_ul END AS state
              ,emp.val_str  AS created_by_employee_dog
              ,tb.open_abs_dep_code AS department_code_dog_open
              ,tb.open_abs_dep_name AS department_name_dog_open
              ,tb.serv_department_code AS department_code_dog_issue
              ,tb.serv_department_name AS department_name_dog_issue
              ,tb.open_dep_branch_code AS branch_code_dog_open
              ,tb.open_dep_branch_name AS branch_name_dog_open
              ,tb.serv_dep_branch_code AS branch_code_dog_issue
              ,tb.serv_dep_branch_name AS branch_name_dog_issue
              ,tb.serv_department_city AS serv_dog_city
              ,tb.serv_department_region AS serv_dog_region
              ,tb.adv_account
              ,NVL2(to_char(cr_line.contract_sid),tb.adv_account,NULL) AS adv_account_transh
              ,NVL(ptb.amount,0) AS amount
              ,NVL(ptb.amount_eqv,0) AS amount_eqv
              ,NVL(tb.overdue_principal,0) AS overdue_principal
              ,NVL(tb.overdue_principal_eqv,0) AS overdue_principal_eqv
              ,NVL(ptb.amount,0) + NVL(tb.overdue_principal,0) AS sum_dolg
              ,NVL(ptb.amount_eqv,0) + NVL(tb.overdue_principal_eqv,0) AS sum_dolg_rur
              ,CASE
                 WHEN CASE 
                        WHEN ctr.contract_sid = 183457045231 THEN 'Кредиты ЮЛ'
                        WHEN ctr.source_system_id IN (2,4) OR
                             (INSTR(prt.code,'ФЛ')> 0 and INSTR(prt.code,'M')=0 and INSTR(prt.code,'М')=0) THEN 'Кредиты ФЛ'
                        WHEN INSTR(ct.contract_type_name,'МСБ') > 0 THEN 'Кредиты МСБ'
                        WHEN INSTR(ct.contract_type_name,'Корп') > 0 THEN 'Кредиты ЮЛ'
                        WHEN INSTR(prt.code,'M6') > 0 OR INSTR(prt.code,'М6') > 0  THEN
                          CASE WHEN c.open_date < to_date('08.02.2012','DD.MM.YYYY') THEN 'Кредиты МСБ' ELSE 'Кредиты ЮЛ' END
                        WHEN INSTR(prt.code,'K') > 0 OR INSTR(prt.code,'К') > 0 THEN 'Кредиты ЮЛ'
                        WHEN INSTR(prt.code,'M') > 0 OR INSTR(prt.code,'М') > 0 THEN 'Кредиты МСБ'
                 ELSE CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' THEN 'Кредиты ФЛ'
                      ELSE CASE WHEN INSTR(prt.code,'M')= 1 OR INSTR(prt.code,'М') = 1 OR
                                     INSTR(COALESCE(tb.creditline_no,c.contract_no),'M')= 1 OR INSTR(COALESCE(tb.creditline_no,c.contract_no),'М') = 1  
                             THEN 'Кредиты МСБ' ELSE 'Кредиты ФЛ'
                           END    
                      END
                 END = 'Кредиты ФЛ' then
                   CASE
                     WHEN ctr.as_of_date - spec.delinq_date_fifo >= 0 THEN
                       NVL(ptb.amount_eqv,0) + NVL(tb.overdue_principal_eqv,0)
                     ELSE
                       0
                   END
               ELSE
                 CASE
                   WHEN NVL(ptb.max_fifo_for_client,0) > 0 THEN
                     NVL(ptb.amount_eqv,'0') + NVL(tb.overdue_principal_eqv,'0')
                   ELSE
                     0
                 END
               END AS PROBLEM_DEBT
              ,CASE
                 WHEN CASE
                        WHEN ctr.contract_sid = 183457045231 THEN 'Кредиты ЮЛ'
                        WHEN ctr.source_system_id IN (2,4) OR
                             (INSTR(prt.code,'ФЛ')> 0 and INSTR(prt.code,'M')=0 and INSTR(prt.code,'М')=0) THEN 'Кредиты ФЛ'
                        WHEN INSTR(ct.contract_type_name,'МСБ') > 0 THEN 'Кредиты МСБ'
                        WHEN INSTR(ct.contract_type_name,'Корп') > 0 THEN 'Кредиты ЮЛ'
                        WHEN INSTR(prt.code,'M6') > 0 OR INSTR(prt.code,'М6') > 0  THEN
                          CASE WHEN c.open_date < to_date('08.02.2012','DD.MM.YYYY') THEN 'Кредиты МСБ' ELSE 'Кредиты ЮЛ' END
                        WHEN INSTR(prt.code,'K') > 0 OR INSTR(prt.code,'К') > 0 THEN 'Кредиты ЮЛ'
                        WHEN INSTR(prt.code,'M') > 0 OR INSTR(prt.code,'М') > 0 THEN 'Кредиты МСБ'
                 ELSE CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' THEN 'Кредиты ФЛ'
                      ELSE CASE WHEN INSTR(prt.code,'M')= 1 OR INSTR(prt.code,'М') = 1 OR
                                     INSTR(COALESCE(tb.creditline_no,c.contract_no),'M')= 1 OR INSTR(COALESCE(tb.creditline_no,c.contract_no),'М') = 1  
                             THEN 'Кредиты МСБ' ELSE 'Кредиты ФЛ'
                           END    
                      END
                 END = 'Кредиты ФЛ' then
                   CASE
                     WHEN ctr.as_of_date - spec.delinq_date_fifo >= 30 THEN
                       NVL(ptb.amount_eqv,'0') + NVL(tb.overdue_principal_eqv,0)
                     ELSE
                       0
                   END
               ELSE
                 CASE
                   WHEN NVL(ptb.max_fifo_for_client,0) > 30 THEN
                     NVL(ptb.amount_eqv,0) + NVL(tb.overdue_principal_eqv,0)
                   ELSE
                     0
                 END
               END AS PROBLEM_DEBT_30
              ,CASE
                 WHEN CASE
                        WHEN ctr.contract_sid = 183457045231 THEN 'Кредиты ЮЛ'
                        WHEN ctr.source_system_id IN (2,4) OR
                             (INSTR(prt.code,'ФЛ')> 0 and INSTR(prt.code,'M')=0 and INSTR(prt.code,'М')=0) THEN 'Кредиты ФЛ'
                        WHEN INSTR(ct.contract_type_name,'МСБ') > 0 THEN 'Кредиты МСБ'
                        WHEN INSTR(ct.contract_type_name,'Корп') > 0 THEN 'Кредиты ЮЛ'
                        WHEN INSTR(prt.code,'M6') > 0 OR INSTR(prt.code,'М6') > 0  THEN
                          CASE WHEN c.open_date < to_date('08.02.2012','DD.MM.YYYY') THEN 'Кредиты МСБ' ELSE 'Кредиты ЮЛ' END
                        WHEN INSTR(prt.code,'K') > 0 OR INSTR(prt.code,'К') > 0 THEN 'Кредиты ЮЛ'
                        WHEN INSTR(prt.code,'M') > 0 OR INSTR(prt.code,'М') > 0 THEN 'Кредиты МСБ'
                 ELSE CASE WHEN TRIM(cl.client_type_flg) LIKE 'Ф%' THEN 'Кредиты ФЛ'
                      ELSE CASE WHEN INSTR(prt.code,'M')= 1 OR INSTR(prt.code,'М') = 1 OR
                                     INSTR(COALESCE(tb.creditline_no,c.contract_no),'M')= 1 OR INSTR(COALESCE(tb.creditline_no,c.contract_no),'М') = 1  
                             THEN 'Кредиты МСБ' ELSE 'Кредиты ФЛ'
                           END    
                      END
                 END = 'Кредиты ФЛ' then
                   CASE
                     WHEN ctr.as_of_date - spec.delinq_date_fifo >= 90 THEN
                       NVL(ptb.amount_eqv,0) + NVL(tb.overdue_principal_eqv,0)
                     ELSE
                       0
                   END
               ELSE
                 CASE
                   WHEN NVL(ptb.max_fifo_for_client,0) > 90 THEN
                     NVL(ptb.amount_eqv,0) + NVL(tb.overdue_principal_eqv,0)
                   ELSE
                     0
                 END
               END AS DEFAULTED_DEBT
              ,NVL(tb.unused_credit_limit,0) AS unused_credit_limit
              ,NVL(tb.unused_credit_limit_eqv,0) AS unused_credit_limit_eqv
             ,(NVL(ptb.amount_eqv,0) + NVL(tb.overdue_principal_eqv,0)) *
                CASE WHEN NVL(prt.rez_percent,0) > 0 THEN NVL(prt.rez_percent,0)/100
                ELSE NVL(spec.rez_percent,0)/100 END AS principal_res
             ,NVL(tb.unused_credit_limit_eqv,0) *
                CASE WHEN NVL(prt.rez_percent,0) > 0 THEN NVL(prt.rez_percent,0)/100
                ELSE NVL(spec.rez_percent,0)/100 END AS unused_credit_limit_res
             ,(NVL(ptb.interest_eqv,0) + NVL(tb.overdue_interest_eqv,0)) *
                CASE WHEN NVL(prt.rez_percent,0) > 0 THEN NVL(prt.rez_percent,0)/100
                ELSE NVL(spec.rez_percent,0)/100 END AS interest_res
             ,NVL(ptb.fee_eqv,0) *
                CASE WHEN NVL(prt.rez_percent,0) > 0 THEN NVL(prt.rez_percent,0)/100
                ELSE NVL(spec.rez_percent,0)/100 END AS fee_res
              ,NVL(ptb.interest,0) AS interest
              ,NVL(ptb.interest_eqv,0) AS interest_eqv
              ,NVL(tb.overdue_interest,0) AS overdue_interest
              ,NVL(tb.overdue_interest_eqv,0) AS overdue_interest_eqv
              ,NVL(tb.prc_main_vnb_amount,0) AS prc_main_vnb_amount
              ,NVL(tb.prc_debt_vnb_amount,0) AS prc_debt_vnb_amount
              ,CASE
                 WHEN NVL(tb.account_sum_91802,0) +
                      NVL(tb.account_sum_91803,0) +
                      NVL(tb.account_sum_91704,0) +
                      NVL(tb.account_sum_91604,0) = 0
                   THEN NULL
                 ELSE
                   tb.off_date_vnb
               END AS off_date_vnb
              ,v.off_main_debt_vnb
              ,v.off_prc_vnb
              ,v.off_other_pays_vnb
              ,NVL(tb.account_sum_91802,0) AS account_sum_91802
              ,NVL(tb.account_sum_91704,0) AS account_sum_91704
              ,NVL(tb.account_sum_91604,0) AS account_sum_91604
              ,NVL(tb.account_sum_91803,0) AS account_sum_91803
              ,spec.delinq_date_fifo
              ,NVL(ctr.as_of_date - spec.delinq_date_fifo + 1, 0) AS cnt_delinq_date_fifo
              ,LEAST(NVL(spec.delinq_date_lifo,spec.delinquency_interest_date),NVL(spec.delinquency_interest_date,spec.delinq_date_lifo)) AS delinq_date_lifo
              ,NVL(ctr.as_of_date - LEAST(NVL(spec.delinq_date_lifo,spec.delinquency_interest_date),NVL(spec.delinquency_interest_date,spec.delinq_date_lifo)) + 1,0) AS cnt_delinq_date_lifo
              ,NVL(ptb.max_fifo_for_client,0) AS max_fifo_for_client
              ,prt.code AS code_pos
              ,NVL(spec.rez_percent,0) AS rez_percent
              ,CASE WHEN NOT(prt.code LIKE '%(И)%') THEN NVL(prt.rez_percent,0) ELSE 0 END AS calc_prc_reserve
              ,COALESCE(c.loan_quality_cod,spec.loan_quality_cod_spec) AS loan_quality_cod
              ,COALESCE(CASE spec.fin_state
                          WHEN 1 THEN 'Хорошее'
                          WHEN 2 THEN 'Среднее'
                          WHEN 3 THEN 'Плохое'
                        ELSE NULL
                        END
                        ,cl.fin_state) AS fin_state
              ,spec.loan_state as loan_state
              ,COALESCE(CASE spec_first_fin.ctr_val
                          WHEN 1 THEN 'Хорошее'
                          WHEN 2 THEN 'Среднее'
                          WHEN 3 THEN 'Плохое'
                        ELSE NULL
                        END
                        ,cl_first_fin.ctr_val) AS first_fin_state
              ,NVL(con_first.ctr_val,spec_first_lq.ctr_val) as first_loan_quality_cod
              ,spec_first_loan.ctr_val as first_loan_state
              ,NVL(ptb.cnt_overdue_client,0) AS cnt_overdue_client
              ,NVL(ptb.max_cnt_day_overdue_client,0) AS max_cnt_day_overdue_client
              ,NVL(ptb.max_sum_overdue_client,0) AS max_sum_overdue_client
              ,NVL(tb.account_sum_91311,0) +
               NVL(tb.account_sum_91312,0) +
               NVL(tb.account_sum_91313,0) +
               NVL(tb.account_sum_91314,0) AS account_sum_collateral
              ,NVL(tb.account_sum_91311,0) AS account_sum_91311
              ,tb.account_num_91311
              ,tb.account_name_91311
              ,NVL(tb.account_sum_91312,0) AS account_sum_91312
              ,tb.account_num_91312
              ,tb.account_name_91312
              ,NVL(tb.account_sum_91313,0) AS account_sum_91313
              ,tb.account_num_91313
              ,tb.account_name_91313
              ,NVL(tb.account_sum_91314,0) AS account_sum_91314
              ,tb.account_num_91314
              ,tb.account_name_91314
              ,NVL(tb.account_sum_91414,0) AS account_sum_91414
              ,tb.account_num_91414
              ,tb.account_name_91414
              ,NVL(tb.provis_percent,0) AS provis_percent
              ,NVL(tb.provis_percent_client,0) AS provis_percent_client
              ,NVL(clm.cred_dog_cft_bank,clm.cred_dog_in_3card) AS pr_source_refinans
              /*,NULL                               AS parent_dog_id_refinans
              ,to_date('01.01.1900','DD.MM.YYYY') AS date_refinans
              ,NULL                               AS sum_main_refinans
              ,NULL                               AS sum_debt_refinans
              ,NULL                               AS fifo_dog_refinans
              ,NULL                               AS fifo_client_refinans
              ,NULL                               AS sum_res_refinans
              ,NULL                               AS first_id_dog_refinans
              ,to_date('01.01.1900','DD.MM.YYYY') AS date_turn_refinans_first
              ,NULL                               AS sum_turn_refinans_first
              ,NULL                               AS last_id_dog_refinans
              ,NULL                               AS sum_turn_refinans_last
              ,to_date('01.01.1900','DD.MM.YYYY') AS date_turn_refinans_last
              ,NULL                               AS dolg_last_dog_refinans
              ,NULL                               AS fifo_last_dog_refinans
              ,NULL                               AS problem_debt_refinans
              ,NULL                               AS recove_res_main_refinans
              ,NULL                               AS recove_res_percent_refinans
              ,NULL                               AS recove_res_usl_refinans
              ,NULL                               AS sum_main_rur_refinans
              ,NULL                               AS sum_debt_od_refinans
              ,NULL                               AS sum_main_prc_refinans
              ,NULL                               AS sum_debt_prc_refinans
              ,NULL                               AS refin_komiss
              ,NULL                               AS refin_debt_komiss
              ,NULL                               AS refin_peny
              ,NULL                               AS refin_debt_vnb
              ,NULL                               AS refin_prc_vnb
              ,NULL                               AS refin_other_vnb
              ,to_date('01.01.1900','DD.MM.YYYY') AS date_price
              ,NULL                               AS sell_price
              ,NULL                               AS calc_prc_reserve_on_sale
              ,NULL                               AS sum_main_sold_debt
              ,NULL                               AS sum_prc_sold_balance
              ,NULL                               AS sum_other_receiv_sold
              ,NULL                               AS x_skb_client_status
              ,NULL                               AS in_work_units
              ,NULL                               AS stage_name
              ,NULL                               AS skb_stage_asgn_flg
              ,NULL                               AS stage_reason
              ,NULL                               AS day_stage
              ,NULL                               AS prev_stage_date
              ,NULL                               AS emp_name
              ,NULL                               AS skb_emp_date
              ,NULL                               AS ka_name
              ,NULL                               AS reg_number
              ,NULL                               AS ka_send_date
              ,NULL                               AS ka_plan_end_date
              ,NULL                               AS ka_count
              ,NULL                               AS reg_count
              ,NULL                               AS ka_deadline
              ,NULL                               AS reason
              ,NULL                               AS collection
              ,NULL                               AS x_skb_hand_last_call
              ,NULL                               AS pr_bankrot
              ,NULL                               AS amount_debt_pay_eqv
              ,NULL                               AS amount_debt_pay_eqv_refin
              ,NULL                               AS principal_res_restore
              ,NULL                               AS interest_res_restore
              ,NULL                               AS interest_res_restore_usl
              ,NULL                               AS payment_un_debt_osn_dolg_prev
              ,NULL                               AS payment_debt_osn_dolg_prev
              ,NULL                               AS payment_un_debt_prcnt_prev
              ,NULL                               AS payment_debt_prcnt_prev
              ,NULL                               AS payment_un_debt_comm_prev
              ,NULL                               AS payment_debt_comm_prev
              ,NULL                               AS payment_penalty_prev
              ,NULL                               AS payment_debt_odvnb_prev
              ,NULL                               AS payment_debt_prcvnb_prev
              ,NULL                               AS payment_debt_othvnb_prev
              ,NULL                               AS pay_gp
              ,NULL                               AS recovery_costs_client
              ,NULL                               AS recovery_court
              ,ctr.contract_sid
              ,ctr.contract_gid
              ,ctr.client_sid
              ,sst.system_name AS dog_system_name
              ,sst.bank_name AS dog_bank_name
              ,DECODE(c.cur_id,'840','Доллар США','978','Евро','810','Российский рубль','643','Российский рубль',NULL) AS code_naim
              ,NVL(ptb.fee_eqv,0) AS fee_eqv
          FROM dm_clant.ptb_creds_in_work ctr
               LEFT JOIN ptb
                 ON ptb.as_of_date = ctr.as_of_date
                    AND ptb.obj_gid = ctr.contract_gid
                    AND ptb.source_system_id = ctr.source_system_id
               LEFT JOIN v
                 ON v.as_of_date = ctr.as_of_date
                    AND v.contract_gid = ctr.contract_gid
                    AND v.source_system_id = ctr.source_system_id
               LEFT JOIN tb
                 ON tb.as_of_date = ctr.as_of_date
                    AND tb.obj_gid = ctr.contract_gid
                    AND tb.source_system_id = ctr.source_system_id
               LEFT JOIN c
                 ON c.as_of_date = ctr.as_of_date
                    AND c.contract_gid = ctr.contract_gid
                    AND c.source_system_id = ctr.source_system_id
               LEFT JOIN spec
                 ON spec.as_of_date = ctr.as_of_date
                    AND spec.contract_gid = ctr.contract_gid
                    AND spec.source_system_id = ctr.source_system_id
               LEFT JOIN cl
                 ON cl.as_of_date = ctr.as_of_date
                    AND cl.client_gid = TRUNC(ctr.client_sid/10)
                    AND cl.source_system_id = ctr.source_system_id
               LEFT JOIN dwh.ref_contract_type ct
                 ON ct.end_date = to_date('31.12.5999','DD.MM.YYYY')
                    AND ct.contract_type_sid = c.contract_type_sid
                    AND ctr.as_of_date BETWEEN ct.effective_start AND ct.effective_end
               LEFT JOIN dwh.ref_product_group pg
                 ON pg.product_group_gid = TRUNC(ct.product_group_sid/10)
                    AND pg.source_system_id = ct.source_system_id
                    AND pg.end_date = to_date('31.12.5999','DD.MM.YYYY')
                    AND ctr.as_of_date BETWEEN pg.effective_start AND pg.effective_end
               LEFT JOIN dwh.ref_port prt
                 ON prt.end_date = to_date('31.12.5999','DD.MM.YYYY')
                    AND prt.port_sid = spec.port_sid
                    AND ctr.as_of_date BETWEEN prt.effective_start AND prt.effective_end
               LEFT JOIN dwh.ref_port_kind knd
                 ON knd.end_date = to_date('31.12.5999','DD.MM.YYYY')
                    AND knd.port_kind_gid = prt.port_kind_gid
                    AND knd.source_system_id = prt.source_system_id
                    AND ctr.as_of_date BETWEEN knd.effective_start AND knd.effective_end
               LEFT JOIN dm_skb.dm_claims clm
                 ON clm.claim_id = tb.claim_gid
                    AND clm.source_system_id = tb.source_system_id
               LEFT JOIN dwh.fct_cur_rate fcr
                 ON fcr.cur_rate_date = ctr.as_of_date
                    AND fcr.cur_id = c.cur_id
               LEFT JOIN dm_clant.tb_ref_contract_2_product c2p
                 ON c2p.contract_sid = ctr.contract_sid
               LEFT JOIN dm_skb.mv_rep_product_dim prod
                 ON prod.id_lv0 = 4919561 -- Иерархия статей управленческого учета
                    AND prod.id_lv4 = c2p.p_id
                    AND ctr.as_of_date BETWEEN prod.start_date_lv1 AND prod.end_date_lv1
                    AND ctr.as_of_date BETWEEN prod.start_date_lv2 AND prod.end_date_lv2
                    AND ctr.as_of_date BETWEEN prod.start_date_lv3 AND prod.end_date_lv3
                    AND ctr.as_of_date BETWEEN prod.start_date_lv4 AND prod.end_date_lv4
               LEFT JOIN (SELECT so.loan_source_gid, so.source_system_id, so.loan_source_name, so.effective_start, so.effective_end
                            FROM dwh.ref_loan_source so
                            WHERE so.end_date = to_date('31.12.5999', 'dd.mm.yyyy')) so
                 ON so.loan_source_gid = TRUNC(spec.loan_source_sid/10)
                    AND so.source_system_id = spec.source_system_id
                    AND ctr.as_of_date BETWEEN so.effective_start AND so.effective_end
                LEFT JOIN (SELECT ob.loan_object_gid, ob.source_system_id, ob.loan_object_name, ob.effective_start, ob.effective_end
                             FROM dwh.ref_loan_object ob
                            WHERE ob.end_date = to_date('31.12.5999', 'dd.mm.yyyy')) ob
                  ON ob.loan_object_gid = TRUNC(spec.loan_object_sid/10)
                     AND ob.source_system_id = spec.source_system_id
                     AND ctr.as_of_date BETWEEN ob.effective_start AND ob.effective_end
                LEFT JOIN dwh.ref_credit_transh tr
                  ON tr.transh_gid = ctr.contract_gid
                     AND tr.source_system_id = ctr.source_system_id
                     AND tr.end_date = to_date('31.12.5999','DD.MM.YYYY')
                     AND ctr.as_of_date BETWEEN tr.effective_start AND tr.effective_end
                LEFT JOIN cr_line
                  ON cr_line.contract_sid = ctr.contract_sid
                     AND ctr.as_of_date BETWEEN cr_line.effective_start AND cr_line.effective_end
                LEFT JOIN emp
                  ON emp.employee_gid = TRUNC(c.created_by_employee_sid/10)
                     AND emp.source_system_id = c.source_system_id
                     AND ctr.as_of_date BETWEEN emp.effective_start AND emp.effective_end
                LEFT JOIN spec_first_fin
                  ON spec_first_fin.contract_gid = ctr.contract_gid
                     AND spec_first_fin.source_system_id = ctr.source_system_id
                     AND tb.date_first_turn BETWEEN spec_first_fin.effective_start AND spec_first_fin.effective_end
                LEFT JOIN spec_first_loan
                    ON spec_first_loan.contract_gid = ctr.contract_gid
                     AND spec_first_loan.source_system_id = ctr.source_system_id
                     AND tb.date_first_turn BETWEEN spec_first_loan.effective_start AND spec_first_loan.effective_end
                LEFT JOIN spec_first_lq
                  ON spec_first_lq.contract_gid = ctr.contract_gid
                     AND spec_first_lq.source_system_id = ctr.source_system_id
                     AND tb.date_first_turn BETWEEN spec_first_lq.effective_start AND spec_first_lq.effective_end
                LEFT JOIN cl_first_fin
                  ON cl_first_fin.client_gid = TRUNC(ctr.client_sid/10)
                     AND cl_first_fin.source_system_id = ctr.source_system_id
                     AND tb.date_first_turn BETWEEN cl_first_fin.effective_start AND spec_first_fin.effective_end
                LEFT JOIN con_first
                  ON con_first.contract_gid = ctr.contract_gid
                     AND con_first.source_system_id = ctr.source_system_id
                     AND tb.date_first_turn BETWEEN con_first.effective_start AND con_first.effective_end
                LEFT JOIN type_restr_date
                  ON type_restr_date.contract_gid = ctr.contract_gid
                     AND type_restr_date.source_system_id = ctr.source_system_id
                     AND ctr.as_of_date BETWEEN type_restr_date.effective_start AND type_restr_date.effective_end
                LEFT JOIN dm_skb.mv_rep_system_dim sst
                  ON sst.system_id = ctr.source_system_id
                LEFT JOIN dwh.ref_okopfs okpf
                  ON okpf.end_date = to_date('31.12.5999','DD.MM.YYYY')
                     AND okpf.code = cl.okopf
                     AND okpf.source_system_id = cl.source_system_id
                     AND ctr.as_of_date BETWEEN okpf.effective_start AND okpf.effective_end
                     AND ctr.as_of_date BETWEEN NVL(okpf.dfrom, to_date('01.01.1900', 'dd.mm.yyyy')) AND NVL(okpf.dto,SYSDATE)
     WHERE ctr.as_of_date = inBegDate + idx
       AND ct.contract_type_name <> 'Потребительский кредит_МФО'
      ) src ON (dest.contract_sid = src.contract_sid AND dest.as_of_date = src.as_of_date)
      WHEN NOT MATCHED THEN INSERT 
         (
          dest.AS_OF_DATE,
          dest.SOURCE_SYSTEM_ID,
          dest.CLIENT_GID,
          dest.UC_ID,
          dest.CLIENT_TYPE_FLG,
          dest.TYPE_OF_BUSINESS,
          dest.FULL_NAME,
          dest.SHORT_NAME,
          dest.TIN,
          dest.OGRN,
          dest.OKVED,
          dest.BUSINESS,
          dest.OKOPF,
          dest.OKATO,
          dest.REG_REGION,
          dest.SUM_CONTR_FOR_CLIENT,
          dest.CNT_CONTR_FOR_CLIENT,
          dest.PR_DEFOLT_CLIENT,
          dest.PR_PROBLEM_CLIENT,
          dest.CLAIM_ID,
          dest.TARGET,
          dest.CLAIM_USER_FIO,
          dest.FIO_BBR,
          dest.FIO_DEB,
          dest.FIO_DRB,
          dest.FIO_DECISION_CLAIM,
          dest.ID_CONTR,
          dest.TRANSH_GID,
          dest.CONTRACT_NO,
          dest.TRANSH_NO,
          dest.PR_TRANSH,
          dest.SOURCE_ID_DOG,
          dest.CODE,
          dest.PRINCIPAL,
          dest.PRINCIPAL_RUR,
          dest.calc_sum_credit,
          dest.SUM_FIRST_TURN,
          dest.DATE_FIRST_TURN,
          dest.LIFE_TERM_CONTR,
          dest.VALID_CONTR,
          dest.hier_product_name_f,
          dest.business_name_f,
          dest.product_group_name_f,
          dest.product_name_f,
          dest.p_id,
          dest.GROUP_CONTRACT_TYPE,
          dest.CONTRACT_TYPE,
          dest.LOAN_TYPE,
          dest.LOAN_SOURCE_NAME,
          dest.LOAN_OBJECT_NAME,
          dest.OPEN_DATE,
          dest.OPEN_DATE_TRANSH,
          dest.CLOSE_DATE,
          dest.CLOSE_FACT_DATE,
          dest.MAIN_PAYMENT,
          dest.PRC_PAYMENT,
          dest.TYPE_PAYMENT,
          dest.INTEREST_RATE_OPEN_DATE,
          dest.INTEREST_RATE,
          dest.RATE_FIRST_DAY,
          dest.SUM_KOMISS_MONTH,
          dest.EFFECTIVE_RATE,
          dest.PR_RESTRUCT,
          dest.RESTRUCT_CODE,
          dest.DATE_RESTRUCT,
          dest.TYPE_RESTRUCT,
          dest.STATUS,
          dest.STATE,
          dest.CREATED_BY_EMPLOYEE_DOG,
          dest.DEPARTMENT_CODE_DOG_OPEN,
          dest.DEPARTMENT_NAME_DOG_OPEN,
          dest.DEPARTMENT_CODE_DOG_ISSUE,
          dest.DEPARTMENT_NAME_DOG_ISSUE,
          dest.BRANCH_CODE_DOG_OPEN,
          dest.BRANCH_NAME_DOG_OPEN,
          dest.BRANCH_CODE_DOG_ISSUE,
          dest.BRANCH_NAME_DOG_ISSUE,
          dest.SERV_DOG_CITY,
          dest.SERV_DOG_REGION,
          dest.ADV_ACCOUNT,
          dest.ADV_ACCOUNT_TRANSH,
          dest.AMOUNT,
          dest.AMOUNT_EQV,
          dest.OVERDUE_PRINCIPAL,
          dest.OVERDUE_PRINCIPAL_EQV,
          dest.SUM_DOLG,
          dest.SUM_DOLG_RUR,
          dest.PROBLEM_DEBT,
          dest.PROBLEM_DEBT_30,
          dest.DEFAULTED_DEBT,
          dest.UNUSED_CREDIT_LIMIT,
          dest.UNUSED_CREDIT_LIMIT_EQV,
          dest.PRINCIPAL_RES,
          dest.UNUSED_CREDIT_LIMIT_RES,
          dest.INTEREST_RES,
          dest.FEE_RES,
          dest.INTEREST,
          dest.INTEREST_EQV,
          dest.OVERDUE_INTEREST,
          dest.OVERDUE_INTEREST_EQV,
          dest.PRC_DEBT_VNB_AMOUNT,
          dest.PRC_MAIN_VNB_AMOUNT,
          dest.OFF_DATE_VNB,
          dest.OFF_MAIN_DEBT_VNB,
          dest.OFF_PRC_VNB,
          dest.OFF_OTHER_PAYS_VNB,
          dest.ACCOUNT_SUM_91802,
          dest.ACCOUNT_SUM_91704,
          dest.ACCOUNT_SUM_91604,
          dest.ACCOUNT_SUM_91803,
          dest.DELINQ_DATE_FIFO,
          dest.CNT_DELINQ_DATE_FIFO,
          dest.DELINQ_DATE_LIFO,
          dest.CNT_DELINQ_DATE_LIFO,
          dest.MAX_FIFO_FOR_CLIENT,
          dest.CODE_POS,
          dest.REZ_PERCENT,
          dest.CALC_PRC_RESERVE,
          dest.LOAN_QUALITY_COD,
          dest.FIN_STATE,
          dest.LOAN_STATE,
          dest.FIRST_FIN_STATE,
          dest.FIRST_LOAN_QUALITY_COD,
          dest.FIRST_LOAN_STATE,
          dest.CNT_OVERDUE_CLIENT,
          dest.MAX_CNT_DAY_OVERDUE_CLIENT,
          dest.MAX_SUM_OVERDUE_CLIENT,
          dest.ACCOUNT_SUM_COLLATERAL,
          dest.ACCOUNT_SUM_91311,
          dest.ACCOUNT_NUM_91311,
          dest.ACCOUNT_NAME_91311,
          dest.ACCOUNT_SUM_91312,
          dest.ACCOUNT_NUM_91312,
          dest.ACCOUNT_NAME_91312,
          dest.ACCOUNT_SUM_91313,
          dest.ACCOUNT_NUM_91313,
          dest.ACCOUNT_NAME_91313,
          dest.ACCOUNT_SUM_91314,
          dest.ACCOUNT_NUM_91314,
          dest.ACCOUNT_NAME_91314,
          dest.ACCOUNT_SUM_91414,
          dest.ACCOUNT_NUM_91414,
          dest.ACCOUNT_NAME_91414,
          dest.PROVIS_PERCENT,
          dest.PROVIS_PERCENT_CLIENT,
          dest.PR_SOURCE_REFINANS,
          /*dest.PARENT_DOG_ID_REFINANS,
          dest.DATE_REFINANS,
          dest.SUM_MAIN_REFINANS,
          dest.SUM_DEBT_REFINANS,
          dest.FIFO_DOG_REFINANS,
          dest.FIFO_CLIENT_REFINANS,
          dest.SUM_RES_REFINANS,
          dest.FIRST_ID_DOG_REFINANS,
          dest.DATE_TURN_REFINANS_FIRST,
          dest.SUM_TURN_REFINANS_FIRST,
          dest.LAST_ID_DOG_REFINANS,
          dest.SUM_TURN_REFINANS_LAST,
          dest.DATE_TURN_REFINANS_LAST,
          dest.DOLG_LAST_DOG_REFINANS,
          dest.FIFO_LAST_DOG_REFINANS,
          dest.PROBLEM_DEBT_REFINANS,
          dest.RECOVE_RES_MAIN_REFINANS,
          dest.RECOVE_RES_PERCENT_REFINANS,
          dest.RECOVE_RES_USL_REFINANS,
          dest.SUM_MAIN_RUR_REFINANS,
          dest.SUM_DEBT_OD_REFINANS,
          dest.SUM_MAIN_PRC_REFINANS,
          dest.SUM_DEBT_PRC_REFINANS,
          dest.REFIN_KOMISS,
          dest.REFIN_DEBT_KOMISS,
          dest.REFIN_PENY,
          dest.REFIN_DEBT_VNB,
          dest.REFIN_PRC_VNB,
          dest.REFIN_OTHER_VNB,
          dest.DATE_PRICE,
          dest.SELL_PRICE,
          dest.CALC_PRC_RESERVE_ON_SALE,
          dest.SUM_MAIN_SOLD_DEBT,
          dest.SUM_PRC_SOLD_BALANCE,
          dest.SUM_OTHER_RECEIV_SOLD,
          dest.X_SKB_CLIENT_STATUS,
          dest.IN_WORK_UNITS,
          dest.STAGE_NAME,
          dest.SKB_STAGE_ASGN_FLG,
          dest.STAGE_REASON,
          dest.DAY_STAGE,
          dest.PREV_STAGE_DATE,
          dest.EMP_NAME,
          dest.SKB_EMP_DATE,
          dest.KA_NAME,
          dest.REG_NUMBER,
          dest.KA_SEND_DATE,
          dest.KA_PLAN_END_DATE,
          dest.KA_COUNT,
          dest.REG_COUNT,
          dest.KA_DEADLINE,
          dest.REASON,
          dest.COLLECTION,
          dest.X_SKB_HAND_LAST_CALL,
          dest.PR_BANKROT,
          dest.AMOUNT_DEBT_PAY_EQV,
          dest.AMOUNT_DEBT_PAY_EQV_REFIN,
          dest.PRINCIPAL_RES_RESTORE,
          dest.INTEREST_RES_RESTORE,
          dest.INTEREST_RES_RESTORE_USL,
          dest.PAYMENT_UN_DEBT_OSN_DOLG_PREV,
          dest.PAYMENT_DEBT_OSN_DOLG_PREV,
          dest.PAYMENT_UN_DEBT_PRCNT_PREV,
          dest.PAYMENT_DEBT_PRCNT_PREV,
          dest.PAYMENT_UN_DEBT_COMM_PREV,
          dest.PAYMENT_DEBT_COMM_PREV,
          dest.PAYMENT_PENALTY_PREV,
          dest.PAYMENT_DEBT_ODVNB_PREV,
          dest.PAYMENT_DEBT_PRCVNB_PREV,
          dest.PAYMENT_DEBT_OTHVNB_PREV,
          dest.PAY_GP,
          dest.RECOVERY_COSTS_CLIENT,
          dest.RECOVERY_COURT,
          dest.CONTRACT_SID,
          dest.CONTRACT_GID,
          dest.CLIENT_SID,
          dest.DOG_SYSTEM_NAME,
          dest.DOG_BANK_NAME,
          dest.code_naim,
          dest.fee_eqv
          ) VALUES (
                src.AS_OF_DATE,
                src.SOURCE_SYSTEM_ID,
                src.CLIENT_GID,
                src.UC_ID,
                src.CLIENT_TYPE_FLG,
                src.TYPE_OF_BUSINESS,
                src.FULL_NAME,
                src.SHORT_NAME,
                src.TIN,
                src.OGRN,
                src.OKVED,
                src.BUSINESS,
                src.OKOPF,
                src.OKATO,
                src.REG_REGION,
                src.SUM_CONTR_FOR_CLIENT,
                src.CNT_CONTR_FOR_CLIENT,
                src.PR_DEFOLT_CLIENT,
                src.PR_PROBLEM_CLIENT,
                src.CLAIM_ID,
                src.TARGET,
                src.CLAIM_USER_FIO,
                src.FIO_BBR,
                src.FIO_DEB,
                src.FIO_DRB,
                src.FIO_DECISION_CLAIM,
                src.ID_CONTR,
                src.TRANSH_GID,
                src.CONTRACT_NO,
                src.TRANSH_NO,
                src.PR_TRANSH,
                src.SOURCE_ID_DOG,
                src.CODE,
                src.PRINCIPAL,
                src.PRINCIPAL_RUR,
                src.calc_sum_credit,
                src.SUM_FIRST_TURN,
                src.DATE_FIRST_TURN,
                src.LIFE_TERM_CONTR,
                src.VALID_CONTR,
                src.hier_product_name_f,
                src.business_name_f,
                src.product_group_name_f,
                src.product_name_f,
                src.p_id,
                src.GROUP_CONTRACT_TYPE,
                src.CONTRACT_TYPE,
                src.LOAN_TYPE,
                src.LOAN_SOURCE_NAME,
                src.LOAN_OBJECT_NAME,
                src.OPEN_DATE,
                src.OPEN_DATE_TRANSH,
                src.CLOSE_DATE,
                src.CLOSE_FACT_DATE,
                src.MAIN_PAYMENT,
                src.PRC_PAYMENT,
                src.TYPE_PAYMENT,
                src.INTEREST_RATE_OPEN_DATE,
                src.INTEREST_RATE,
                src.RATE_FIRST_DAY,
                src.SUM_KOMISS_MONTH,
                src.EFFECTIVE_RATE,
                src.PR_RESTRUCT,
                src.RESTRUCT_CODE,
                src.DATE_RESTRUCT,
                src.TYPE_RESTRUCT,
                src.STATUS,
                src.STATE,
                src.CREATED_BY_EMPLOYEE_DOG,
                src.DEPARTMENT_CODE_DOG_OPEN,
                src.DEPARTMENT_NAME_DOG_OPEN,
                src.DEPARTMENT_CODE_DOG_ISSUE,
                src.DEPARTMENT_NAME_DOG_ISSUE,
                src.BRANCH_CODE_DOG_OPEN,
                src.BRANCH_NAME_DOG_OPEN,
                src.BRANCH_CODE_DOG_ISSUE,
                src.BRANCH_NAME_DOG_ISSUE,
                src.SERV_DOG_CITY,
                src.SERV_DOG_REGION,
                src.ADV_ACCOUNT,
                src.ADV_ACCOUNT_TRANSH,
                src.AMOUNT,
                src.AMOUNT_EQV,
                src.OVERDUE_PRINCIPAL,
                src.OVERDUE_PRINCIPAL_EQV,
                src.SUM_DOLG,
                src.SUM_DOLG_RUR,
                src.PROBLEM_DEBT,
                src.PROBLEM_DEBT_30,
                src.DEFAULTED_DEBT,
                src.UNUSED_CREDIT_LIMIT,
                src.UNUSED_CREDIT_LIMIT_EQV,
                src.PRINCIPAL_RES,
                src.UNUSED_CREDIT_LIMIT_RES,
                src.INTEREST_RES,
                src.FEE_RES,
                src.INTEREST,
                src.INTEREST_EQV,
                src.OVERDUE_INTEREST,
                src.OVERDUE_INTEREST_EQV,
                src.PRC_DEBT_VNB_AMOUNT,
                src.PRC_MAIN_VNB_AMOUNT,
                src.OFF_DATE_VNB,
                src.OFF_MAIN_DEBT_VNB,
                src.OFF_PRC_VNB,
                src.OFF_OTHER_PAYS_VNB,
                src.ACCOUNT_SUM_91802,
                src.ACCOUNT_SUM_91704,
                src.ACCOUNT_SUM_91604,
                src.ACCOUNT_SUM_91803,
                src.DELINQ_DATE_FIFO,
                src.CNT_DELINQ_DATE_FIFO,
                src.DELINQ_DATE_LIFO,
                src.CNT_DELINQ_DATE_LIFO,
                src.MAX_FIFO_FOR_CLIENT,
                src.CODE_POS,
                src.REZ_PERCENT,
                src.CALC_PRC_RESERVE,
                src.LOAN_QUALITY_COD,
                src.FIN_STATE,
                src.LOAN_STATE,
                src.FIRST_FIN_STATE,
                src.FIRST_LOAN_QUALITY_COD,
                src.FIRST_LOAN_STATE,
                src.CNT_OVERDUE_CLIENT,
                src.MAX_CNT_DAY_OVERDUE_CLIENT,
                src.MAX_SUM_OVERDUE_CLIENT,
                src.ACCOUNT_SUM_COLLATERAL,
                src.ACCOUNT_SUM_91311,
                src.ACCOUNT_NUM_91311,
                src.ACCOUNT_NAME_91311,
                src.ACCOUNT_SUM_91312,
                src.ACCOUNT_NUM_91312,
                src.ACCOUNT_NAME_91312,
                src.ACCOUNT_SUM_91313,
                src.ACCOUNT_NUM_91313,
                src.ACCOUNT_NAME_91313,
                src.ACCOUNT_SUM_91314,
                src.ACCOUNT_NUM_91314,
                src.ACCOUNT_NAME_91314,
                src.ACCOUNT_SUM_91414,
                src.ACCOUNT_NUM_91414,
                src.ACCOUNT_NAME_91414,
                src.PROVIS_PERCENT,
                src.PROVIS_PERCENT_CLIENT,
                src.PR_SOURCE_REFINANS,
                /*src.PARENT_DOG_ID_REFINANS,
                src.DATE_REFINANS,
                src.SUM_MAIN_REFINANS,
                src.SUM_DEBT_REFINANS,
                src.FIFO_DOG_REFINANS,
                src.FIFO_CLIENT_REFINANS,
                src.SUM_RES_REFINANS,
                src.FIRST_ID_DOG_REFINANS,
                src.DATE_TURN_REFINANS_FIRST,
                src.SUM_TURN_REFINANS_FIRST,
                src.LAST_ID_DOG_REFINANS,
                src.SUM_TURN_REFINANS_LAST,
                src.DATE_TURN_REFINANS_LAST,
                src.DOLG_LAST_DOG_REFINANS,
                src.FIFO_LAST_DOG_REFINANS,
                src.PROBLEM_DEBT_REFINANS,
                src.RECOVE_RES_MAIN_REFINANS,
                src.RECOVE_RES_PERCENT_REFINANS,
                src.RECOVE_RES_USL_REFINANS,
                src.SUM_MAIN_RUR_REFINANS,
                src.SUM_DEBT_OD_REFINANS,
                src.SUM_MAIN_PRC_REFINANS,
                src.SUM_DEBT_PRC_REFINANS,
                src.REFIN_KOMISS,
                src.REFIN_DEBT_KOMISS,
                src.REFIN_PENY,
                src.REFIN_DEBT_VNB,
                src.REFIN_PRC_VNB,
                src.REFIN_OTHER_VNB,
                src.DATE_PRICE,
                src.SELL_PRICE,
                src.CALC_PRC_RESERVE_ON_SALE,
                src.SUM_MAIN_SOLD_DEBT,
                src.SUM_PRC_SOLD_BALANCE,
                src.SUM_OTHER_RECEIV_SOLD,
                src.X_SKB_CLIENT_STATUS,
                src.IN_WORK_UNITS,
                src.STAGE_NAME,
                src.SKB_STAGE_ASGN_FLG,
                src.STAGE_REASON,
                src.DAY_STAGE,
                src.PREV_STAGE_DATE,
                src.EMP_NAME,
                src.SKB_EMP_DATE,
                src.KA_NAME,
                src.REG_NUMBER,
                src.KA_SEND_DATE,
                src.KA_PLAN_END_DATE,
                src.KA_COUNT,
                src.REG_COUNT,
                src.KA_DEADLINE,
                src.REASON,
                src.COLLECTION,
                src.X_SKB_HAND_LAST_CALL,
                src.PR_BANKROT,
                src.AMOUNT_DEBT_PAY_EQV,
                src.AMOUNT_DEBT_PAY_EQV_REFIN,
                src.PRINCIPAL_RES_RESTORE,
                src.INTEREST_RES_RESTORE,
                src.INTEREST_RES_RESTORE_USL,
                src.PAYMENT_UN_DEBT_OSN_DOLG_PREV,
                src.PAYMENT_DEBT_OSN_DOLG_PREV,
                src.PAYMENT_UN_DEBT_PRCNT_PREV,
                src.PAYMENT_DEBT_PRCNT_PREV,
                src.PAYMENT_UN_DEBT_COMM_PREV,
                src.PAYMENT_DEBT_COMM_PREV,
                src.PAYMENT_PENALTY_PREV,
                src.PAYMENT_DEBT_ODVNB_PREV,
                src.PAYMENT_DEBT_PRCVNB_PREV,
                src.PAYMENT_DEBT_OTHVNB_PREV,
                src.PAY_GP,
                src.RECOVERY_COSTS_CLIENT,
                src.RECOVERY_COURT,
                src.CONTRACT_SID,
                src.CONTRACT_GID,
                src.CLIENT_SID,
                src.DOG_SYSTEM_NAME,
                src.DOG_BANK_NAME,
                src.code_naim,
                src.fee_eqv)
      WHEN MATCHED THEN UPDATE SET
          dest.SOURCE_SYSTEM_ID              = src.SOURCE_SYSTEM_ID              ,
          dest.CLIENT_GID                    = src.CLIENT_GID                    ,
          dest.UC_ID                         = src.UC_ID                         ,
          dest.CLIENT_TYPE_FLG               = src.CLIENT_TYPE_FLG               ,
          dest.TYPE_OF_BUSINESS              = src.TYPE_OF_BUSINESS              ,
          dest.FULL_NAME                     = src.FULL_NAME                     ,
          dest.SHORT_NAME                    = src.SHORT_NAME                    ,
          dest.TIN                           = src.TIN                           ,
          dest.OGRN                          = src.OGRN                          ,
          dest.OKVED                         = src.OKVED                         ,
          dest.BUSINESS                      = src.BUSINESS                      ,
          dest.OKOPF                         = src.OKOPF                         ,
          dest.OKATO                         = src.OKATO                         ,
          dest.REG_REGION                    = src.REG_REGION                    ,
          dest.SUM_CONTR_FOR_CLIENT          = src.SUM_CONTR_FOR_CLIENT          ,
          dest.CNT_CONTR_FOR_CLIENT          = src.CNT_CONTR_FOR_CLIENT          ,
          dest.PR_DEFOLT_CLIENT              = src.PR_DEFOLT_CLIENT              ,
          dest.PR_PROBLEM_CLIENT             = src.PR_PROBLEM_CLIENT             ,
          dest.CLAIM_ID                      = src.CLAIM_ID                      ,
          dest.TARGET                        = src.TARGET                        ,
          dest.CLAIM_USER_FIO                = src.CLAIM_USER_FIO                ,
          dest.FIO_BBR                       = src.FIO_BBR                       ,
          dest.FIO_DEB                       = src.FIO_DEB                       ,
          dest.FIO_DRB                       = src.FIO_DRB                       ,
          dest.FIO_DECISION_CLAIM            = src.FIO_DECISION_CLAIM            ,
          dest.ID_CONTR                      = src.ID_CONTR                      ,
          dest.TRANSH_GID                    = src.TRANSH_GID                    ,
          dest.CONTRACT_NO                   = src.CONTRACT_NO                   ,
          dest.TRANSH_NO                     = src.TRANSH_NO                     ,
          dest.PR_TRANSH                     = src.PR_TRANSH                     ,
          dest.SOURCE_ID_DOG                 = src.SOURCE_ID_DOG                 ,
          dest.CODE                          = src.CODE                          ,
          dest.PRINCIPAL                     = src.PRINCIPAL                     ,
          dest.PRINCIPAL_RUR                 = src.PRINCIPAL_RUR                 ,
          dest.calc_sum_credit               = src.calc_sum_credit               ,
          dest.SUM_FIRST_TURN                = src.SUM_FIRST_TURN                ,
          dest.DATE_FIRST_TURN               = src.DATE_FIRST_TURN               ,
          dest.LIFE_TERM_CONTR               = src.LIFE_TERM_CONTR               ,
          dest.VALID_CONTR                   =  src.VALID_CONTR                  ,
          dest.hier_product_name_f           = src.hier_product_name_f           ,
          dest.business_name_f               = src.business_name_f               ,
          dest.product_group_name_f          = src.product_group_name_f          ,
          dest.product_name_f                = src.product_name_f                ,
          dest.p_id                          = src.p_id                          ,
          dest.GROUP_CONTRACT_TYPE           = src.GROUP_CONTRACT_TYPE           ,
          dest.CONTRACT_TYPE                 = src.CONTRACT_TYPE                 ,
          dest.LOAN_TYPE                     = src.LOAN_TYPE                     ,
          dest.LOAN_SOURCE_NAME              = src.LOAN_SOURCE_NAME              ,
          dest.LOAN_OBJECT_NAME              = src.LOAN_OBJECT_NAME              ,
          dest.OPEN_DATE                     = src.OPEN_DATE                     ,
          dest.OPEN_DATE_TRANSH              = src.OPEN_DATE_TRANSH              ,
          dest.CLOSE_DATE                    = src.CLOSE_DATE                    ,
          dest.CLOSE_FACT_DATE               = src.CLOSE_FACT_DATE               ,
          dest.MAIN_PAYMENT                  = src.MAIN_PAYMENT                  ,
          dest.PRC_PAYMENT                   = src.PRC_PAYMENT                   ,
          dest.TYPE_PAYMENT                  = src.TYPE_PAYMENT                  ,
          dest.INTEREST_RATE_OPEN_DATE       = src.INTEREST_RATE_OPEN_DATE       ,
          dest.INTEREST_RATE                 = src.INTEREST_RATE                 ,
          dest.RATE_FIRST_DAY                = src.RATE_FIRST_DAY                ,
          dest.SUM_KOMISS_MONTH              = src.SUM_KOMISS_MONTH              ,
          dest.EFFECTIVE_RATE                = src.EFFECTIVE_RATE                ,
          dest.PR_RESTRUCT                   = src.PR_RESTRUCT                   ,
          dest.RESTRUCT_CODE                 = src.RESTRUCT_CODE                 ,
          dest.DATE_RESTRUCT                 = src.DATE_RESTRUCT                 ,
          dest.TYPE_RESTRUCT                 = src.TYPE_RESTRUCT                 ,
          dest.STATUS                        = src.STATUS                        ,
          dest.STATE                         = src.STATE                         ,
          dest.CREATED_BY_EMPLOYEE_DOG       = src.CREATED_BY_EMPLOYEE_DOG       ,
          dest.DEPARTMENT_CODE_DOG_OPEN      = src.DEPARTMENT_CODE_DOG_OPEN      ,
          dest.DEPARTMENT_NAME_DOG_OPEN      = src.DEPARTMENT_NAME_DOG_OPEN      ,
          dest.DEPARTMENT_CODE_DOG_ISSUE     = src.DEPARTMENT_CODE_DOG_ISSUE     ,
          dest.DEPARTMENT_NAME_DOG_ISSUE     = src.DEPARTMENT_NAME_DOG_ISSUE     ,
          dest.BRANCH_CODE_DOG_OPEN          = src.BRANCH_CODE_DOG_OPEN          ,
          dest.BRANCH_NAME_DOG_OPEN          = src.BRANCH_NAME_DOG_OPEN          ,
          dest.BRANCH_CODE_DOG_ISSUE         = src.BRANCH_CODE_DOG_ISSUE         ,
          dest.BRANCH_NAME_DOG_ISSUE         = src.BRANCH_NAME_DOG_ISSUE         ,
          dest.SERV_DOG_CITY                 = src.SERV_DOG_CITY                 ,
          dest.SERV_DOG_REGION               = src.SERV_DOG_REGION               ,
          dest.ADV_ACCOUNT                   = src.ADV_ACCOUNT                   ,
          dest.ADV_ACCOUNT_TRANSH            = src.ADV_ACCOUNT_TRANSH            ,
          dest.AMOUNT                        = src.AMOUNT                        ,
          dest.AMOUNT_EQV                    = src.AMOUNT_EQV                    ,
          dest.OVERDUE_PRINCIPAL             = src.OVERDUE_PRINCIPAL             ,
          dest.OVERDUE_PRINCIPAL_EQV         = src.OVERDUE_PRINCIPAL_EQV         ,
          dest.SUM_DOLG                      = src.SUM_DOLG                      ,
          dest.SUM_DOLG_RUR                  = src.SUM_DOLG_RUR                  ,
          dest.PROBLEM_DEBT                  = src.PROBLEM_DEBT                  ,
          dest.PROBLEM_DEBT_30               = src.PROBLEM_DEBT_30               ,
          dest.DEFAULTED_DEBT                = src.DEFAULTED_DEBT                ,
          dest.UNUSED_CREDIT_LIMIT           = src.UNUSED_CREDIT_LIMIT           ,
          dest.UNUSED_CREDIT_LIMIT_EQV       = src.UNUSED_CREDIT_LIMIT_EQV       ,
          dest.PRINCIPAL_RES                 = src.PRINCIPAL_RES                 ,
          dest.UNUSED_CREDIT_LIMIT_RES       = src.UNUSED_CREDIT_LIMIT_RES       ,
          dest.INTEREST_RES                  = src.INTEREST_RES                  ,
          dest.FEE_RES                       = src.FEE_RES                       ,
          dest.INTEREST                      = src.INTEREST                      ,
          dest.INTEREST_EQV                  = src.INTEREST_EQV                  ,
          dest.OVERDUE_INTEREST              = src.OVERDUE_INTEREST              ,
          dest.OVERDUE_INTEREST_EQV          = src.OVERDUE_INTEREST_EQV          ,
          dest.PRC_DEBT_VNB_AMOUNT           = src.PRC_DEBT_VNB_AMOUNT           ,
          dest.PRC_MAIN_VNB_AMOUNT           = src.PRC_MAIN_VNB_AMOUNT           ,
          dest.OFF_DATE_VNB                  = src.OFF_DATE_VNB                  ,
          dest.OFF_MAIN_DEBT_VNB             = src.OFF_MAIN_DEBT_VNB             ,
          dest.OFF_PRC_VNB                   = src.OFF_PRC_VNB                   ,
          dest.OFF_OTHER_PAYS_VNB            = src.OFF_OTHER_PAYS_VNB            ,
          dest.ACCOUNT_SUM_91802             = src.ACCOUNT_SUM_91802             ,
          dest.ACCOUNT_SUM_91704             = src.ACCOUNT_SUM_91704             ,
          dest.ACCOUNT_SUM_91604             = src.ACCOUNT_SUM_91604             ,
          dest.ACCOUNT_SUM_91803             = src.ACCOUNT_SUM_91803             ,
          dest.DELINQ_DATE_FIFO              = src.DELINQ_DATE_FIFO              ,
          dest.CNT_DELINQ_DATE_FIFO          = src.CNT_DELINQ_DATE_FIFO          ,
          dest.DELINQ_DATE_LIFO              = src.DELINQ_DATE_LIFO              ,
          dest.CNT_DELINQ_DATE_LIFO          = src.CNT_DELINQ_DATE_LIFO          ,
          dest.MAX_FIFO_FOR_CLIENT           = src.MAX_FIFO_FOR_CLIENT           ,
          dest.CODE_POS                      = src.CODE_POS                      ,
          dest.REZ_PERCENT                   = src.REZ_PERCENT                   ,
          dest.CALC_PRC_RESERVE              = src.CALC_PRC_RESERVE              ,
          dest.LOAN_QUALITY_COD              = src.LOAN_QUALITY_COD              ,
          dest.FIN_STATE                     = src.FIN_STATE                     ,
          dest.LOAN_STATE                    = src.LOAN_STATE                    ,
          dest.FIRST_FIN_STATE               = src.FIRST_FIN_STATE               ,
          dest.FIRST_LOAN_QUALITY_COD        = src.FIRST_LOAN_QUALITY_COD        ,
          dest.FIRST_LOAN_STATE              = src.FIRST_LOAN_STATE              ,
          dest.CNT_OVERDUE_CLIENT            = src.CNT_OVERDUE_CLIENT            ,
          dest.MAX_CNT_DAY_OVERDUE_CLIENT    = src.MAX_CNT_DAY_OVERDUE_CLIENT    ,
          dest.MAX_SUM_OVERDUE_CLIENT        = src.MAX_SUM_OVERDUE_CLIENT        ,
          dest.ACCOUNT_SUM_COLLATERAL        = src.ACCOUNT_SUM_COLLATERAL        ,
          dest.ACCOUNT_SUM_91311             = src.ACCOUNT_SUM_91311             ,
          dest.ACCOUNT_NUM_91311             = src.ACCOUNT_NUM_91311             ,
          dest.ACCOUNT_NAME_91311            = src.ACCOUNT_NAME_91311            ,
          dest.ACCOUNT_SUM_91312             = src.ACCOUNT_SUM_91312             ,
          dest.ACCOUNT_NUM_91312             = src.ACCOUNT_NUM_91312             ,
          dest.ACCOUNT_NAME_91312            = src.ACCOUNT_NAME_91312            ,
          dest.ACCOUNT_SUM_91313             = src.ACCOUNT_SUM_91313             ,
          dest.ACCOUNT_NUM_91313             = src.ACCOUNT_NUM_91313             ,
          dest.ACCOUNT_NAME_91313            = src.ACCOUNT_NAME_91313            ,
          dest.ACCOUNT_SUM_91314             = src.ACCOUNT_SUM_91314             ,
          dest.ACCOUNT_NUM_91314             = src.ACCOUNT_NUM_91314             ,
          dest.ACCOUNT_NAME_91314            = src.ACCOUNT_NAME_91314            ,
          dest.ACCOUNT_SUM_91414             = src.ACCOUNT_SUM_91414             ,
          dest.ACCOUNT_NUM_91414             = src.ACCOUNT_NUM_91414             ,
          dest.ACCOUNT_NAME_91414            = src.ACCOUNT_NAME_91414            ,
          dest.PROVIS_PERCENT                = src.PROVIS_PERCENT                ,
          dest.PROVIS_PERCENT_CLIENT         = src.PROVIS_PERCENT_CLIENT         ,
          dest.PR_SOURCE_REFINANS            = src.PR_SOURCE_REFINANS            ,
          /*dest.PARENT_DOG_ID_REFINANS        = src.PARENT_DOG_ID_REFINANS        ,
          dest.DATE_REFINANS                 = src.DATE_REFINANS                 ,
          dest.SUM_MAIN_REFINANS             = src.SUM_MAIN_REFINANS             ,
          dest.SUM_DEBT_REFINANS             = src.SUM_DEBT_REFINANS             ,
          dest.FIFO_DOG_REFINANS             = src.FIFO_DOG_REFINANS             ,
          dest.FIFO_CLIENT_REFINANS          = src.FIFO_CLIENT_REFINANS          ,
          dest.SUM_RES_REFINANS              = src.SUM_RES_REFINANS              ,
          dest.FIRST_ID_DOG_REFINANS         = src.FIRST_ID_DOG_REFINANS         ,
          dest.DATE_TURN_REFINANS_FIRST      = src.DATE_TURN_REFINANS_FIRST      ,
          dest.SUM_TURN_REFINANS_FIRST       = src.SUM_TURN_REFINANS_FIRST       ,
          dest.LAST_ID_DOG_REFINANS          = src.LAST_ID_DOG_REFINANS          ,
          dest.SUM_TURN_REFINANS_LAST        = src.SUM_TURN_REFINANS_LAST        ,
          dest.DATE_TURN_REFINANS_LAST       = src.DATE_TURN_REFINANS_LAST       ,
          dest.DOLG_LAST_DOG_REFINANS        = src.DOLG_LAST_DOG_REFINANS        ,
          dest.FIFO_LAST_DOG_REFINANS        = src.FIFO_LAST_DOG_REFINANS        ,
          dest.PROBLEM_DEBT_REFINANS         = src.PROBLEM_DEBT_REFINANS         ,
          dest.RECOVE_RES_MAIN_REFINANS      = src.RECOVE_RES_MAIN_REFINANS      ,
          dest.RECOVE_RES_PERCENT_REFINANS   = src.RECOVE_RES_PERCENT_REFINANS   ,
          dest.RECOVE_RES_USL_REFINANS       = src.RECOVE_RES_USL_REFINANS       ,
          dest.SUM_MAIN_RUR_REFINANS         = src.SUM_MAIN_RUR_REFINANS         ,
          dest.SUM_DEBT_OD_REFINANS          = src.SUM_DEBT_OD_REFINANS          ,
          dest.SUM_MAIN_PRC_REFINANS         = src.SUM_MAIN_PRC_REFINANS         ,
          dest.SUM_DEBT_PRC_REFINANS         = src.SUM_DEBT_PRC_REFINANS         ,
          dest.REFIN_KOMISS                  = src.REFIN_KOMISS                  ,
          dest.REFIN_DEBT_KOMISS             = src.REFIN_DEBT_KOMISS             ,
          dest.REFIN_PENY                    = src.REFIN_PENY                    ,
          dest.REFIN_DEBT_VNB                = src.REFIN_DEBT_VNB                ,
          dest.REFIN_PRC_VNB                 = src.REFIN_PRC_VNB                 ,
          dest.REFIN_OTHER_VNB               = src.REFIN_OTHER_VNB               ,
          dest.DATE_PRICE                    = src.DATE_PRICE                    ,
          dest.SELL_PRICE                    = src.SELL_PRICE                    ,
          dest.CALC_PRC_RESERVE_ON_SALE      = src.CALC_PRC_RESERVE_ON_SALE      ,
          dest.SUM_MAIN_SOLD_DEBT            = src.SUM_MAIN_SOLD_DEBT            ,
          dest.SUM_PRC_SOLD_BALANCE          = src.SUM_PRC_SOLD_BALANCE          ,
          dest.SUM_OTHER_RECEIV_SOLD         = src.SUM_OTHER_RECEIV_SOLD         ,
          dest.X_SKB_CLIENT_STATUS           = src.X_SKB_CLIENT_STATUS           ,
          dest.IN_WORK_UNITS                 = src.IN_WORK_UNITS                 ,
          dest.STAGE_NAME                    = src.STAGE_NAME                    ,
          dest.SKB_STAGE_ASGN_FLG            = src.SKB_STAGE_ASGN_FLG            ,
          dest.STAGE_REASON                  = src.STAGE_REASON                  ,
          dest.DAY_STAGE                     = src.DAY_STAGE                     ,
          dest.PREV_STAGE_DATE               = src.PREV_STAGE_DATE               ,
          dest.EMP_NAME                      = src.EMP_NAME                      ,
          dest.SKB_EMP_DATE                  = src.SKB_EMP_DATE                  ,
          dest.KA_NAME                       = src.KA_NAME                       ,
          dest.REG_NUMBER                    = src.REG_NUMBER                    ,
          dest.KA_SEND_DATE                  = src.KA_SEND_DATE                  ,
          dest.KA_PLAN_END_DATE              = src.KA_PLAN_END_DATE              ,
          dest.KA_COUNT                      = src.KA_COUNT                      ,
          dest.REG_COUNT                     = src.REG_COUNT                     ,
          dest.KA_DEADLINE                   = src.KA_DEADLINE                   ,
          dest.REASON                        = src.REASON                        ,
          dest.COLLECTION                    = src.COLLECTION                    ,
          dest.X_SKB_HAND_LAST_CALL          = src.X_SKB_HAND_LAST_CALL          ,
          dest.PR_BANKROT                    = src.PR_BANKROT                    ,
          dest.AMOUNT_DEBT_PAY_EQV           = src.AMOUNT_DEBT_PAY_EQV           ,
          dest.AMOUNT_DEBT_PAY_EQV_REFIN     = src.AMOUNT_DEBT_PAY_EQV_REFIN     ,
          dest.PRINCIPAL_RES_RESTORE         = src.PRINCIPAL_RES_RESTORE         ,
          dest.INTEREST_RES_RESTORE          = src.INTEREST_RES_RESTORE          ,
          dest.INTEREST_RES_RESTORE_USL      = src.INTEREST_RES_RESTORE_USL      ,
          dest.PAYMENT_UN_DEBT_OSN_DOLG_PREV = src.PAYMENT_UN_DEBT_OSN_DOLG_PREV ,
          dest.PAYMENT_DEBT_OSN_DOLG_PREV    = src.PAYMENT_DEBT_OSN_DOLG_PREV    ,
          dest.PAYMENT_UN_DEBT_PRCNT_PREV    = src.PAYMENT_UN_DEBT_PRCNT_PREV    ,
          dest.PAYMENT_DEBT_PRCNT_PREV       = src.PAYMENT_DEBT_PRCNT_PREV       ,
          dest.PAYMENT_UN_DEBT_COMM_PREV     = src.PAYMENT_UN_DEBT_COMM_PREV     ,
          dest.PAYMENT_DEBT_COMM_PREV        = src.PAYMENT_DEBT_COMM_PREV        ,
          dest.PAYMENT_PENALTY_PREV          = src.PAYMENT_PENALTY_PREV          ,
          dest.PAYMENT_DEBT_ODVNB_PREV       = src.PAYMENT_DEBT_ODVNB_PREV       ,
          dest.PAYMENT_DEBT_PRCVNB_PREV      = src.PAYMENT_DEBT_PRCVNB_PREV      ,
          dest.PAYMENT_DEBT_OTHVNB_PREV      = src.PAYMENT_DEBT_OTHVNB_PREV      ,
          dest.PAY_GP                        = src.PAY_GP                        ,
          dest.RECOVERY_COSTS_CLIENT         = src.RECOVERY_COSTS_CLIENT         ,
          dest.RECOVERY_COURT                = src.RECOVERY_COURT                ,
          dest.CONTRACT_GID                  = src.CONTRACT_GID                  ,
          dest.CLIENT_SID                    = src.CLIENT_SID                    ,
          dest.DOG_SYSTEM_NAME               = src.DOG_SYSTEM_NAME               ,
          dest.DOG_BANK_NAME                 = src.DOG_BANK_NAME                 ,
          dest.code_naim                     = src.code_naim                     , 
          dest.fee_eqv                       = src.fee_eqv   
          WHERE                    
          dm_skb.pkg_etl_signs.isEqual(SOURCE_SYSTEM_ID              , src.SOURCE_SYSTEM_ID              ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CLIENT_GID                    , src.CLIENT_GID                    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(UC_ID                         , src.UC_ID                         ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CLIENT_TYPE_FLG               , src.CLIENT_TYPE_FLG               ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(TYPE_OF_BUSINESS              , src.TYPE_OF_BUSINESS              ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(FULL_NAME                     , src.FULL_NAME                     ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SHORT_NAME                    , src.SHORT_NAME                    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(TIN                           , src.TIN                           ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(OGRN                          , src.OGRN                          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(OKVED                         , src.OKVED                         ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(BUSINESS                      , src.BUSINESS                      ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(OKOPF                         , src.OKOPF                         ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(OKATO                         , src.OKATO                         ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(REG_REGION                    , src.REG_REGION                    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SUM_CONTR_FOR_CLIENT          , src.SUM_CONTR_FOR_CLIENT          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CNT_CONTR_FOR_CLIENT          , src.CNT_CONTR_FOR_CLIENT          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PR_DEFOLT_CLIENT              , src.PR_DEFOLT_CLIENT              ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PR_PROBLEM_CLIENT             , src.PR_PROBLEM_CLIENT             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CLAIM_ID                      , src.CLAIM_ID                      ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(TARGET                        , src.TARGET                        ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CLAIM_USER_FIO                , src.CLAIM_USER_FIO                ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(FIO_BBR                       , src.FIO_BBR                       ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(FIO_DEB                       , src.FIO_DEB                       ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(FIO_DRB                       , src.FIO_DRB                       ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(FIO_DECISION_CLAIM            , src.FIO_DECISION_CLAIM            ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ID_CONTR                      , src.ID_CONTR                      ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(TRANSH_GID                    , src.TRANSH_GID                    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CONTRACT_NO                   , src.CONTRACT_NO                   ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(TRANSH_NO                     , src.TRANSH_NO                     ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PR_TRANSH                     , src.PR_TRANSH                     ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SOURCE_ID_DOG                 , src.SOURCE_ID_DOG                 ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CODE                          , src.CODE                          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PRINCIPAL                     , src.PRINCIPAL                     ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PRINCIPAL_RUR                 , src.PRINCIPAL_RUR                 ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(calc_sum_credit               , src.calc_sum_credit               ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SUM_FIRST_TURN                , src.SUM_FIRST_TURN                ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(DATE_FIRST_TURN               , src.DATE_FIRST_TURN               ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(LIFE_TERM_CONTR               , src.LIFE_TERM_CONTR               ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(VALID_CONTR                   , src.VALID_CONTR                   ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(hier_product_name_f           , src.hier_product_name_f           ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(business_name_f               , src.business_name_f               ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(product_group_name_f          , src.product_group_name_f          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(product_name_f                , src.product_name_f                ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(p_id                          , src.p_id                          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(GROUP_CONTRACT_TYPE           , src.GROUP_CONTRACT_TYPE           ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CONTRACT_TYPE                 , src.CONTRACT_TYPE                 ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(LOAN_TYPE                     , src.LOAN_TYPE                     ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(LOAN_SOURCE_NAME              , src.LOAN_SOURCE_NAME              ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(LOAN_OBJECT_NAME              , src.LOAN_OBJECT_NAME              ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(OPEN_DATE                     , src.OPEN_DATE                     ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(OPEN_DATE_TRANSH              , src.OPEN_DATE_TRANSH              ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CLOSE_DATE                    , src.CLOSE_DATE                    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CLOSE_FACT_DATE               , src.CLOSE_FACT_DATE               ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(MAIN_PAYMENT                  , src.MAIN_PAYMENT                  ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PRC_PAYMENT                   , src.PRC_PAYMENT                   ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(TYPE_PAYMENT                  , src.TYPE_PAYMENT                  ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(INTEREST_RATE_OPEN_DATE       , src.INTEREST_RATE_OPEN_DATE       ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(INTEREST_RATE                 , src.INTEREST_RATE                 ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(RATE_FIRST_DAY                , src.RATE_FIRST_DAY                ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SUM_KOMISS_MONTH              , src.SUM_KOMISS_MONTH              ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(EFFECTIVE_RATE                , src.EFFECTIVE_RATE                ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PR_RESTRUCT                   , src.PR_RESTRUCT                   ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(RESTRUCT_CODE                 , src.RESTRUCT_CODE                 ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(DATE_RESTRUCT                 , src.DATE_RESTRUCT                 ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(TYPE_RESTRUCT                 , src.TYPE_RESTRUCT                 ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(STATUS                        , src.STATUS                        ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(STATE                         , src.STATE                         ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CREATED_BY_EMPLOYEE_DOG       , src.CREATED_BY_EMPLOYEE_DOG       ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(DEPARTMENT_CODE_DOG_OPEN      , src.DEPARTMENT_CODE_DOG_OPEN      ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(DEPARTMENT_NAME_DOG_OPEN      , src.DEPARTMENT_NAME_DOG_OPEN      ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(DEPARTMENT_CODE_DOG_ISSUE     , src.DEPARTMENT_CODE_DOG_ISSUE     ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(DEPARTMENT_NAME_DOG_ISSUE     , src.DEPARTMENT_NAME_DOG_ISSUE     ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(BRANCH_CODE_DOG_OPEN          , src.BRANCH_CODE_DOG_OPEN          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(BRANCH_NAME_DOG_OPEN          , src.BRANCH_NAME_DOG_OPEN          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(BRANCH_CODE_DOG_ISSUE         , src.BRANCH_CODE_DOG_ISSUE         ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(BRANCH_NAME_DOG_ISSUE         , src.BRANCH_NAME_DOG_ISSUE         ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SERV_DOG_CITY                 , src.SERV_DOG_CITY                 ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SERV_DOG_REGION               , src.SERV_DOG_REGION               ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ADV_ACCOUNT                   , src.ADV_ACCOUNT                   ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ADV_ACCOUNT_TRANSH            , src.ADV_ACCOUNT_TRANSH            ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(AMOUNT                        , src.AMOUNT                        ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(AMOUNT_EQV                    , src.AMOUNT_EQV                    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(OVERDUE_PRINCIPAL             , src.OVERDUE_PRINCIPAL             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(OVERDUE_PRINCIPAL_EQV         , src.OVERDUE_PRINCIPAL_EQV         ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SUM_DOLG                      , src.SUM_DOLG                      ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SUM_DOLG_RUR                  , src.SUM_DOLG_RUR                  ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PROBLEM_DEBT                  , src.PROBLEM_DEBT                  ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PROBLEM_DEBT_30               , src.PROBLEM_DEBT_30               ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(DEFAULTED_DEBT                , src.DEFAULTED_DEBT                ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(UNUSED_CREDIT_LIMIT           , src.UNUSED_CREDIT_LIMIT           ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(UNUSED_CREDIT_LIMIT_EQV       , src.UNUSED_CREDIT_LIMIT_EQV       ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PRINCIPAL_RES                 , src.PRINCIPAL_RES                 ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(UNUSED_CREDIT_LIMIT_RES       , src.UNUSED_CREDIT_LIMIT_RES       ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(INTEREST_RES                  , src.INTEREST_RES                  ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(FEE_RES                       , src.FEE_RES                       ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(INTEREST                      , src.INTEREST                      ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(INTEREST_EQV                  , src.INTEREST_EQV                  ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(OVERDUE_INTEREST              , src.OVERDUE_INTEREST              ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(OVERDUE_INTEREST_EQV          , src.OVERDUE_INTEREST_EQV          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PRC_DEBT_VNB_AMOUNT           , src.PRC_DEBT_VNB_AMOUNT           ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PRC_MAIN_VNB_AMOUNT           , src.PRC_MAIN_VNB_AMOUNT           ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(OFF_DATE_VNB                  , src.OFF_DATE_VNB                  ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(OFF_MAIN_DEBT_VNB             , src.OFF_MAIN_DEBT_VNB             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(OFF_PRC_VNB                   , src.OFF_PRC_VNB                   ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(OFF_OTHER_PAYS_VNB            , src.OFF_OTHER_PAYS_VNB            ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_SUM_91802             , src.ACCOUNT_SUM_91802             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_SUM_91704             , src.ACCOUNT_SUM_91704             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_SUM_91604             , src.ACCOUNT_SUM_91604             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_SUM_91803             , src.ACCOUNT_SUM_91803             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(DELINQ_DATE_FIFO              , src.DELINQ_DATE_FIFO              ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CNT_DELINQ_DATE_FIFO          , src.CNT_DELINQ_DATE_FIFO          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(DELINQ_DATE_LIFO              , src.DELINQ_DATE_LIFO              ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CNT_DELINQ_DATE_LIFO          , src.CNT_DELINQ_DATE_LIFO          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(MAX_FIFO_FOR_CLIENT           , src.MAX_FIFO_FOR_CLIENT           ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CODE_POS                      , src.CODE_POS                      ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(REZ_PERCENT                   , src.REZ_PERCENT                   ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CALC_PRC_RESERVE              , src.CALC_PRC_RESERVE              ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(LOAN_QUALITY_COD              , src.LOAN_QUALITY_COD              ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(FIN_STATE                     , src.FIN_STATE                     ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(LOAN_STATE                    , src.LOAN_STATE                    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(FIRST_FIN_STATE               , src.FIRST_FIN_STATE               ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(FIRST_LOAN_QUALITY_COD        , src.FIRST_LOAN_QUALITY_COD        ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(FIRST_LOAN_STATE              , src.FIRST_LOAN_STATE              ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CNT_OVERDUE_CLIENT            , src.CNT_OVERDUE_CLIENT            ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(MAX_CNT_DAY_OVERDUE_CLIENT    , src.MAX_CNT_DAY_OVERDUE_CLIENT    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(MAX_SUM_OVERDUE_CLIENT        , src.MAX_SUM_OVERDUE_CLIENT        ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_SUM_COLLATERAL        , src.ACCOUNT_SUM_COLLATERAL        ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_SUM_91311             , src.ACCOUNT_SUM_91311             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_NUM_91311             , src.ACCOUNT_NUM_91311             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_NAME_91311            , src.ACCOUNT_NAME_91311            ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_SUM_91312             , src.ACCOUNT_SUM_91312             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_NUM_91312             , src.ACCOUNT_NUM_91312             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_NAME_91312            , src.ACCOUNT_NAME_91312            ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_SUM_91313             , src.ACCOUNT_SUM_91313             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_NUM_91313             , src.ACCOUNT_NUM_91313             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_NAME_91313            , src.ACCOUNT_NAME_91313            ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_SUM_91314             , src.ACCOUNT_SUM_91314             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_NUM_91314             , src.ACCOUNT_NUM_91314             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_NAME_91314            , src.ACCOUNT_NAME_91314            ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_SUM_91414             , src.ACCOUNT_SUM_91414             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_NUM_91414             , src.ACCOUNT_NUM_91414             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(ACCOUNT_NAME_91414            , src.ACCOUNT_NAME_91414            ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PROVIS_PERCENT                , src.PROVIS_PERCENT                ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PROVIS_PERCENT_CLIENT         , src.PROVIS_PERCENT_CLIENT         ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PR_SOURCE_REFINANS            , src.PR_SOURCE_REFINANS            ) = 0 OR
          /*dm_skb.pkg_etl_signs.isEqual(PARENT_DOG_ID_REFINANS        , src.PARENT_DOG_ID_REFINANS        ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(DATE_REFINANS                 , src.DATE_REFINANS                 ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SUM_MAIN_REFINANS             , src.SUM_MAIN_REFINANS             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SUM_DEBT_REFINANS             , src.SUM_DEBT_REFINANS             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(FIFO_DOG_REFINANS             , src.FIFO_DOG_REFINANS             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(FIFO_CLIENT_REFINANS          , src.FIFO_CLIENT_REFINANS          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SUM_RES_REFINANS              , src.SUM_RES_REFINANS              ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(FIRST_ID_DOG_REFINANS         , src.FIRST_ID_DOG_REFINANS         ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(DATE_TURN_REFINANS_FIRST      , src.DATE_TURN_REFINANS_FIRST      ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SUM_TURN_REFINANS_FIRST       , src.SUM_TURN_REFINANS_FIRST       ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(LAST_ID_DOG_REFINANS          , src.LAST_ID_DOG_REFINANS          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SUM_TURN_REFINANS_LAST        , src.SUM_TURN_REFINANS_LAST        ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(DATE_TURN_REFINANS_LAST       , src.DATE_TURN_REFINANS_LAST       ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(DOLG_LAST_DOG_REFINANS        , src.DOLG_LAST_DOG_REFINANS        ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(FIFO_LAST_DOG_REFINANS        , src.FIFO_LAST_DOG_REFINANS        ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PROBLEM_DEBT_REFINANS         , src.PROBLEM_DEBT_REFINANS         ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(RECOVE_RES_MAIN_REFINANS      , src.RECOVE_RES_MAIN_REFINANS      ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(RECOVE_RES_PERCENT_REFINANS   , src.RECOVE_RES_PERCENT_REFINANS   ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(RECOVE_RES_USL_REFINANS       , src.RECOVE_RES_USL_REFINANS       ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SUM_MAIN_RUR_REFINANS         , src.SUM_MAIN_RUR_REFINANS         ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SUM_DEBT_OD_REFINANS          , src.SUM_DEBT_OD_REFINANS          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SUM_MAIN_PRC_REFINANS         , src.SUM_MAIN_PRC_REFINANS         ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SUM_DEBT_PRC_REFINANS         , src.SUM_DEBT_PRC_REFINANS         ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(REFIN_KOMISS                  , src.REFIN_KOMISS                  ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(REFIN_DEBT_KOMISS             , src.REFIN_DEBT_KOMISS             ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(REFIN_PENY                    , src.REFIN_PENY                    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(REFIN_DEBT_VNB                , src.REFIN_DEBT_VNB                ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(REFIN_PRC_VNB                 , src.REFIN_PRC_VNB                 ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(REFIN_OTHER_VNB               , src.REFIN_OTHER_VNB               ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(DATE_PRICE                    , src.DATE_PRICE                    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SELL_PRICE                    , src.SELL_PRICE                    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CALC_PRC_RESERVE_ON_SALE      , src.CALC_PRC_RESERVE_ON_SALE      ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SUM_MAIN_SOLD_DEBT            , src.SUM_MAIN_SOLD_DEBT            ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SUM_PRC_SOLD_BALANCE          , src.SUM_PRC_SOLD_BALANCE          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SUM_OTHER_RECEIV_SOLD         , src.SUM_OTHER_RECEIV_SOLD         ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(X_SKB_CLIENT_STATUS           , src.X_SKB_CLIENT_STATUS           ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(IN_WORK_UNITS                 , src.IN_WORK_UNITS                 ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(STAGE_NAME                    , src.STAGE_NAME                    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SKB_STAGE_ASGN_FLG            , src.SKB_STAGE_ASGN_FLG            ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(STAGE_REASON                  , src.STAGE_REASON                  ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(DAY_STAGE                     , src.DAY_STAGE                     ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PREV_STAGE_DATE               , src.PREV_STAGE_DATE               ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(EMP_NAME                      , src.EMP_NAME                      ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(SKB_EMP_DATE                  , src.SKB_EMP_DATE                  ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(KA_NAME                       , src.KA_NAME                       ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(REG_NUMBER                    , src.REG_NUMBER                    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(KA_SEND_DATE                  , src.KA_SEND_DATE                  ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(KA_PLAN_END_DATE              , src.KA_PLAN_END_DATE              ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(KA_COUNT                      , src.KA_COUNT                      ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(REG_COUNT                     , src.REG_COUNT                     ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(KA_DEADLINE                   , src.KA_DEADLINE                   ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(REASON                        , src.REASON                        ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(COLLECTION                    , src.COLLECTION                    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(X_SKB_HAND_LAST_CALL          , src.X_SKB_HAND_LAST_CALL          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PR_BANKROT                    , src.PR_BANKROT                    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(AMOUNT_DEBT_PAY_EQV           , src.AMOUNT_DEBT_PAY_EQV           ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(AMOUNT_DEBT_PAY_EQV_REFIN     , src.AMOUNT_DEBT_PAY_EQV_REFIN     ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PRINCIPAL_RES_RESTORE         , src.PRINCIPAL_RES_RESTORE         ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(INTEREST_RES_RESTORE          , src.INTEREST_RES_RESTORE          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(INTEREST_RES_RESTORE_USL      , src.INTEREST_RES_RESTORE_USL      ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PAYMENT_UN_DEBT_OSN_DOLG_PREV , src.PAYMENT_UN_DEBT_OSN_DOLG_PREV ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PAYMENT_DEBT_OSN_DOLG_PREV    , src.PAYMENT_DEBT_OSN_DOLG_PREV    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PAYMENT_UN_DEBT_PRCNT_PREV    , src.PAYMENT_UN_DEBT_PRCNT_PREV    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PAYMENT_DEBT_PRCNT_PREV       , src.PAYMENT_DEBT_PRCNT_PREV       ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PAYMENT_UN_DEBT_COMM_PREV     , src.PAYMENT_UN_DEBT_COMM_PREV     ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PAYMENT_DEBT_COMM_PREV        , src.PAYMENT_DEBT_COMM_PREV        ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PAYMENT_PENALTY_PREV          , src.PAYMENT_PENALTY_PREV          ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PAYMENT_DEBT_ODVNB_PREV       , src.PAYMENT_DEBT_ODVNB_PREV       ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PAYMENT_DEBT_PRCVNB_PREV      , src.PAYMENT_DEBT_PRCVNB_PREV      ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PAYMENT_DEBT_OTHVNB_PREV      , src.PAYMENT_DEBT_OTHVNB_PREV      ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(PAY_GP                        , src.PAY_GP                        ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(RECOVERY_COSTS_CLIENT         , src.RECOVERY_COSTS_CLIENT         ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(RECOVERY_COURT                , src.RECOVERY_COURT                ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CONTRACT_GID                  , src.CONTRACT_GID                  ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(CLIENT_SID                    , src.CLIENT_SID                    ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(DOG_SYSTEM_NAME               , src.DOG_SYSTEM_NAME               ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(DOG_BANK_NAME                 , src.DOG_BANK_NAME                 ) = 0 OR
          dm_skb.pkg_etl_signs.isEqual(code_naim                     , src.code_naim                     ) = 0 OR 
          dm_skb.pkg_etl_signs.isEqual(fee_eqv                       , src.fee_eqv                       ) = 0;
    */
    
    
    vEndTime := SYSDATE;
    vMes := 'SUCCESSFULLY :: "'||to_char(inBegDate+idx,'DD.MM.YYYY')||'" '||SQL%ROWCOUNT||' rows merged into table "dm_skb.tb_ciw_closed" in '||dm_skb.get_ti_as_hms(vEndTime - vTIBegin);
    dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_creds_closed',vMes);

    COMMIT;
  END LOOP;
  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "dm_skb.pkg_etl_ctr_signs.load_creds_closed" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' successfully';
  dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_creds_closed',vMes);
EXCEPTION
  WHEN OTHERS THEN
    vEndTime := SYSDATE;
    vMes := 'ERROR :: Table "dm_clant.ptb_creds_in_work" aggregation failed :: '||SQLERRM;
    dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_creds_new',vMes);
    vMes := 'FINISH :: Procedure "dm_skb.pkg_etl_ctr_signs.load_creds_new" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' with errors';
    dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_creds_new',vMes);
END load_creds_closed;

PROCEDURE mass_sql_load(inBegDate IN DATE,inEndDate IN DATE,inSign IN VARCHAR2,inForceTruncPart IN BOOLEAN DEFAULT FALSE)
  IS
    vMes VARCHAR2(2000);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vTIBegin DATE;
    vHistFlg NUMBER;
    --vUnit VARCHAR2(256);
    vSPCode VARCHAR2(30);
    vBuff VARCHAR2(32700);
    vSQL CLOB;
    vCou INTEGER := 0;
BEGIN
  vMes := 'START :: Procedure "dm_skb.pkg_etl_ctr_signs.mass_sql_load" started.';
  dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.mass_sql_load',vMes);

  BEGIN
    SELECT /*COALESCE(mass_unit,daily_unit),*/hist_flg,sp_code INTO /*vUnit,*/vHistFlg,vSPCode
      FROM dm_skb.tb_signs_pool WHERE sign_name = UPPER(inSign);
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Показатель "'||UPPER(inSign)||'" не найден в таблице dm_skb.tb_signs_pool');
  END;    
  
  -- Подготовка субпартиций 
  IF vHistFlg = 0 THEN
    vTIBegin := SYSDATE;
    vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - подготовка субпартиций --------';
    dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.mass_sql_load',vMes);
    
    IF inForceTruncPart THEN
      vBuff := 'ALTER TABLE dm_skb.ptb_ctr_signs TRUNCATE PARTITION '||UPPER(inSign);
      dm_skb.my_execute(vBuff,vMes);
      IF vMes = 'Ok' THEN
        vMes := 'SUCCESSFULLY :: Table "dm_skb.ptb_ctr_signs" altered. Partition '||UPPER(inSign)||' truncated';
        dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.mass_sql_load',vMes);
      ELSE
        IF vMes LIKE '%ORA%02149%' THEN
          dbms_lob.createtemporary(vSQL,FALSE);
          vBuff := 'BEGIN'||Chr(10);
          dbms_lob.writeappend(vSQL,LENGTH(vBuff),vBuff);
          FOR idx IN (
            SELECT CASE WHEN s.table_name IS NULL THEN
                   '  EXECUTE IMMEDIATE ''ALTER TABLE dm_skb.ptb_ctr_signs MODIFY PARTITION '||inSign||' ADD SUBPARTITION '||vSPCode||'_'||to_char(dt,'YYYYMMDD')||' VALUES (to_date('''''||to_char(dt,'DD.MM.YYYY')||''''',''''DD.MM.YYYY''''))'';'
                   ELSE '  EXECUTE IMMEDIATE ''ALTER TABLE dm_skb.ptb_ctr_signs TRUNCATE SUBPARTITION '||vSPCode||'_'||to_char(dt,'YYYYMMDD')||''';'
                 END cmd
              FROM (
                SELECT inEndDate - ROWNUM + 1 AS dt FROM dual CONNECT BY ROWNUM <= inEndDate - inBegDate + 1
              ) t
                LEFT JOIN dba_tab_subpartitions s
                  ON s.table_owner = 'DM_SKB'
                     AND s.table_name = 'PTB_CTR_SIGNS'
                     AND s.partition_name = UPPER(inSign)
                     AND s.subpartition_name = vSPCode||'_'||to_char(dt,'YYYYMMDD')
            ORDER BY dt
          ) LOOP
            dbms_lob.writeappend(vSQL,LENGTH(idx.cmd)+1,idx.cmd||CHR(10));
            vCou := vCou + 1;
          END LOOP;
          vBuff := 'END;';
          dbms_lob.writeappend(vSQL,LENGTH(vBuff),vBuff);
          EXECUTE IMMEDIATE vSQL;
          dbms_lob.freetemporary(vSQL);
          vMes := 'SUCCESSFULLY :: Table "dm_skb.ptb_ctr_signs" altered. Partition '||UPPER(inSign)||' - '||vCou||' subpartitions proccessed';
          dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.mass_sql_load',vMes);
        ELSE
          vMes := 'ERROR :: '||vMes;
          dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.mass_sql_load',vMes);  
        END IF;
      END IF;
    ELSE
      dbms_lob.createtemporary(vSQL,FALSE);
      vBuff := 'BEGIN'||Chr(10);
      dbms_lob.writeappend(vSQL,LENGTH(vBuff),vBuff);
      FOR idx IN (
        SELECT CASE WHEN s.table_name IS NULL THEN
               '  EXECUTE IMMEDIATE ''ALTER TABLE dm_skb.ptb_ctr_signs MODIFY PARTITION '||inSign||' ADD SUBPARTITION '||vSPCode||'_'||to_char(dt,'YYYYMMDD')||' VALUES (to_date('''''||to_char(dt,'DD.MM.YYYY')||''''',''''DD.MM.YYYY''''))'';'
               ELSE '  EXECUTE IMMEDIATE ''ALTER TABLE dm_skb.ptb_ctr_signs TRUNCATE SUBPARTITION '||vSPCode||'_'||to_char(dt,'YYYYMMDD')||''';'
             END cmd
          FROM (
            SELECT inEndDate - ROWNUM + 1 AS dt FROM dual CONNECT BY ROWNUM <= inEndDate - inBegDate + 1
          ) t
            LEFT JOIN dba_tab_subpartitions s
              ON s.table_owner = 'DM_SKB'
                 AND s.table_name = 'PTB_CTR_SIGNS'
                 AND s.partition_name = UPPER(inSign)
                 AND s.subpartition_name = vSPCode||'_'||to_char(dt,'YYYYMMDD')
        ORDER BY dt
      ) LOOP
        dbms_lob.writeappend(vSQL,LENGTH(idx.cmd)+1,idx.cmd||CHR(10));
        vCou := vCou + 1;
      END LOOP;
      vBuff := 'END;';
      dbms_lob.writeappend(vSQL,LENGTH(vBuff),vBuff);
      EXECUTE IMMEDIATE vSQL;
      dbms_lob.freetemporary(vSQL);
      vMes := 'SUCCESSFULLY :: Table "dm_skb.ptb_ctr_signs" altered. Partition '||UPPER(inSign)||' - '||vCou||' subpartitions proccessed';
      dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.mass_sql_load',vMes);
    END IF;
      
    
    vEndTime := SYSDATE;
    vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - окончание подготовки субпартиций. Время выполнения - '||dm_skb.get_ti_as_hms(vEndTime - vTIBegin);
    dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.mass_sql_load',vMes);
  END IF;
  
  -- Загрузка данных
  begin
  dbms_lob.createtemporary(vSQL,FALSE);
  vBuff := 'BEGIN'||Chr(10);
  dbms_lob.writeappend(vSQL,LENGTH(vBuff),vBuff);
  if vHistFlg = 0 THEN -- для "FCT" показателей 
      vBuff := 'INSERT INTO DM_SKB.PTB_CTR_SIGNS'||Chr(10);
  else -- для исторических показателей 
      vBuff := 'INSERT INTO DM_SKB.TB_CTR_SIGNS'||Chr(10);
  end if;
  dbms_lob.writeappend(vSQL,LENGTH(vBuff),vBuff);
  
  for idx in (
    SELECT mass_sql cmd FROM dm_skb.tb_signs_pool WHERE sign_name = UPPER(inSign)
  )
  loop
    dbms_lob.writeappend(vSQL,LENGTH(idx.cmd)+1,idx.cmd||';'||CHR(10));
  end loop;
  vBuff := 'COMMIT;'||Chr(10)||'END;';
  dbms_lob.writeappend(vSQL,LENGTH(vBuff),vBuff);

  EXECUTE IMMEDIATE vSQL using in inEndDate;
  dbms_lob.freetemporary(vSQL);
  vMes := 'SUCCESSFULLY :: mass_sql load proccessed';
  dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.mass_sql_load',vMes);

  end; -- Загрузка данных
  
  
  -- Сжатие субпартиций для "FCT" и удаление для "FCT - HIST" показателей
  IF vHistFlg = 0 THEN -- только для "FCT" показателей
    vTIBegin := SYSDATE;
    vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - сжатие/удаление субпартиций --------';
    dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.mass_sql_load',vMes);
    
    --dm_skb.pkg_etl_ctr_signs.prepare_subpartitions_fct(inBegDate,inEndDate,UPPER(inSign),TRUE);
    dm_skb.mass_load_parallel_by_month(inBegDate,inEndDate,'dm_skb.pkg_etl_ctr_signs.prepare_subpartitions_fct','VARCHAR2 '||UPPER(inSign)||'::BOOLEAN TRUE');
    /*FOR idx IN 1..31 LOOP
      dm_skb.mass_load_parallel_by_year(inBegDate,inEndDate,'dm_skb.pkg_etl_ctr_signs.prepare_subpartitions_fct'
        ,'VARCHAR2 '||UPPER(inSign)||'::BOOLEAN TRUE',FALSE,to_char(idx,'00'),TRUE);
    END LOOP;*/

  
    vEndTime := SYSDATE;
    vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - окончание сжатия/удаления субпартиций. Время выполнения - '||dm_skb.get_ti_as_hms(vEndTime - vTIBegin);
    dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.mass_sql_load',vMes);
  END IF;
  
  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "dm_skb.pkg_etl_ctr_signs.mass_sql_load" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' successfully';
  dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.mass_sql_load',vMes);
EXCEPTION WHEN OTHERS THEN
  vEndTime := SYSDATE;
  vMes := 'ERROR :: Procedure "dm_skb.pkg_etl_ctr_signs.mass_sql_load" :: '||SQLERRM||Chr(10)||vBuff;
  dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.mass_sql_load',vMes);
  vMes := 'FINISH :: Procedure "dm_skb.pkg_etl_ctr_signs.mass_sql_load" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' with errors.';
  dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.mass_sql_load',vMes);
END mass_sql_load;

-- Процедура остановки jobs для task
PROCEDURE stop_task_jobs(task_name IN VARCHAR2)
  IS
    vMes VARCHAR2(2000);
BEGIN
  for i in 1..100 loop
  begin
  dbms_scheduler.stop_job('DM_SKB.'||task_name||'_'||i);
  vMes := 'SUCCESSFULLY :: Procedure "dm_skb.pkg_etl_ctr_signs.stop_task_jobs" stopping tasks job '||'DM_SKB.'||task_name||'_'||i;
  dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.stop_task_jobs',vMes);
  exception when others then 
    vMes := 'ERROR :: Procedure "dm_skb.pkg_etl_ctr_signs.stop_task_jobs" :: '||SQLERRM||' while stopping tasks job '||'DM_SKB.'||task_name||'_'||i;
    dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.stop_task_jobs',vMes);
  end;
  end loop;  
END stop_task_jobs;

PROCEDURE load_scoring(inBegDate DATE,inEndDate DATE)
  IS
    vDays INTEGER;
    vMes VARCHAR2(2000);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vTIBegin DATE;
BEGIN
  EXECUTE IMMEDIATE 'ALTER SESSION SET nls_numeric_characters = '', ''';
   
  vDays := inEndDate - inBegDate;
  vMes := 'START :: Procedure "dm_skb.pkg_etl_ctr_signs.load_scoring" started.';
  dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_scoring',vMes);

  FOR idx IN 0..vDays
  LOOP
    vTIBegin := SYSDATE;
    DELETE FROM tddw.creds_for_scoring_tddw WHERE as_of_date = inBegDate + idx;
    vEndTime := SYSDATE;
    vMes := 'SUCCESSFULLY :: "'||to_char(inBegDate+idx,'DD.MM.YYYY')||'" - '||SQL%ROWCOUNT||' rows deleted from table "tddw.creds_for_scoring_tddw" in '||dm_skb.get_ti_as_hms(vEndTime - vTIBegin);
    dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_scoring',vMes);
    COMMIT;
     
    
    vTIBegin := SYSDATE;
    INSERT INTO tddw.creds_for_scoring_tddw (as_of_date,
                                             client_type_flg,
                                             client_system_name,
                                             client_gid,
                                             client_birth_date,
                                             contract_gid,
                                             dog_system_name,
                                             dog_bank_name,
                                             group_contract_type,
                                             contract_type,
                                             open_date,
                                             date_first_turn,
                                             close_date,
                                             close_fact_date,
                                             cnt_delinq_date_fifo,
                                             cnt_delinq_date_lifo,
                                             loan_quality_cod,
                                             life_term_contr,
                                             interest_rate,
                                             principal_rur,
                                             sum_first_turn,
                                             main_payment,
                                             prc_tech,
                                             prc_peny,
                                             sum_peny,
                                             sum_komiss_ones,
                                             sum_komiss_month,
                                             cnt_debt_30_l,
                                             cnt_debt_31_60,
                                             cnt_debt_61_90,
                                             cnt_debt_90_m,
                                             prc_res,
                                             principal_res,
                                             deb_amount,
                                             sum_deb_amount,
                                             amount_to_debt,
                                             overdue_principal,
                                             interest_eqv,
                                             overdue_interest_eqv,
                                             all_sum_debt_on_dog,
                                             all_sum_debt_all_dog,
                                             cnt_contr_for_client,
                                             max_fifo_for_client,
                                             cnt_overdue_client,
                                             max_cnt_day_overdue_client,
                                             max_sum_overdue_client,
                                             sum_pay_od_main,
                                             sum_all_pay_od_main,
                                             sum_pay_od_debt,
                                             sum_all_pay_od_debt,
                                             sum_pay_od_main_debt,
                                             sum_pay_prc_main,
                                             sum_all_pay_prc_main,
                                             sum_pay_prc_debt,
                                             sum_all_pay_prc_debt,
                                             sum_pay_prc_main_debt,
                                             sum_all_pay_prc_main_debt,
                                             sum_pay_comiss,
                                             sum_all_pay_comiss,
                                             sum_pay_peny,
                                             sum_all_pay_peny,
                                             cnt_pays_od_on_debt,
                                             cnt_all_pays_od_on_debt,
                                             cnt_pays_prc_on_debt,
                                             cnt_all_pays_prc_on_debt,
                                             sum_all_pay_od_debt_lifo,
                                             sum_all_pay_prc_debt_lifo,
                                             area_department,
                                             region_department,
                                             fed_okrug,
                                             code_result_connect,
                                             result_connect,
                                             count_val_code_dog,
                                             count_val_code_client,
                                             code_result_phone,
                                             result_phone,
                                             cnt_code_result_phone_on_dog,
                                             cnt_code_result_phone_on_cl,
                                             id_dog_siebel,
                                             source_system_id,
                                             contract_no,
                                             transh_no)
    SELECT as_of_date,
           client_type_flg,
           client_system_name,
           client_gid,
           client_birth_date,
           contract_gid,
           dog_system_name,
           dog_bank_name,
           group_contract_type,
           contract_type,
           open_date,
           date_first_turn,
           close_date,
           close_fact_date,
           cnt_delinq_date_fifo,
           cnt_delinq_date_lifo,
           loan_quality_cod,
           life_term_contr,
           interest_rate,
           principal_rur,
           sum_first_turn,
           main_payment,
           prc_tech,
           prc_peny,
           sum_peny,
           sum_komiss_ones,
           sum_komiss_month,
           cnt_debt_30_l,
           cnt_debt_31_60,
           cnt_debt_61_90,
           cnt_debt_90_m,
           prc_res,
           principal_res,
           deb_amount,
           sum_deb_amount,
           amount_to_debt,
           overdue_principal,
           interest_eqv,
           overdue_interest_eqv,
           all_sum_debt_on_dog,
           all_sum_debt_all_dog,
           cnt_contr_for_client,
           max_fifo_for_client,
           cnt_overdue_client,
           max_cnt_day_overdue_client,
           max_sum_overdue_client,
           sum_pay_od_main,
           sum_all_pay_od_main,
           sum_pay_od_debt,
           sum_all_pay_od_debt,
           sum_pay_od_main_debt,
           sum_pay_prc_main,
           sum_all_pay_prc_main,
           sum_pay_prc_debt,
           sum_all_pay_prc_debt,
           sum_pay_prc_main_debt,
           sum_all_pay_prc_main_debt,
           sum_pay_comiss,
           sum_all_pay_comiss,
           sum_pay_peny,
           sum_all_pay_peny,
           cnt_pays_od_on_debt,
           cnt_all_pays_od_on_debt,
           cnt_pays_prc_on_debt,
           cnt_all_pays_prc_on_debt,
           sum_all_pay_od_debt_lifo,
           sum_all_pay_prc_debt_lifo,
           area_department,
           region_department,
           fed_okrug,
           code_result_connect,
           result_connect,
           count_val_code_dog,
           count_val_code_client,
           code_result_phone,
           result_phone,
           cnt_code_result_phone_on_dog,
           cnt_code_result_phone_on_cl,
           id_dog_siebel,
           source_system_id,
           contract_no,
           transh_no
      FROM tddw.vw_creds_for_scoring_tddw
      WHERE as_of_date = inBegDate+idx;

    vEndTime := SYSDATE;
    vMes := 'SUCCESSFULLY :: "'||to_char(inBegDate+idx,'DD.MM.YYYY')||'" - '||SQL%ROWCOUNT||' rows inserted into table "tddw.creds_for_scoring_tddw" in '||dm_skb.get_ti_as_hms(vEndTime - vTIBegin);
    dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_scoring',vMes);
    COMMIT;
  END LOOP;
  
  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "dm_skb.pkg_etl_ctr_signs.load_scoring" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' successfully';
  dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_scoring',vMes);
EXCEPTION WHEN OTHERS THEN
  vEndTime := SYSDATE;
  vMes := 'ERROR :: Procedure "dm_skb.pkg_etl_ctr_signs.load_scoring" :: '||SQLERRM;
  dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_scoring',vMes);
  vMes := 'FINISH :: Procedure "dm_skb.pkg_etl_ctr_signs.load_scoring" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' with errors.';
  dm_skb.pr_log_write('dm_skb.pkg_etl_ctr_signs.load_scoring',vMes);
END load_scoring;

END pkg_etl_ctr_signs;
/

prompt
prompt Creating package body PKG_ETL_SIGNS
prompt ===================================
prompt
CREATE OR REPLACE PACKAGE BODY DM_SKB.pkg_etl_signs
  IS
FUNCTION GetLabels(inOSUser VARCHAR2) RETURN TTabLabels PIPELINED
  IS
    Rec TRecLabels;
BEGIN
  FOR idx IN (
    WITH
      rol AS (
        SELECT r.id
          FROM tb_role_registry r
        CONNECT BY PRIOR r.id = r.parent_id
        START WITH r.id IN (SELECT ur.role_id
                              FROM tb_urole_registry ur
                                   INNER JOIN tb_labrole_registry lr ON lr.role_id = ur.role_id
                                   INNER JOIN tb_user_registry u ON u.id = ur.user_id AND LOWER(u.user_name) = LOWER(inOSUser)
                           )
      )
    SELECT DISTINCT l.id,l.parent_id,l.caption,l.ord,l.form_id
      FROM tb_label_registry l
    CONNECT BY PRIOR l.id = l.parent_id
    START WITH l.id IN (SELECT lr.label_id FROM tb_labrole_registry lr
                          WHERE lr.label_id = l.id
                            AND lr.role_id IN (SELECT ID FROM rol))
  ) LOOP
    Rec.id := idx.id;
    Rec.parent_id := idx.parent_id;
    Rec.caption := idx.caption;
    Rec.ord := idx.ord;
    Rec.form_id := idx.form_id;
    PIPE ROW(Rec);
  END LOOP;
END;

FUNCTION GetReports(inOSUser VARCHAR2,inFormID NUMBER) RETURN TTabReports PIPELINED
  IS
    Rec TRecReports;
BEGIN
  FOR idx IN (
    WITH
      rol AS (
        SELECT r.id
          FROM tb_role_registry r
        CONNECT BY PRIOR r.id = r.parent_id
        START WITH r.id IN (SELECT ur.role_id
                              FROM tb_urole_registry ur
                                   INNER JOIN tb_user_registry u ON u.id = ur.user_id AND LOWER(u.user_name) = LOWER(inOSUser)
                           )
      )
    SELECT q.id,q.query_name,q.query_descr,q.ord
      FROM tb_query_registry q
           INNER JOIN tb_repform_registry rf
             ON rf.query_id = q.id
                AND rf.form_id = inFormID
      WHERE q.id IN (SELECT qr.query_id FROM tb_qrole_registry qr
                          WHERE qr.query_id = q.id
                            AND qr.role_id IN (SELECT ID FROM rol))
        AND q.is_report = 1
  ) LOOP
    Rec.id := idx.id;
    Rec.query_name := idx.query_name;
    Rec.query_descr := idx.query_descr;
    Rec.ord := idx.ord;
    PIPE ROW(Rec);
  END LOOP;
END;

PROCEDURE pr_log_write(inUnit IN VARCHAR2,inMessage IN VARCHAR2)
  IS
    vBuff VARCHAR2(32700);
    PRAGMA AUTONOMOUS_TRANSACTION;
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
   vBuff :=
   'BEGIN'||CHR(10)||
   'INSERT INTO '||lower(vOwner)||'.tb_signs_log (dat, unit, message) VALUES (SYSDATE,:1,:2);'||CHR(10)||
   'END;';
   EXECUTE IMMEDIATE vBuff USING IN inUnit, IN inMessage;
   COMMIT;
END pr_log_write;

PROCEDURE pr_stat_write(inSignName IN VARCHAR2,inAnltCode IN VARCHAR2,inSec NUMBER,inAction VARCHAR2)
  IS
    vBuff VARCHAR2(32700);
    PRAGMA AUTONOMOUS_TRANSACTION;
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
   vBuff :=
   'BEGIN'||CHR(10)||
   'INSERT INTO '||lower(vOwner)||'.tb_signs_calc_stat (sign_name,anlt_code,sec,action) VALUES (:1,:2,:3,:4);'||CHR(10)||
   'END;';
   EXECUTE IMMEDIATE vBuff USING IN inSignName,IN inAnltCode,IN inSec,IN inAction;
   COMMIT;
END pr_stat_write;

FUNCTION get_ti_as_hms (inInterval IN NUMBER /*интервал в днях*/) RETURN VARCHAR2
  IS
BEGIN
  RETURN LPAD(TO_CHAR(TRUNC(inInterval*24*60*60/3600)),3,' ')||'h '||LPAD(TO_CHAR(TRUNC(MOD(inInterval*24*60*60,3600)/60)),2,' ')||'m '||LPAD(TO_CHAR(ROUND(MOD(MOD(inInterval*24*60*60,3600),60),0)),2,' ')||'s';
END get_ti_as_hms;

FUNCTION parse_str(inStr VARCHAR2,inSeparator IN VARCHAR2) RETURN tabStr PIPELINED
  IS
    rec recStr;
    vExpr VARCHAR2(4000) := inSeparator||inStr||inSeparator;
    vPartCount INTEGER := (LENGTH(inStr) - LENGTH(REPLACE(inStr,inSeparator,'')))/LENGTH(inSeparator) + 1;
BEGIN
  FOR idx IN (
    SELECT LEVEL AS ord
          ,SUBSTR(
             SUBSTR(vExpr
                   ,INSTR(vExpr,inSeparator,1,LEVEL) + LENGTH(inSeparator)
                   ,LENGTH(vExpr))
                 ,1,INSTR(SUBSTR(vExpr
                   ,INSTR(vExpr,inSeparator,1,LEVEL) + LENGTH(inSeparator)
                   ,LENGTH(vExpr)),inSeparator,1,1) - 1) AS a
      FROM dual
    CONNECT BY LEVEL <= vPartCount
  ) LOOP
    rec.ord := idx.ord;
    rec.Str := idx.a;
    PIPE ROW(rec);
  END LOOP;
END parse_str;

FUNCTION isEqual(n1 IN NUMBER,n2 IN NUMBER) RETURN NUMBER
  IS
BEGIN
  IF n1 = n2 OR n1 IS NULL AND n2 IS NULL THEN RETURN 1; ELSE RETURN 0; END IF;
END isEqual;

FUNCTION isEqual(v1 IN VARCHAR2,v2 IN VARCHAR2) RETURN NUMBER
  IS
BEGIN
  IF v1 = v2 OR v1 IS NULL AND v2 IS NULL THEN RETURN 1; ELSE RETURN 0; END IF;
END isEqual;

FUNCTION isEqual(d1 IN DATE,d2 IN DATE) RETURN NUMBER
  IS
BEGIN
  IF d1 = d2 OR d1 IS NULL AND d2 IS NULL THEN RETURN 1; ELSE RETURN 0; END IF;
END isEqual;

FUNCTION isEqual(c1 IN CLOB,c2 IN CLOB) RETURN NUMBER
  IS
BEGIN
  IF dbms_lob.compare(c1,c2) = 0 THEN RETURN 1; ELSE RETURN 0; END IF;
END isEqual;

FUNCTION DBLinkReady(inDBLinkName VARCHAR2) RETURN BOOLEAN
  IS
    vRes NUMBER := 0;
BEGIN
  EXECUTE IMMEDIATE 'SELECT 1 FROM dual@'||inDBLinkName INTO vRes;
  RETURN TRUE;
EXCEPTION WHEN OTHERS THEN
  RETURN FALSE;
END DBLinkReady;

FUNCTION GetConditionResult(inCondition IN CLOB) RETURN NUMBER
  IS
    vResult NUMBER;
BEGIN
  IF inCondition IS NULL THEN
    RETURN 1;
  ELSE
    EXECUTE IMMEDIATE 'DECLARE vRes BOOLEAN; BEGIN vRes := '||inCondition||'; IF vRes THEN :1 := 1; ELSE :1 := 0; END IF; END;' USING OUT vResult;
    RETURN vResult;
  END IF;
END;

PROCEDURE mass_load_parallel_by_date_pe(inBeg IN DATE, inEnd IN DATE, inUnit IN VARCHAR2 DEFAULT NULL
  ,inParams IN VARCHAR2 DEFAULT NULL)
  IS
    vMes VARCHAR2(2000);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vPLev NUMBER;
    vTry NUMBER;
    vStatus NUMBER;
    vTask VARCHAR2(255) := dbms_parallel_execute.generate_task_name;
    vParams VARCHAR2(32700);
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
  BEGIN
    vMes := 'START :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.mass_load_parallel_by_date_pe" started.';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.mass_load_parallel_by_date_pe',vMes);

    -- Формирование строки доп. параметров
    IF inParams IS NOT NULL THEN
      FOR idx IN (
        SELECT SUBSTR(str,1,INSTR(str,' ',1,1)-1) AS param_type
              ,SUBSTR(str,INSTR(str,' ',1,1)+1) AS param_value
        FROM TABLE(parse_str(inParams,'::'))
      ) LOOP
        vParams := vParams||
          CASE idx.param_type
            WHEN 'VARCHAR2' THEN ''''''||idx.param_value||''''''
            WHEN 'DATE' THEN 'to_date('''''||idx.param_value||''''',''''DD.MM.YYYY'''')'
          ELSE idx.param_value END||',';
      END LOOP;
      vParams := SUBSTR(vParams,1,LENGTH(vParams) - 1)  ;
    END IF;
    --Вычисление количества потоков
    SELECT TRUNC(to_number(VALUE)/5*4) INTO vPLev FROM v$parameter WHERE NAME = 'job_queue_processes';

    -- Создание временной таблицы
    EXECUTE IMMEDIATE 'CREATE TABLE '||lower(vOwner)||'.tmp_'||vTask||' (id NUMBER,exec_sql VARCHAR2(2000))';
    FOR idx IN (SELECT rownum AS id
               ,'begin '||inUnit||'(to_date('''''||to_char(inBeg+rownum-1,'DD.MM.YYYY')||''''',''''DD.MM.YYYY''''),to_date('''''||to_char(inBeg+rownum-1,'DD.MM.YYYY')||''''',''''DD.MM.YYYY'''')'||NVL2(vParams,','||vParams,'')||'); end;' AS vSQL
      FROM dual CONNECT BY ROWNUM <= inEnd - inBeg + 1)
    LOOP
      EXECUTE IMMEDIATE
      --dbms_output.put_line(
      'INSERT INTO '||lower(vOwner)||'.tmp_'||vTask||' (id,exec_sql)
        VALUES ('||idx.id||','''||idx.vsql||''')'
      --)
      ;
      --dbms_output.put_line(idx.vSQL);
    END LOOP;


      --Наименование задачи
      DBMS_PARALLEL_EXECUTE.CREATE_TASK(task_name => vTask);

      --Раскладка по потокам
      DBMS_PARALLEL_EXECUTE.CREATE_CHUNKS_BY_SQL
        (task_name => vTask
        ,sql_stmt =>'SELECT id,id FROM '||lower(vOwner)||'.tmp_'||vTask||' ORDER BY 1'
        ,by_rowid => FALSE
        );
      --Запуск задачи на выполнение
      DBMS_PARALLEL_EXECUTE.RUN_TASK (task_name => vTask,
         sql_stmt => 'declare
                        vSQL VARCHAR2(4000);
                      begin
                         SELECT exec_sql INTO vSQL
                           FROM '||lower(vOwner)||'.tmp_'||vTask||'
                           WHERE id = :start_id AND id = :end_id
                         ;
                        execute immediate vSQL;
                        commit;
                      end;'
         ,language_flag => DBMS_SQL.NATIVE
         , parallel_level => vPLev );

      --Финишный контроль и удаление задачи
      vTry := 0;
      vStatus := DBMS_PARALLEL_EXECUTE.task_status(vTask);

      WHILE(vTry < 2 and vStatus != DBMS_PARALLEL_EXECUTE.FINISHED)
      LOOP
        vTry := vTry + 1;
        DBMS_PARALLEL_EXECUTE.resume_task(vTask);
        vStatus := DBMS_PARALLEL_EXECUTE.task_status(vTask);
      END LOOP;

      DBMS_PARALLEL_EXECUTE.drop_task(vTask);

      -- Удаление временной таблицы
      EXECUTE IMMEDIATE 'DROP TABLE '||lower(vOwner)||'.tmp_'||vTask;

    vEndTime := SYSDATE;
    vMes := 'FINISH :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.mass_load_parallel_by_date_pe" finished in '||get_ti_as_hms(vEndTime - vBegTime)||' successfully.';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.mass_load_parallel_by_date_pe',vMes);
  EXCEPTION WHEN OTHERS THEN
    DBMS_PARALLEL_EXECUTE.drop_task(vTask);
    vEndTime := SYSDATE;
    vMes := 'ERROR :: '||SQLERRM;
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.mass_load_parallel_by_date_pe',vMes);
    vMes := 'FINISH :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.mass_load_parallel_by_date_pe" finished in '||get_ti_as_hms(vEndTime - vBegTime)||' with errors.';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.mass_load_parallel_by_date_pe',vMes);
  END mass_load_parallel_by_date_pe;

PROCEDURE mass_load_parallel_by_month (inBegDate IN DATE, inEndDate IN DATE, inProcedure IN VARCHAR2
  ,inParams VARCHAR2 DEFAULT NULL)
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  FOR idx IN (SELECT MIN(TRUNC(InEndDate,'DD') - ROWNUM +1) min_dt
                    ,MAX(TRUNC(InEndDate,'DD') - ROWNUM +1) max_dt
                    ,'
                      BEGIN
                        '||lower(vOwner)||'.pkg_etl_signs.mass_load_parallel_by_date_pe(to_date('''||TO_CHAR(MIN(TRUNC(InEndDate,'DD') - ROWNUM +1),'DD.MM.YYYY')||''',''DD.MM.YYYY'')
                                                           ,to_date('''||TO_CHAR(MAX(TRUNC(InEndDate,'DD') - ROWNUM +1),'DD.MM.YYYY')||''',''DD.MM.YYYY'')
                                                           ,'''||inProcedure||''','''||inParams||''');
                      END;
                    ' as exec_sql
                  FROM DUAL CONNECT BY ROWNUM < TRUNC(InEndDate,'DD') - TRUNC(inBegDate,'DD') + 2
                  GROUP BY TRUNC(TRUNC(InEndDate,'DD')- ROWNUM +1,'MM')
              ORDER BY 1
             )
  LOOP
    EXECUTE IMMEDIATE idx.exec_sql;
  END LOOP;
END mass_load_parallel_by_month;

PROCEDURE mass_load_parallel_by_ydate_pe
  (inBegDate IN DATE, inEndDate IN DATE, inUnit IN VARCHAR2
  ,inParams IN VARCHAR2 DEFAULT NULL
  ,inLastDay BOOLEAN DEFAULT TRUE
  ,inMonthlyDay VARCHAR2 DEFAULT NULL)
  IS
    vMes VARCHAR2(2000);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vPLev NUMBER;
    vTry NUMBER;
    vStatus NUMBER;
    vTask VARCHAR2(255) := dbms_parallel_execute.generate_task_name;
    vParams VARCHAR2(4000);
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  vMes := 'START :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.mass_load_parallel_by_ydate_pe" started.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.mass_load_parallel_by_ydate_pe',vMes);

  -- Формирование строки доп. параметров
  IF inParams IS NOT NULL THEN
    FOR idx IN (
      SELECT SUBSTR(str,1,INSTR(str,' ',1,1)-1) AS param_type
            ,SUBSTR(str,INSTR(str,' ',1,1)+1) AS param_value
      FROM TABLE(parse_str(inParams,'::'))
    ) LOOP
      vParams := vParams||
        CASE idx.param_type
          WHEN 'VARCHAR2' THEN ''''''||idx.param_value||''''''
          WHEN 'DATE' THEN 'to_date('''''||idx.param_value||''''',''''DD.MM.YYYY'''')'
        ELSE idx.param_value END||',';
    END LOOP;
    vParams := SUBSTR(vParams,1,LENGTH(vParams) - 1)  ;
  END IF;

  --Создание временной таблицы
  EXECUTE IMMEDIATE 'CREATE TABLE '||lower(vOwner)||'.tmp_'||vTask||' (id NUMBER,exec_sql VARCHAR2(2000))';

  IF inLastDay AND NVL(to_number(inMonthlyDay, 'FM99', 'nls_numeric_characters='', '''),0) = 0 THEN
    FOR idx IN (SELECT ROWNUM AS ID
                      ,'BEGIN
                       '||inUnit||'(to_date('''''||TO_CHAR(LAST_DAY(ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1)),'DD.MM.YYYY')||''''',''''DD.MM.YYYY''''),to_date('''''||TO_CHAR(LAST_DAY(ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1)),'DD.MM.YYYY')||''''',''''DD.MM.YYYY'''')'||NVL2(vParams,','||vParams,'')||'); END;' as exec_sql
                  FROM DUAL CONNECT BY ROWNUM <= MONTHS_BETWEEN(TRUNC(InEndDate,'MM'),TRUNC(inBegDate,'MM')) + 1
                ORDER BY 1
               )
    LOOP
      EXECUTE IMMEDIATE
      --dbms_output.put_line(
      'INSERT INTO '||lower(vOwner)||'.tmp_'||vTask||' (id,exec_sql)
        VALUES ('||idx.id||','''||idx.exec_sql||''')'
      --)
      ;
    END LOOP;
  ELSIF NOT inLastDay AND NVL(to_number(inMonthlyDay, 'FM99', 'nls_numeric_characters='', '''),0) = 0 THEN
    FOR idx IN (SELECT ROWNUM AS ID
                      ,'BEGIN
                         '||inUnit||'(to_date('''''||TO_CHAR(ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1),'DD.MM.YYYY')||''''',''''DD.MM.YYYY''''),to_date('''''||TO_CHAR(ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1),'DD.MM.YYYY')||''''',''''DD.MM.YYYY'''')'||NVL2(vParams,','||vParams,'')||'); END;' AS exec_sql
                    FROM DUAL CONNECT BY ROWNUM <= MONTHS_BETWEEN(TRUNC(InEndDate,'MM'),TRUNC(inBegDate,'MM')) + 1
                ORDER BY 1
               )
    LOOP
      EXECUTE IMMEDIATE
      --dbms_output.put_line(
      'INSERT INTO '||lower(vOwner)||'.tmp_'||vTask||' (id,exec_sql)
        VALUES ('||idx.id||','''||idx.exec_sql||''')'
      --)
      ;
    END LOOP;
  ELSE
    FOR idx IN (SELECT ROWNUM AS ID
                      ,CASE WHEN EXTRACT(MONTH FROM ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1)) = EXTRACT(MONTH FROM ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1) + NVL(to_number(inMonthlyDay, 'FM99', 'nls_numeric_characters='', '''),0) - 1) THEN
                         'BEGIN
                         '||inUnit||'(to_date('''''||TO_CHAR(ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1) + NVL(to_number(inMonthlyDay, 'FM99', 'nls_numeric_characters='', '''),0) - 1,'DD.MM.YYYY')||''''',''''DD.MM.YYYY''''),to_date('''''||TO_CHAR(ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1) + NVL(to_number(inMonthlyDay, 'FM99', 'nls_numeric_characters='', '''),0) - 1,'DD.MM.YYYY')||''''',''''DD.MM.YYYY'''')'||NVL2(vParams,','||vParams,'')||'); END;'
                       ELSE 'BEGIN '||lower(vOwner)||'.pkg_etl_signs.pr_log_write('''''||inUnit||''''',''''INFORMATION :: "'||inMonthlyDay||'.'||TRIM(to_char(EXTRACT(MONTH FROM ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1)),'00')||'.'||EXTRACT(YEAR FROM ADD_MONTHS(TRUNC(InEndDate,'MM'),-ROWNUM + 1)))||'" - дата отсутствует в указанном месяце. Расчет не требуется''''); END;'
                       END AS exec_sql
                    FROM DUAL CONNECT BY ROWNUM <= MONTHS_BETWEEN(TRUNC(InEndDate,'MM'),TRUNC(inBegDate,'MM')) + 1
                ORDER BY 1
               )
    LOOP
      BEGIN
      vMes :=
      --dbms_output.put_line(
      'INSERT INTO '||lower(vOwner)||'.tmp_'||vTask||' (id,exec_sql)
        VALUES ('||idx.id||','''||idx.exec_sql||''')'
      --)
      ;
      EXECUTE IMMEDIATE vMes;
      EXCEPTION WHEN OTHERS THEN
        pr_log_write(inUnit,SQLERRM||Chr(10)||vMes);
      END;
    END LOOP;
  END IF;

  --Вычисление количества потоков
  SELECT TRUNC(to_number(VALUE)/5*4) INTO vPLev FROM v$parameter WHERE NAME = 'job_queue_processes';

  --Наименование задачи
  DBMS_PARALLEL_EXECUTE.CREATE_TASK(task_name => vTask);
  --Раскладка по потокам
  DBMS_PARALLEL_EXECUTE.CREATE_CHUNKS_BY_SQL
    (task_name => vTask
    ,sql_stmt =>'SELECT id,id FROM '||lower(vOwner)||'.tmp_'||vTask||' ORDER BY 1'
    ,by_rowid => FALSE
    );
  --Запуск задачи на выполнение
  DBMS_PARALLEL_EXECUTE.RUN_TASK (task_name => vTask,
     sql_stmt => 'declare
                    vSQL VARCHAR2(4000);
                  begin
                     SELECT exec_sql INTO vSQL
                       FROM '||lower(vOwner)||'.tmp_'||vTask||'
                       WHERE id = :start_id AND id = :end_id
                     ;
                    execute immediate vSQL;
                    commit;
                  end;'
     ,language_flag => DBMS_SQL.NATIVE
     , parallel_level => vPLev );

  --Финишный контроль и удаление задачи
  vTry := 0;
  vStatus := DBMS_PARALLEL_EXECUTE.task_status(vTask);

  WHILE(vTry < 2 and vStatus != DBMS_PARALLEL_EXECUTE.FINISHED)
  LOOP
    vTry := vTry + 1;
    DBMS_PARALLEL_EXECUTE.resume_task(vTask);
    vStatus := DBMS_PARALLEL_EXECUTE.task_status(vTask);
  END LOOP;

  DBMS_PARALLEL_EXECUTE.drop_task(vTask);

  -- Удаление временной таблицы
  EXECUTE IMMEDIATE 'DROP TABLE '||lower(vOwner)||'.tmp_'||vTask;

  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.mass_load_parallel_by_ydate_pe" finished in '||get_ti_as_hms(vEndTime - vBegTime)||' successfully.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.mass_load_parallel_by_ydate_pe',vMes);
EXCEPTION WHEN OTHERS THEN
  DBMS_PARALLEL_EXECUTE.drop_task(vTask);
  vEndTime := SYSDATE;
  vMes := 'ERROR :: '||SQLERRM;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.mass_load_parallel_by_ydate_pe',vMes);
  vMes := 'FINISH :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.mass_load_parallel_by_ydate_pe" finished in '||get_ti_as_hms(vEndTime - vBegTime)||' with errors.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.mass_load_parallel_by_ydate_pe',vMes);
END mass_load_parallel_by_ydate_pe;

PROCEDURE mass_load_parallel_by_year
  (inBegDate IN DATE, inEndDate IN DATE, inProcedure IN VARCHAR2
  ,inParams VARCHAR2 DEFAULT NULL
  ,inLastDay BOOLEAN DEFAULT TRUE
  ,inMonthlyDay VARCHAR2 DEFAULT NULL
  ,inYearParallel BOOLEAN DEFAULT FALSE
  ,inHeadJobName IN VARCHAR2 DEFAULT NULL)
  IS
    vLstDay VARCHAR2(5);
    vTask VARCHAR2(256);
    vTry NUMBER;
    vStatus NUMBER;
    vPLev NUMBER;
    vSQL_stmt VARCHAR2(32700);
BEGIN
  IF inLastDay THEN vLstDay := 'TRUE'; ELSE vLstDay := 'FALSE'; END IF;
  IF inYearParallel THEN
    --Наименование задачи
    vTask := dbms_parallel_execute.generate_task_name;
    --Создание задачи
    DBMS_PARALLEL_EXECUTE.CREATE_TASK(task_name => vTask);

   -- Вычисление количества потоков
    SELECT TRUNC(to_number(VALUE)/5*4) INTO vPLev FROM v$parameter WHERE NAME = 'job_queue_processes';

    --Раскладка по потокам
    DBMS_PARALLEL_EXECUTE.CREATE_CHUNKS_BY_SQL
      (task_name => vTask
      ,sql_stmt =>
        'SELECT ROWNUM AS ID,ROWNUM as ID FROM (
          SELECT EXTRACT(YEAR FROM to_date('''||to_char(inEndDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') - ROWNUM + 1) as y
            FROM dual CONNECT BY ROWNUM <= to_date('''||to_char(inEndDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') - to_date('''||to_char(inBegDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') + 1
          GROUP BY EXTRACT(YEAR FROM to_date('''||to_char(inEndDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') - ROWNUM + 1)
          ORDER BY 1
        )'
      ,by_rowid => FALSE
      );

     vSql_stmt := 'declare
                    vSQL VARCHAR2(4000);
                  begin
                    WITH
                      y as (
                        SELECT ROWNUM AS ID,y_beg,y_end FROM (
                          SELECT MIN(to_date('''||to_char(inEndDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') - ROWNUM + 1) AS y_beg
                                ,MAX(to_date('''||to_char(inEndDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') - ROWNUM + 1) AS y_end
                            FROM dual CONNECT BY ROWNUM <= to_date('''||to_char(inEndDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') - to_date('''||to_char(inBegDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') + 1
                          GROUP BY EXTRACT(YEAR FROM to_date('''||to_char(inEndDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') - ROWNUM + 1)
                          ORDER BY 1
                        )
                      )
                     SELECT ''
                      BEGIN
                        mass_load_parallel_by_ydate_pe(to_date(''''''||to_char(y.y_beg,''DD.MM.YYYY'')||'''''',''''DD.MM.YYYY'''')
                                                             ,to_date(''''''||to_char(y.y_end,''DD.MM.YYYY'')||'''''',''''DD.MM.YYYY'''')
                                                             ,'''''||inProcedure||'''''
                                                             ,'||CASE WHEN inParams IS NOT NULL THEN ''''''||inParams||'''''' ELSE 'NULL' END||'
                                                             ,'||vLstDay||CASE WHEN inMonthlyDay IS NOT NULL THEN ','''''||inMonthlyDay||'''''' ELSE NULL END||'
                                                             ,'''''||inHeadJobName||''''');
                      END;
                    '' as exec_sql
                       INTO vSQL
                       FROM y
                       WHERE id = :start_id AND id = :end_id
                     ;
                    execute immediate vSQL;
                    commit;
                  end;';

    --Запуск задачи на выполнение
    DBMS_PARALLEL_EXECUTE.RUN_TASK (task_name => vTask
       ,sql_stmt => vSql_stmt
       ,language_flag => DBMS_SQL.NATIVE
       , parallel_level => vPLev );

    --Финишный контроль и удаление задачи
    vTry := 0;
    vStatus := DBMS_PARALLEL_EXECUTE.task_status(vTask);

    WHILE(vTry < 2 and vStatus != DBMS_PARALLEL_EXECUTE.FINISHED)
    LOOP
      vTry := vTry + 1;
      DBMS_PARALLEL_EXECUTE.resume_task(vTask);
      vStatus := DBMS_PARALLEL_EXECUTE.task_status(vTask);
    END LOOP;

    DBMS_PARALLEL_EXECUTE.drop_task(vTask);

  ELSE
    FOR idx IN (SELECT GREATEST(TRUNC(add_months(inEndDate,-(ROWNUM-1)*12),'YYYY'),inBegDate) AS min_dt
                      ,LEAST(add_months(TRUNC(add_months(inEndDate,-(ROWNUM-1)*12),'YYYY'),12) - 1,inEndDate) AS max_dt
                      ,'BEGIN'||Chr(10)||
                       '   mass_load_parallel_by_ydate_pe(to_date('''||TO_CHAR(GREATEST(TRUNC(add_months(inEndDate,-(ROWNUM-1)*12),'YYYY'),inBegDate),'DD.MM.YYYY')||''',''DD.MM.YYYY'')'||Chr(10)||
                       '                                       ,to_date('''||TO_CHAR(LEAST(add_months(TRUNC(add_months(inEndDate,-(ROWNUM-1)*12),'YYYY'),12) - 1,inEndDate),'DD.MM.YYYY')||''',''DD.MM.YYYY'')'||Chr(10)||
                       '                                       ,'''||inProcedure||''''||Chr(10)||
                       '                                       ,'||CASE WHEN inParams IS NOT NULL THEN ''''||inParams||'''' ELSE 'NULL' END||Chr(10)||
                       '                                       ,'||vLstDay||NVL2(inMonthlyDay,','''||inMonthlyDay||'''',NULL)||'
                                                               ,'''''||inHeadJobName||''''');'||Chr(10)||
                       'END;' AS exec_sql

                    FROM DUAL CONNECT BY ROWNUM <= CEIL(MONTHS_BETWEEN(inEndDate+1,TRUNC(inBegDate,'YYYY'))/12)
                ORDER BY 1
               )
    LOOP

      EXECUTE IMMEDIATE idx.exec_sql;
    END LOOP;
  END IF;
EXCEPTION WHEN OTHERS THEN
  BEGIN DBMS_PARALLEL_EXECUTE.drop_task(vTask); EXCEPTION WHEN OTHERS THEN NULL; END;
END mass_load_parallel_by_year;

PROCEDURE MyExecute(inScript IN VARCHAR2)
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  EXECUTE IMMEDIATE inScript;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.MyExecute','SUCESSFULLY :: '||inScript);
EXCEPTION WHEN OTHERS THEN
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.MyExecute',SQLERRM);
END MyExecute;

PROCEDURE AnyExecute(inScript IN CLOB,inParams IN VARCHAR2 DEFAULT NULL)
IS
  vOwner VARCHAR2(4000) := GetVarValue('vOwner');
  vStmt CLOB;
  vParams VARCHAR2(32700);
  vDeclParams VARCHAR2(32700);
  outRes VARCHAR2(32700);
BEGIN
  IF inParams IS NOT NULL THEN
    FOR idx IN (
      SELECT str,ROWNUM AS ord FROM (
        SELECT str
          FROM TABLE(pkg_etl_signs.parse_str(inParams,'#!#'))
      )
    ) LOOP
      vDeclParams := vDeclParams||'  p'||idx.ord||' VARCHAR2(32700) := q''['||idx.str||']'';'||CHR(10);
      vParams := vParams||' IN p'||idx.ord||',';
    END LOOP;
  END IF;  
  vDeclParams := vDeclParams||'  outRes VARCHAR2(32700);';
  vParams := vParams||' OUT outRes';
  vStmt := 'DECLARE'||CHR(10)||vDeclParams||CHR(10)||'BEGIN'||CHR(10)||'EXECUTE IMMEDIATE q''['||inScript||']'' USING '||vParams||';'||CHR(10)||'  :1 := outRes;'||CHR(10)||'END;';
  EXECUTE IMMEDIATE vStmt USING OUT outRes;
EXCEPTION WHEN OTHERS THEN
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.MyExecute',SQLERRM);
END AnyExecute;

PROCEDURE prepare_entity(inId IN NUMBER,outRes OUT CLOB)
  IS
    vBuff                     VARCHAR2(32700);
    vRes                      VARCHAR2(32700);
    --
    vEntityId                 NUMBER;
    vFctTableName             VARCHAR2(256);
    vHistTableName            VARCHAR2(256);
    vHistIdxName              VARCHAR2(256);
    vTmpTableName             VARCHAR2(256);
    vTmpIdxName               VARCHAR2(256);
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  -- Получение и сохранение в переменные метаданных сущности
  BEGIN
    SELECT id
          ,fct_table_name
          ,hist_table_name
          ,tmp_table_name
      INTO vEntityID
          ,vFctTableName
          ,vHistTableName
          ,vTmpTableName
      FROM tb_entity
      WHERE id = inId;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    raise_application_error(-20000,'Сущность ID = '||inId||' не найдена в таблице "'||lower(vOwner)||'.tb_entity"');
  END;
  -- Создание таблицы для хранения показателей по датам
  dbms_lob.createtemporary(outRes,FALSE);

  vBuff :=
  'CREATE TABLE '||lower(vOwner)||'.'||lower(vFctTableName)||' ('||CHR(10)||
  '  AS_OF_DATE DATE'||CHR(10)||
  ' ,OBJ_GID NUMBER'||CHR(10)||
  ' ,SOURCE_SYSTEM_ID NUMBER'||CHR(10)||
  ' ,SIGN_NAME VARCHAR2(256)'||CHR(10)||
  ' ,SIGN_VAL VARCHAR2(4000)'||CHR(10)||
  ') PARTITION BY LIST (SIGN_NAME)'||CHR(10)||
  '  SUBPARTITION BY LIST (AS_OF_DATE)'||CHR(10)||
  '  (PARTITION EMPTY_SIGN VALUES (''EMPTY_SIGN'') STORAGE(INITIAL 64K NEXT  8M) NOLOGGING'||CHR(10)||
  '     (SUBPARTITION SPEMPTY_19700101 VALUES(to_date(''01.01.1970'',''DD.MM.YYYY''))))';

  BEGIN
    EXECUTE IMMEDIATE vBuff;
    vRes := 'Table '||lower(vOwner)||'.'||lower(vFctTableName)||' created successfully';
    dbms_lob.writeappend(outRes,LENGTH(vRes),vRes);
  EXCEPTION WHEN OTHERS THEN
    vRes := SQLERRM||CHR(10)||vBuff;
    dbms_lob.writeappend(outRes,LENGTH(vRes),vRes);
  END;

  -- Создание таблицы для хранения показателей периодами
  vBuff :=
  'CREATE TABLE '||lower(vOwner)||'.'||lower(vHistTableName)||' ('||CHR(10)||
  '  EFFECTIVE_START DATE'||CHR(10)||
  ' ,EFFECTIVE_END DATE'||CHR(10)||
  ' ,OBJ_GID NUMBER'||CHR(10)||
  ' ,SOURCE_SYSTEM_ID NUMBER'||CHR(10)||
  ' ,SIGN_NAME VARCHAR2(256)'||CHR(10)||
  ' ,SIGN_VAL VARCHAR2(4000)'||CHR(10)||
  ') PARTITION BY LIST (SIGN_NAME)'||CHR(10)||
  '  (PARTITION EMPTY_SIGN VALUES (''EMPTY_SIGN'') STORAGE(INITIAL 64K NEXT 4M) NOLOGGING)';

  BEGIN
    EXECUTE IMMEDIATE vBuff;
    vRes := /*outRes||*/CHR(10)||'-----------------------'||CHR(10)||'Table '||lower(vOwner)||'.'||lower(vHistTableName)||' created successfully';
    dbms_lob.writeappend(outRes,LENGTH(vRes),vRes);
  EXCEPTION WHEN OTHERS THEN
    vRes := /*outRes||*/CHR(10)||'-----------------------'||CHR(10)||SQLERRM||CHR(10)||vBuff;
    dbms_lob.writeappend(outRes,LENGTH(vRes),vRes);
  END;

  -- Создание промежуточной таблицы
  vBuff :=
  'CREATE TABLE '||lower(vOwner)||'.'||lower(vTmpTableName)||' ('||CHR(10)||
  '  EFFECTIVE_START DATE'||CHR(10)||
  ' ,EFFECTIVE_END DATE'||CHR(10)||
  ' ,OBJ_GID NUMBER'||CHR(10)||
  ' ,SOURCE_SYSTEM_ID NUMBER'||CHR(10)||
  ' ,SIGN_NAME VARCHAR2(256)'||CHR(10)||
  ' ,SIGN_VAL VARCHAR2(4000)'||CHR(10)||
  ') PARTITION BY LIST (SIGN_NAME)'||CHR(10)||
  '  SUBPARTITION BY RANGE (EFFECTIVE_END)'||CHR(10)||
  '  (PARTITION EMPTY_SIGN VALUES (''EMPTY_SIGN'') STORAGE(INITIAL 64K NEXT 4M) NOLOGGING'||CHR(10)||
  '     (SUBPARTITION SPEMPTY_POTHERS VALUES LESS THAN (MAXVALUE))) NOLOGGING';

  BEGIN
    EXECUTE IMMEDIATE vBuff;
    vRes := /*outRes||*/CHR(10)||'-----------------------'||CHR(10)||'Table '||lower(vOwner)||'.'||lower(vTmpTableName)||' created successfully';
    dbms_lob.writeappend(outRes,LENGTH(vRes),vRes);
  EXCEPTION WHEN OTHERS THEN
    vRes := /*outRes||*/CHR(10)||'-----------------------'||CHR(10)||SQLERRM||CHR(10)||vBuff;
    dbms_lob.writeappend(outRes,LENGTH(vRes),vRes);
  END;

  -- Создание уникальных индексов
  -- Формирование наименований индексов
  BEGIN
    SELECT 'uix_'||object_id INTO vHistIdxName
      FROM all_objects
      WHERE owner = UPPER(vOwner)
        AND object_name = UPPER(vHistTableName)
        AND object_type = 'TABLE';
  EXCEPTION WHEN NO_DATA_FOUND THEN
    vRes := /*outRes||*/CHR(10)||'-----------------------'||CHR(10)||'Объект '||lower(vOwner)||'.'||lower(vHistTableName)||' не найден'||CHR(10)||vBuff;
    dbms_lob.writeappend(outRes,LENGTH(vRes),vRes);
  END;

  BEGIN
    SELECT 'uix_'||object_id INTO vTmpIdxName
      FROM all_objects
      WHERE owner = UPPER(vOwner)
        AND object_name = UPPER(vTmpTableName)
        AND object_type = 'TABLE';
  EXCEPTION WHEN NO_DATA_FOUND THEN
    vRes := /*outRes||*/CHR(10)||'-----------------------'||CHR(10)||'Объект '||lower(vOwner)||'.'||lower(vTmpTableName)||' не найден'||CHR(10)||vBuff;
    dbms_lob.writeappend(outRes,LENGTH(vRes),vRes);
  END;
  -- Формирование набора ключевых колонок, входящих в индекс
  --SELECT LISTAGG(SUBSTR(Str,1,INSTR(Str,' ') - 1),',') WITHIN GROUP (ORDER BY rownum) INTO vKeyIdxColumns
  --  FROM TABLE(parse_str(vKeyColumns,','));

  -- Формирование и запуск DDL
  vBuff := 'CREATE UNIQUE INDEX '||lower(vOwner)||'.'||vHistIdxName||' ON '||lower(vHistTableName)||CHR(10)||
           '  (SIGN_NAME,OBJ_GID,SOURCE_SYSTEM_ID,EFFECTIVE_END)'||CHR(10)||
           'LOCAL COMPRESS NOLOGGING';
  BEGIN
    EXECUTE IMMEDIATE vBuff;
    vRes := /*outRes||*/CHR(10)||'-----------------------'||CHR(10)||'Unique index '||lower(vOwner)||'.'||lower(vHistIdxName)||' created successfully';
    dbms_lob.writeappend(outRes,LENGTH(vRes),vRes);
  EXCEPTION WHEN OTHERS THEN
    vRes := /*outRes||*/CHR(10)||'-----------------------'||CHR(10)||SQLERRM||CHR(10)||vBuff;
    dbms_lob.writeappend(outRes,LENGTH(vRes),vRes);
  END;

  vBuff := 'CREATE UNIQUE INDEX '||lower(vOwner)||'.'||vTmpIdxName||' ON '||lower(vTmpTableName)||CHR(10)||
           '  (SIGN_NAME,EFFECTIVE_END,OBJ_GID,SOURCE_SYSTEM_ID)'||CHR(10)||
           'LOCAL COMPRESS NOLOGGING';
  BEGIN
    EXECUTE IMMEDIATE vBuff;
    vRes := /*outRes||*/CHR(10)||'-----------------------'||CHR(10)||'Unique index '||lower(vOwner)||'.'||lower(vTmpIdxName)||' created successfully';
    dbms_lob.writeappend(outRes,LENGTH(vRes),vRes);
  EXCEPTION WHEN OTHERS THEN
    vRes := /*outRes||*/CHR(10)||'-----------------------'||CHR(10)||SQLERRM||CHR(10)||vBuff;
    dbms_lob.writeappend(outRes,LENGTH(vRes),vRes);
  END;
EXCEPTION WHEN OTHERS THEN
  vRes := /*outRes||*/CHR(10)||SQLERRM;
  dbms_lob.writeappend(outRes,LENGTH(vRes),vRes);
END prepare_entity;

PROCEDURE prepare_log_table(outRes OUT VARCHAR2)
  IS
    vBuff VARCHAR2(32700);
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  -- Создание таблицы
  vBuff :=
  'CREATE TABLE '||lower(vOwner)||'.tb_signs_log'||CHR(10)||
  '  (id NUMBER,dat DATE, unit VARCHAR2(4000), message VARCHAR2(4000)) NOLOGGING';
  BEGIN
    EXECUTE IMMEDIATE vBuff;
    outRes := 'Table "'||lower(vOwner)||'.tb_signs_log" created successfully'||CHR(10);
  EXCEPTION WHEN OTHERS THEN
    outRes := 'Table "'||lower(vOwner)||'.tb_signs_log" not created. Error: '||SQLERRM||CHR(10);
  END;
  -- Создание индексов
  vBuff := 'CREATE UNIQUE INDEX '||lower(vOwner)||'.idx_tb_signs_log_u001 ON '||lower(vOwner)||'.tb_signs_log (id) NOLOGGING';
  BEGIN
    EXECUTE IMMEDIATE vBuff;
    outRes := outRes||'-------------------------'||CHR(10)||'Unique index "'||lower(vOwner)||'.idx_tb_signs_log_u001" created successfully'||CHR(10);
  EXCEPTION WHEN OTHERS THEN
    outRes := outRes||'-------------------------'||CHR(10)||'Unique index "'||lower(vOwner)||'.idx_tb_signs_log_u001" not created. Error: '||SQLERRM||CHR(10);
  END;

  vBuff := 'CREATE INDEX '||lower(vOwner)||'.idx_tb_signs_log_002 ON '||lower(vOwner)||'.tb_signs_log (dat) NOLOGGING';
  BEGIN
    EXECUTE IMMEDIATE vBuff;
    outRes := outRes||'-------------------------'||CHR(10)||'Index "'||lower(vOwner)||'.idx_tb_signs_log_002" created successfully'||CHR(10);
  EXCEPTION WHEN OTHERS THEN
    outRes := outRes||'-------------------------'||CHR(10)||'Index "'||lower(vOwner)||'.idx_tb_signs_log_002" not created. Error: '||SQLERRM||CHR(10);
  END;

  vBuff := 'CREATE INDEX '||lower(vOwner)||'.idx_tb_signs_log_003 ON '||lower(vOwner)||'.tb_signs_log (unit) NOLOGGING';
  BEGIN
    EXECUTE IMMEDIATE vBuff;
    outRes := outRes||'-------------------------'||CHR(10)||'Index "'||lower(vOwner)||'.idx_tb_signs_log_003" created successfully'||CHR(10);
  EXCEPTION WHEN OTHERS THEN
    outRes := outRes||'-------------------------'||CHR(10)||'Index "'||lower(vOwner)||'.idx_tb_signs_log_003" not created. Error: '||SQLERRM||CHR(10);
  END;

  -- Создание последовательности
  vBuff := 'CREATE SEQUENCE '||lower(vOwner)||'.tb_signs_log_id_seq MINVALUE 1 MAXVALUE 9999999999999999999999999999 START WITH 1 INCREMENT by 1 NOCACHE';
  BEGIN
    EXECUTE IMMEDIATE vBuff;
    outRes := outRes||'-------------------------'||CHR(10)||'Sequence "'||lower(vOwner)||'.tb_signs_log_id_seq" created successfully'||CHR(10);
  EXCEPTION WHEN OTHERS THEN
    outRes := outRes||'-------------------------'||CHR(10)||'Sequence "'||lower(vOwner)||'.tb_signs_log_id_seq" not created. Error: '||SQLERRM||CHR(10);
  END;

  -- Создание триггера
  vBuff :=
  'CREATE OR REPLACE TRIGGER '||lower(vOwner)||'.tb_signs_log_id_trg BEFORE INSERT ON '||lower(vOwner)||'.tb_signs_log FOR EACH ROW'||CHR(10)||
  'BEGIN SELECT '||lower(vOwner)||'.tb_signs_log_id_seq.nextval INTO :NEW.id FROM dual; END tb_signs_log_id_trg;';
  BEGIN
    EXECUTE IMMEDIATE vBuff;
    outRes := outRes||'-------------------------'||CHR(10)||'Trigger "'||lower(vOwner)||'.tb_signs_log_id_trg" compiled successfully'||CHR(10);
  EXCEPTION WHEN OTHERS THEN
    outRes := outRes||'-------------------------'||CHR(10)||'Trigger "'||lower(vOwner)||'.tb_signs_log_id_trg" not compiled. Error: '||SQLERRM||CHR(10);
  END;
END prepare_log_table;

FUNCTION get_sign(inSign IN VARCHAR2,inDate IN DATE, inSQL IN VARCHAR2 DEFAULT NULL) RETURN TTab PIPELINED
  IS
    vSQL CLOB;
    rec TRec;
    cur INTEGER;       -- хранит идентификатор (ID) курсора
    ret INTEGER;       -- хранит возвращаемое по вызову значение
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  -- Сохранение метаданных показателя в переменные
  SELECT p.sign_sql
    INTO vSQL
    FROM tb_signs_pool p
    WHERE p.sign_name = UPPER(inSign);

  IF inSQL IS NOT NULL THEN vSQL := inSQL; END IF;

  --dbms_output.put_line(vAnltSQL);

  cur := dbms_sql.open_cursor;
  dbms_sql.parse(cur, vSQL, dbms_sql.native);
  dbms_sql.define_column(cur,1,rec.obj_gid);
  dbms_sql.define_column(cur,2,rec.source_system_id);
  dbms_sql.define_column(cur,3,rec.sign_name,256);
  dbms_sql.define_column(cur,4,rec.sign_val,4000);

  IF inSQL IS NULL THEN
    dbms_sql.bind_variable_char(cur,'inDate',to_char(inDate,'DD.MM.YYYY'));
  END IF;

  ret := dbms_sql.execute(cur);
  LOOP
    EXIT WHEN dbms_sql.fetch_rows(cur) = 0;
    dbms_sql.column_value(cur,1,rec.obj_gid);
    dbms_sql.column_value(cur,2,rec.source_system_id);
    dbms_sql.column_value(cur,3,rec.sign_name);
    dbms_sql.column_value(cur,4,rec.sign_val);
    PIPE ROW(rec);
  END LOOP;
  dbms_sql.close_cursor(cur);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.get_sign','ERROR :: "'||UPPER(inSign)||'"  - Показатель не найден в таблице "'||lower(vOwner)||'.tb_signs_pool"');
  WHEN OTHERS THEN
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.get_sign','ERROR :: "'||UPPER(inSign)||'"  - '||SQLERRM||CHR(10)||'----------'||CHR(10)||vSQL);
END get_sign;

FUNCTION get_sign_anlt(inSign IN VARCHAR2, inDate IN DATE, inAnltCode IN VARCHAR2, inReverse NUMBER DEFAULT 0) RETURN TTab PIPELINED
  IS
    rec TRec;
    cur INTEGER;       -- хранит идентификатор (ID) курсора
    ret INTEGER;       -- хранит возвращаемое по вызову значение
    vSQL CLOB;
    vAnltSQL CLOB;
    vAnltID NUMBER;
    vBuff VARCHAR2(32700);
    vWhere VARCHAR2(32700);
    vCou INTEGER;
    --
    vFctTable VARCHAR2(256);
    vHistTable VARCHAR2(256);
    vHistFlg NUMBER;
    vReverse BOOLEAN := inReverse = 1;
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
-- Сохранение метаданных показателя в переменные
SELECT a.anlt_sql,a.id,lower(vOwner)||'.'||e.fct_table_name,lower(vOwner)||'.'||e.hist_table_name,p.hist_flg
      ,(SELECT COUNT(1) FROM tb_signs_anlt_spec WHERE anlt_id = a.id) AS cou
  INTO vSQL,vAnltID,vFctTable,vHistTable,vHistFlg,vCou
  FROM tb_signs_pool p
       INNER JOIN tb_entity e ON e.id = p.entity_id
       INNER JOIN tb_signs_anlt a
          ON a.anlt_code = inAnltCode
            AND inDate BETWEEN a.effective_start AND a.effective_end
  WHERE p.sign_name = UPPER(inSign)
    AND a.archive_flg = 0;

  IF vSQL IS NULL THEN
    vSQL := 'SELECT null AS obj_gid,null AS source_system_id,null AS sign_name FROM dual';
  END IF;

  dbms_lob.createtemporary(vAnltSQL,FALSE);
  vBuff :=
  'SELECT /*+ no_index(sgn) */'||CHR(10)||
  '       '||CASE WHEN NOT(vReverse) THEN 'sgn' ELSE 'anlt' END||'.obj_gid'||CHR(10)||
  '      ,'||CASE WHEN NOT(vReverse) THEN 'sgn' ELSE 'anlt' END||'.source_system_id'||CHR(10)||
  '      ,UPPER(:inSign) AS sign_name'||CHR(10);
  dbms_lob.writeappend(vAnltSQL,LENGTH(vBuff),vBuff);

  IF vCou > 0 THEN
      vBuff :=
      '      ,CASE'||CHR(10);
      dbms_lob.writeappend(vAnltSQL,LENGTH(vBuff),vBuff);
      FOR idx IN (
        SELECT ID,anlt_spec_name,LEVEL AS lev
              --,'WHEN '||SUBSTR(REPLACE(sys_connect_by_path('('||NVL(condition,CASE WHEN inReverse = 0 THEN 'sgn' ELSE 'anlt' END||'.sign_name = '''||UPPER(inSign)||'''')||')','-=#=-'),'-=#=-',' AND '),6)||' THEN '''||anlt_spec_val||'''' AS cond
              ,NVL2(condition,'WHEN '||condition||' THEN '''||anlt_spec_val||'''',NULL) AS cond
              ,condition
          FROM tb_signs_anlt_spec
          WHERE anlt_id = vAnltID
        CONNECT BY PRIOR anlt_spec_val = parent_val
        START WITH parent_val IS NULL AND anlt_id = vAnltID
         ORDER BY connect_by_isleaf DESC,lev DESC
      ) LOOP
        IF idx.lev > 1 THEN
          vBuff := idx.cond||CHR(10);
          dbms_lob.writeappend(vAnltSQL,LENGTH(vBuff),vBuff);
        ELSE
          vWhere := CASE WHEN idx.condition IS NOT NULL THEN ' WHERE '||idx.condition ELSE NULL END||CHR(10);
        END IF;

      END LOOP;
      vBuff :=
      'ELSE NULL END AS sign_val'||CHR(10);
      dbms_lob.writeappend(vAnltSQL,LENGTH(vBuff),vBuff);
  ELSE
    vBuff := ',anlt.sign_val'||CHR(10);
    dbms_lob.writeappend(vAnltSQL,LENGTH(vBuff),vBuff);
  END IF;

  vBuff :=
  'FROM '||CASE WHEN NOT(vReverse) THEN CASE vHistFlg WHEN 1 THEN vHistTable ELSE vFctTable END||' sgn LEFT JOIN' END||' ('||CHR(10);

  dbms_lob.writeappend(vAnltSQL,LENGTH(vBuff),vBuff);
  dbms_lob.writeappend(vAnltSQL,LENGTH(vSQL),vSQL);
  IF vWhere IS NOT NULL THEN dbms_lob.writeappend(vAnltSQL,LENGTH(vWhere),vWhere); END IF;

  vBuff :=
  CHR(10)||') anlt'||CASE WHEN NOT(vReverse) THEN
  CHR(10)||'  ON anlt.sign_name = sgn.sign_name AND anlt.obj_gid = sgn.obj_gid AND anlt.source_system_id = sgn.source_system_id'||CHR(10)||
  'WHERE sgn.sign_name = UPPER(:inSign)'||CHR(10)||
  '     AND '||CASE vHistFlg WHEN 1 THEN 'to_date(:inDate,''DD.MM.YYYY'') BETWEEN sgn.effective_start AND sgn.effective_end'
               ELSE 'to_date(:inDate,''DD.MM.YYYY'') = sgn.as_of_date' END||CHR(10) END;
  dbms_lob.writeappend(vAnltSQL,LENGTH(vBuff),vBuff);

  cur := dbms_sql.open_cursor;
  dbms_sql.parse(cur, vAnltSQL, dbms_sql.native);

  dbms_sql.define_column(cur,1,rec.obj_gid);
  dbms_sql.define_column(cur,2,rec.source_system_id);
  dbms_sql.define_column(cur,3,rec.sign_name,256);
  dbms_sql.define_column(cur,4,rec.sign_val,4000);

  dbms_sql.bind_variable_char(cur,'inDate',to_char(inDate,'DD.MM.YYYY'));
  dbms_sql.bind_variable_char(cur,'inSign',UPPER(inSign));

  ret := dbms_sql.execute(cur);
  LOOP
    EXIT WHEN dbms_sql.fetch_rows(cur) = 0;
    dbms_sql.column_value(cur,1,rec.obj_gid);
    dbms_sql.column_value(cur,2,rec.source_system_id);
    dbms_sql.column_value(cur,3,rec.sign_name);
    dbms_sql.column_value(cur,4,rec.sign_val);
    PIPE ROW(rec);
  END LOOP;
  --dbms_sql.close_cursor(cur);

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.get_sign_anlt','ERROR :: "'||UPPER(inSign)||'"  - Показатель не найден в таблице "'||lower(vOwner)||'.tb_signs_pool"');
  WHEN OTHERS THEN
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.get_sign_anlt','ERROR :: "'||UPPER(inSign)||'"  - '||SQLERRM);

    dbms_output.put_line(SQLERRM||CHR(10)||'-----------'||CHR(10)||vAnltSQL);
END get_sign_anlt;

FUNCTION get_anlt_spec_imp(inDate IN DATE, inAnltCode IN VARCHAR2) RETURN TTabAnltSpecImp PIPELINED
  IS
    vSQL CLOB;
    rec TRecAnltSpecImp;
    cur INTEGER;       -- хранит идентификатор (ID) курсора
    ret INTEGER;       -- хранит возвращаемое по вызову значение
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  SELECT spec_import_sql
    INTO vSQL
    FROM tb_signs_anlt
    WHERE anlt_code = UPPER(inAnltCode)
      AND inDate BETWEEN effective_start AND effective_end;

  cur := dbms_sql.open_cursor;
  dbms_sql.parse(cur, vSQL, dbms_sql.native);
  dbms_sql.define_column(cur,1,rec.val,4000);
  dbms_sql.define_column(cur,2,rec.parent_val,4000);
  dbms_sql.define_column(cur,3,rec.name,4000);
  dbms_sql.define_column(cur,4,rec.condition/*,32700*/);

  dbms_sql.bind_variable_char(cur,'inDate',to_char(inDate,'DD.MM.YYYY'));

  ret := dbms_sql.execute(cur);
  LOOP
    EXIT WHEN dbms_sql.fetch_rows(cur) = 0;
    dbms_sql.column_value(cur,1,rec.val);
    dbms_sql.column_value(cur,2,rec.parent_val);
    dbms_sql.column_value(cur,3,rec.name);
    dbms_sql.column_value(cur,4,rec.condition);
    PIPE ROW(rec);
  END LOOP;
  dbms_sql.close_cursor(cur);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.get_anlt_spec_imp','ERROR :: "'||UPPER(inAnltCode)||'"  - Аналитика не найдена в таблице "'||lower(vOwner)||'.tb_signs_anlt"');
  WHEN OTHERS THEN
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.get_anlt_spec_imp','ERROR :: "'||UPPER(inAnltCode)||'"  - '||SQLERRM||CHR(10)||'----------'||CHR(10)||vSQL);
END get_anlt_spec_imp;

FUNCTION get_sign_mass(inSign IN VARCHAR2,inDate IN DATE) RETURN TTabMass PIPELINED
  IS
    vSQL CLOB;
    rec TRecMass;
    cur INTEGER;       -- хранит идентификатор (ID) курсора
    ret INTEGER;       -- хранит возвращаемое по вызову значение
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  SELECT mass_sql INTO vSQL FROM tb_signs_pool WHERE sign_name = UPPER(inSign);

  cur := dbms_sql.open_cursor;
  dbms_sql.parse(cur, vSQL, dbms_sql.native);
  dbms_sql.define_column(cur,1,rec.effective_start);
  dbms_sql.define_column(cur,2,rec.effective_end);
  dbms_sql.define_column(cur,3,rec.obj_gid);
  dbms_sql.define_column(cur,4,rec.source_system_id);
  dbms_sql.define_column(cur,5,rec.sign_name,256);
  dbms_sql.define_column(cur,6,rec.sign_val,4000);

  dbms_sql.bind_variable_char(cur,'inDate',to_char(inDate,'DD.MM.YYYY'));

  ret := dbms_sql.execute(cur);
  LOOP
    EXIT WHEN dbms_sql.fetch_rows(cur) = 0;
    dbms_sql.column_value(cur,1,rec.effective_start);
    dbms_sql.column_value(cur,2,rec.effective_end);
    dbms_sql.column_value(cur,3,rec.obj_gid);
    dbms_sql.column_value(cur,4,rec.source_system_id);
    dbms_sql.column_value(cur,5,rec.sign_name);
    dbms_sql.column_value(cur,6,rec.sign_val);
    PIPE ROW(rec);
  END LOOP;
  dbms_sql.close_cursor(cur);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.get_sign','ERROR :: "'||UPPER(inSign)||'"  - Показатель не найден в таблице "'||lower(vOwner)||'.tb_signs_pool"');
  WHEN OTHERS THEN
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.get_sign','ERROR :: "'||UPPER(inSign)||'"  - '||SQLERRM);
END get_sign_mass;

FUNCTION CheckSubpartition(inBegDate IN DATE,inEndDate IN DATE,inSign IN VARCHAR2,inAnltCode IN VARCHAR2) RETURN VARCHAR2
  IS
    vMes VARCHAR2(2000);
    vSPCode VARCHAR2(30);
    vHistFlg NUMBER;
    vFCTTable VARCHAR2(256);
    vHistTable VARCHAR2(256);
    vFCTATable VARCHAR2(256);
    vHistATable VARCHAR2(256);
    vBuff VARCHAR2(32700);
    vDML CLOB;
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  -- Получение кода сабпартиции
  BEGIN
    SELECT p.sp_code,p.hist_flg
          ,lower(vOwner)||'.'||e.fct_table_name AS fct_table_name
          ,lower(vOwner)||'.'||e.hist_table_name AS hist_table_name
          ,lower(vOwner)||'.'||ae.fct_table_name AS fct_a_table_name
          ,lower(vOwner)||'.'||ae.hist_table_name AS hist_a_table_name
      INTO vSPCode,vHistFlg,vFCTTable,vHistTable,vFCTATable,vHistATable
      FROM tb_signs_pool p
           INNER JOIN tb_entity e
             ON e.id = p.entity_id
           LEFT JOIN tb_sign_2_anlt s2a
             ON s2a.sign_name = p.sign_name
                AND s2a.anlt_code = UPPER(inAnltCode)
           LEFT JOIN tb_signs_anlt a
             ON a.anlt_code = s2a.anlt_code
                AND inEndDate BETWEEN a.effective_start AND a.effective_end
           LEFT JOIN tb_entity ae
             ON ae.id = a.entity_id
      WHERE p.sign_name = UPPER(inSign);
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Показатель "'||inSign||'" не найден в таблице '||lower(vOwner)||'.tb_signs_pool');
  END;
  -- Очистка или создание
  IF vHistFlg = 0 THEN
    dbms_lob.createtemporary(vDML,FALSE);
    vBuff := 'BEGIN'||CHR(10);
    dbms_lob.writeappend(vDML,LENGTH(vBuff),vBuff);
    FOR idx IN (
      SELECT inEndDate - LEVEL + 1 AS dt FROM dual
      CONNECT BY LEVEL <= inEndDate - inBegDate + 1
      ORDER BY 1
    ) LOOP
      vBuff :=
      '  BEGIN'||CHR(10)||
      '    EXECUTE IMMEDIATE ''alter table '||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||' truncate subpartition '||vSPCode||'_'||to_char(idx.dt,'YYYYMMDD')||'''; '||CHR(10)||
      '    pkg_etl_signs.pr_log_write('''||lower(vOwner)||'.pkg_etl_signs.CheckSubpartition'',''SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||'" altered. Partition '||inSign||': Subpartition '||vSPCode||'_'||to_char(idx.dt,'YYYYMMDD')||' truncated'');'||CHR(10)||
      '  EXCEPTION WHEN OTHERS THEN'||CHR(10)||
      '    BEGIN'||CHR(10)||
      '      EXECUTE IMMEDIATE ''alter table '||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||
      ' MODIFY PARTITION '||inSign||' ADD SUBPARTITION '||vSPCode||'_'||to_char(idx.dt,'YYYYMMDD')||' VALUES (to_date('''''||to_char(idx.dt,'DD.MM.YYYY')||''''',''''DD.MM.YYYY''''))'';'||CHR(10)||
      '      pkg_etl_signs.pr_log_write('''||lower(vOwner)||'.pkg_etl_signs.CheckSubpartition'',''SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||'" altered. Partition '||inSign||': Subpartition '||vSPCode||'_'||to_char(idx.dt,'YYYYMMDD')||' added''); '||CHR(10)||
      '    EXCEPTION WHEN OTHERS THEN'||CHR(10)||
      '      EXECUTE IMMEDIATE ''alter table '||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||
      ' ADD PARTITION '||inSign||' VALUES('''''||inSign||''''') STORAGE (INITIAL 64k NEXT 4M) NOLOGGING (SUBPARTITION '||vSPCode||'_'||to_char(idx.dt,'YYYYMMDD')||' VALUES (to_date('''''||to_char(idx.dt,'DD.MM.YYYY')||''''',''''DD.MM.YYYY'''')))''; '||CHR(10)||
      '      pkg_etl_signs.pr_log_write('''||lower(vOwner)||'.pkg_etl_signs.CheckSubpartition'',''SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||'" altered. Partition '||inSign||' added. Subpartition '||vSPCode||'_'||to_char(idx.dt,'YYYYMMDD')||' added'');'||CHR(10)||
      '    END;'||CHR(10)||
      '  END;'||CHR(10);
      dbms_lob.writeappend(vDML,LENGTH(vBuff),vBuff);
    END LOOP;
    vBuff := 'END;';
    dbms_lob.writeappend(vDML,LENGTH(vBuff),vBuff);
    EXECUTE IMMEDIATE vDML;
    vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'" altered. Partition '||UPPER(inSign)||': Subpartitions "'||to_char(inBegDate,'YYYYMMDD')||' - '||to_char(inEndDate,'YYYYMMDD')||'" prepared';
  ELSE
    BEGIN
      EXECUTE IMMEDIATE
        'ALTER TABLE '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||' ADD PARTITION '||inSign||' VALUES('''||UPPER(inSign)||''') STORAGE(INITIAL 64K NEXT 4M) NOLOGGING';
      vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'" altered. Partition '||UPPER(inSign)||' added.';
    EXCEPTION WHEN OTHERS THEN
      vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'". Partition '||UPPER(inSign)||'. Clearing of historical subpartition not required.';
    END;
  END IF;


  RETURN vMes;
END CheckSubpartition;

PROCEDURE CheckSubpartition(inBegDate IN DATE,inEndDate IN DATE,inSign IN VARCHAR2,inAnltCode IN VARCHAR2)
  IS
    vMes VARCHAR2(2000);
    vSPCode VARCHAR2(30);
    vHistFlg NUMBER;
    vFCTTable VARCHAR2(256);
    vHistTable VARCHAR2(256);
    vFCTATable VARCHAR2(256);
    vHistATable VARCHAR2(256);
    vDays INTEGER;
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  vDays := inEndDate - inBegDate;
  -- Получение кода сабпартиции
  BEGIN
    SELECT p.sp_code,p.hist_flg
          ,lower(vOwner)||'.'||e.fct_table_name AS fct_table_name
          ,lower(vOwner)||'.'||e.hist_table_name AS hist_table_name
          ,lower(vOwner)||'.'||ae.fct_table_name AS fct_a_table_name
          ,lower(vOwner)||'.'||ae.hist_table_name AS hist_a_table_name
      INTO vSPCode,vHistFlg,vFCTTable,vHistTable,vFCTATable,vHistATable
      FROM tb_signs_pool p
           INNER JOIN tb_entity e
             ON e.id = p.entity_id
           LEFT JOIN tb_sign_2_anlt s2a
             ON s2a.sign_name = p.sign_name
                AND s2a.anlt_code = UPPER(inAnltCode)
           LEFT JOIN tb_signs_anlt a
             ON a.anlt_code = s2a.anlt_code
                AND inEndDate BETWEEN a.effective_start AND a.effective_end
           LEFT JOIN tb_entity ae
             ON ae.id = a.entity_id
      WHERE p.sign_name = UPPER(inSign);
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Показатель "'||inSign||'" не найден в таблице '||lower(vOwner)||'.tb_signs_pool');
  END;
  -- Очистка или создание
  FOR idx IN 0..vDays LOOP
    IF vHistFlg = 0 THEN
      BEGIN
        EXECUTE IMMEDIATE 'alter table '||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||'
                           ADD PARTITION '||inSign||' VALUES('''||inSign||''') storage (INITIAL 64k NEXT 4M) NOLOGGING (SUBPARTITION '||vSPCode||'_'||to_char(inBegDate+idx,'YYYYMMDD')||' VALUES (to_date('''||to_char(inBegDate+idx,'DD.MM.YYYY')||''',''DD.MM.YYYY'')))';
        vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||'" altered. Partition '||inSign||' added. Subpartition '||vSPCode||'_'||to_char(inBegDate+idx,'YYYYMMDD')||' added.';
      EXCEPTION WHEN OTHERS THEN
        BEGIN
          EXECUTE IMMEDIATE 'alter table '||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||'
                             MODIFY PARTITION '||inSign||' ADD SUBPARTITION '||vSPCode||'_'||to_char(inBegDate+idx,'YYYYMMDD')||' VALUES (to_date('''||to_char(inBegDate+idx,'DD.MM.YYYY')||''',''DD.MM.YYYY''))';
          vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||'" altered. Partition '||inSign||' modified. Subpartition '||vSPCode||'_'||to_char(inBegDate+idx,'YYYYMMDD')||' added.';
          EXCEPTION WHEN OTHERS THEN
            EXECUTE IMMEDIATE 'alter table '||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||' truncate subpartition '||vSPCode||'_'||to_char(inBegDate+idx,'YYYYMMDD');
            vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||'" altered. Partition '||inSign||': Subpartition '||vSPCode||'_'||to_char(inBegDate+idx,'YYYYMMDD')||' truncated';
          END;
      END;
    ELSE
      BEGIN
        EXECUTE IMMEDIATE
          'ALTER TABLE '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||' ADD PARTITION '||inSign||' VALUES('''||UPPER(inSign)||''') STORAGE(INITIAL 64K NEXT 4M) NOLOGGING';
        vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'" altered. Partition '||UPPER(inSign)||' added.';
      EXCEPTION WHEN OTHERS THEN
        vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'". Partition '||UPPER(inSign)||'. Clearing of historical subpartition not required.';
      END;
    END IF;
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.CheckSubpartition',vMes);
  END LOOP;
EXCEPTION WHEN OTHERS THEN
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.CheckSubpartition',SQLERRM);
END CheckSubpartition;

FUNCTION CompressSubpartition(inDate IN DATE,inSign IN VARCHAR2,inAnltCode IN VARCHAR2) RETURN VARCHAR2
  IS
    vMes VARCHAR2(2000);
    vSPCode VARCHAR2(6);
    vTIBegin DATE;
    vEndTime DATE;
    vHistFlg NUMBER;
    vFCTTable VARCHAR2(256);
    vHistTable VARCHAR2(256);
    vFCTATable VARCHAR2(256);
    vHistATable VARCHAR2(256);
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  -- Получение кода сабпартиции
  BEGIN
    SELECT p.sp_code,p.hist_flg
          ,lower(vOwner)||'.'||e.fct_table_name AS fct_table_name
          ,lower(vOwner)||'.'||e.hist_table_name AS hist_table_name
          ,lower(vOwner)||'.'||ae.fct_table_name AS fct_a_table_name
          ,lower(vOwner)||'.'||ae.hist_table_name AS hist_a_table_name
      INTO vSPCode,vHistFlg,vFCTTable,vHistTable,vFCTATable,vHistATable
      FROM tb_signs_pool p
           INNER JOIN tb_entity e
             ON e.id = p.entity_id
           LEFT JOIN tb_sign_2_anlt s2a
             ON s2a.sign_name = p.sign_name
                AND s2a.anlt_code = UPPER(inAnltCode)
           LEFT JOIN tb_signs_anlt a
             ON a.anlt_code = s2a.anlt_code
                AND inDate BETWEEN a.effective_start AND a.effective_end
           LEFT JOIN tb_entity ae
             ON ae.id = a.entity_id
      WHERE p.sign_name = UPPER(inSign);
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Показатель "'||inSign||'" не найден в таблице '||lower(vOwner)||'.tb_signs_pool');
  END;
  -- Сжатие
  vTIBegin := SYSDATE;
  IF vHistFlg = 0 THEN
    EXECUTE IMMEDIATE 'alter table '||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||' move subpartition '||vSPCode||'_'||to_char(inDate,'YYYYMMDD')||' compress';
    vEndTime := SYSDATE;
    vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||'" Partition '||inSign||': Subpartition '||vSPCode||'_'||to_char(inDate,'YYYYMMDD')||' compressed in '||get_ti_as_hms(vEndTime - vTIBegin);
  ELSE
    vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'" Partition '||inSign||'. Compressing of historical partition not required';
  END IF;
  RETURN vMes;
EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: Table "'||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||'" Partition '||inSign||': Subpartition '||vSPCode||'_'||to_char(inDate,'YYYYMMDD')||' :: '||SQLERRM;
  RETURN vMes;
END CompressSubpartition;

PROCEDURE CompressSubpartition(inBegDate IN DATE,inEndDate IN DATE,inSign IN VARCHAR2,inAnltCode IN VARCHAR2)
  IS
    vMes VARCHAR2(2000);
    vSPCode VARCHAR2(6);
    vTIBegin DATE;
    vEndTime DATE;
    vHistFlg NUMBER;
    vFCTTable VARCHAR2(256);
    vHistTable VARCHAR2(256);
    vFCTATable VARCHAR2(256);
    vHistATable VARCHAR2(256);
    vDays INTEGER;
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  vDays := inEndDate - inBegDate;
  -- Получение кода сабпартиции
  BEGIN
    SELECT p.sp_code,p.hist_flg
          ,lower(vOwner)||'.'||e.fct_table_name AS fct_table_name
          ,lower(vOwner)||'.'||e.hist_table_name AS hist_table_name
          ,lower(vOwner)||'.'||ae.fct_table_name AS fct_a_table_name
          ,lower(vOwner)||'.'||ae.hist_table_name AS hist_a_table_name
      INTO vSPCode,vHistFlg,vFCTTable,vHistTable,vFCTATable,vHistATable
      FROM tb_signs_pool p
           INNER JOIN tb_entity e
             ON e.id = p.entity_id
           LEFT JOIN tb_sign_2_anlt s2a
             ON s2a.sign_name = p.sign_name
                AND s2a.anlt_code = UPPER(inAnltCode)
           LEFT JOIN tb_signs_anlt a
             ON a.anlt_code = s2a.anlt_code
                AND inEndDate BETWEEN a.effective_start AND a.effective_end
           LEFT JOIN tb_entity ae
             ON ae.id = a.entity_id
      WHERE p.sign_name = UPPER(inSign);
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Показатель "'||inSign||'" не найден в таблице '||lower(vOwner)||'.tb_signs_pool');
  END;
  -- Сжатие
    IF vHistFlg = 0 THEN
     FOR idx IN 0..vDays LOOP
      BEGIN
        vTIBegin := SYSDATE;
        EXECUTE IMMEDIATE 'alter table '||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||' move subpartition '||vSPCode||'_'||to_char(inBegDate+idx,'YYYYMMDD')||' compress';
        vEndTime := SYSDATE;
        vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||'" Partition '||inSign||': Subpartition '||vSPCode||'_'||to_char(inBegDate+idx,'YYYYMMDD')||' compressed in '||get_ti_as_hms(vEndTime - vTIBegin);
        pr_log_write(lower(vOwner)||'.pkg_etl_signs.CompressSubpartition',vMes);
      EXCEPTION WHEN OTHERS THEN
        vMes := 'ERROR :: Table "'||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||'" Partition '||inSign||': Subpartition '||vSPCode||'_'||to_char(inBegDate+idx,'YYYYMMDD')||' :: '||SQLERRM;
        pr_log_write(lower(vOwner)||'.pkg_etl_signs.CompressSubpartition',vMes);
      END;
    END LOOP;
    ELSE
      vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'" Partition '||inSign||'. Compressing of historical partition not required';
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.CompressSubpartition',vMes);
    END IF;
END CompressSubpartition;

PROCEDURE tb_load_daily(inBegDate IN DATE,inEndDate IN DATE,inSign VARCHAR2,inAnltCode IN VARCHAR2)
  IS
    vDays INTEGER;
    vMes VARCHAR2(32700);
    vBuff VARCHAR2(32700);
    vSQL CLOB;
    vCou INTEGER := 0;
    vHistTable VARCHAR2(256);
    vHistATable VARCHAR2(256);
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  vDays := inEndDate - inBegDate;
  -- Получение наименования таблицы для загрузки
  BEGIN
    SELECT UPPER(vOwner||'.'||e.hist_table_name) AS hist_table_name
          ,lower(vOwner)||'.'||ae.hist_table_name AS hist_a_table_name
      INTO vHistTable,vHistATable
      FROM tb_signs_pool p
           INNER JOIN tb_entity e
             ON e.id = p.entity_id
           LEFT JOIN tb_sign_2_anlt s2a
             ON s2a.sign_name = p.sign_name
                AND s2a.anlt_code = UPPER(inAnltCode)
           LEFT JOIN tb_signs_anlt a
             ON a.anlt_code = s2a.anlt_code
                AND inEndDate BETWEEN a.effective_start AND a.effective_end
           LEFT JOIN tb_entity ae
             ON ae.id = a.entity_id
      WHERE p.sign_name = UPPER(inSign);
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Показатель "'||inSign||'" не найден в таблице '||lower(vOwner)||'.tb_signs_pool');
  END;

  FOR days IN 0..vDays LOOP
    dbms_lob.createtemporary(vSQL,FALSE);
    vBuff :=
    'DECLARE'||CHR(10)||
    '  vStr VARCHAR2(4000);'||CHR(10)||
    '  vCou INTEGER := 0;'||CHR(10)||
    --'  vLogged BOOLEAN := FALSE;'||CHR(10)||
    'BEGIN'||CHR(10)||
    'EXECUTE IMMEDIATE ''ALTER SESSION SET nls_date_format = ''''DD.MM.RRRR HH24:MI:SS'''''';'||CHR(10)||
    'FOR idx IN ('||CHR(10)||
    '  WITH'||CHR(10)||
    '    ch AS ('||CHR(10)||
    '      SELECT /*+ MATERIALIZE LEADING(SRC) NO_INDEX(DEST)*/'||CHR(10)||
    '             :1 AS SRC_EFFECTIVE_START,'||CHR(10)||
    '             to_date(''31.12.5999'',''DD.MM.YYYY'') AS SRC_EFFECTIVE_END,'||CHR(10)||
    '             SRC.OBJ_GID AS SRC_OBJ_GID,'||CHR(10)||
    '             SRC.SOURCE_SYSTEM_ID AS SRC_SOURCE_SYSTEM_ID,'||CHR(10)||
    '             SRC.SIGN_NAME AS SRC_SIGN_NAME,'||CHR(10)||
    '             SRC.SIGN_VAL AS SRC_SIGN_VAL,'||CHR(10)||
    '             DEST.SIGN_NAME AS D_SIGN_NAME,'||CHR(10)||
    '             DEST.EFFECTIVE_START AS D_EFFECTIVE_START,'||CHR(10)||
    '             DEST.SIGN_VAL AS D_SIGN_VAL'||CHR(10)||
    CASE WHEN inAnltCode IS NULL THEN
    '       FROM TABLE('||lower(vOwner)||'.pkg_etl_signs.get_sign(:2,:1)) src'||CHR(10)
    ELSE
    '       FROM TABLE('||lower(vOwner)||'.pkg_etl_signs.get_sign_anlt(:2,:1,:3,'||CASE WHEN UPPER(inSign) = UPPER(inAnltCode) THEN '1' ELSE '0' END||')) src'||CHR(10)
    END||
    '            LEFT JOIN '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||' PARTITION('||UPPER(inSign)||') DEST'||CHR(10)||
    '              ON DEST.SIGN_NAME = :2'||CHR(10)||
    '                 AND DEST.OBJ_GID = SRC.OBJ_GID'||CHR(10)||
    '                 AND DEST.SOURCE_SYSTEM_ID = SRC.SOURCE_SYSTEM_ID'||CHR(10)||
    '                 AND :1 BETWEEN DEST.EFFECTIVE_START AND DEST.EFFECTIVE_END'||CHR(10)||
    '       WHERE '||UPPER(vOwner)||'.PKG_ETL_SIGNS.ISEQUAL(DEST.SIGN_VAL, SRC.SIGN_VAL) = 0)'||CHR(10)||
    ' ,s AS ('||CHR(10)||
    '  SELECT obj_gid'||CHR(10)||
    '         ,source_system_id'||CHR(10)||
    '         ,MIN(EFFECTIVE_START) AS VNEXTEFF'||CHR(10)||
    '         ,MIN(SIGN_VAL) KEEP(DENSE_RANK FIRST ORDER BY SIGN_NAME,EFFECTIVE_START) AS VNEXTVAL'||CHR(10)||
    '     FROM '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||' PARTITION('||UPPER(inSign)||')'||CHR(10)||
    '     WHERE EFFECTIVE_START > :1'||CHR(10)||
    '       AND (obj_gid,source_system_id) IN (SELECT SRC_OBJ_GID,SRC_SOURCE_SYSTEM_ID FROM ch)'||CHR(10)||
    '   GROUP BY obj_gid,source_system_id)'||CHR(10)||
    ' ,p AS ('||CHR(10)||
    '   SELECT obj_gid'||CHR(10)||
    '         ,source_system_id'||CHR(10)||
    '         ,MAX(EFFECTIVE_END) AS VPREVEFF'||CHR(10)||
    '         ,MAX(SIGN_VAL) KEEP(DENSE_RANK LAST ORDER BY SIGN_NAME,EFFECTIVE_START) AS VPREVVAL'||CHR(10)||
    '     FROM '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||' PARTITION('||UPPER(inSign)||')'||CHR(10)||
    '     WHERE EFFECTIVE_END < :1'||CHR(10)||
    '       AND (obj_gid,source_system_id) IN (SELECT SRC_OBJ_GID,SRC_SOURCE_SYSTEM_ID FROM CH WHERE D_SIGN_NAME IS NULL)'||CHR(10)||
    '   GROUP BY obj_gid,source_system_id)'||CHR(10)||
    'SELECT'||CHR(10)||
    '   CH.SRC_EFFECTIVE_START,'||CHR(10)||
    '   CH.SRC_EFFECTIVE_END,'||CHR(10)||
    '   CH.SRC_OBJ_GID,'||CHR(10)||
    '   CH.SRC_SOURCE_SYSTEM_ID,'||CHR(10)||
    '   CH.SRC_SIGN_NAME,'||CHR(10)||
    '   CH.SRC_SIGN_VAL,'||CHR(10)||
    '   CH.D_SIGN_NAME,'||CHR(10)||
    '   CH.D_EFFECTIVE_START,'||CHR(10)||
    '   CH.D_SIGN_VAL,'||CHR(10)||
    '   p.VPREVEFF,'||CHR(10)||
    '   p.VPREVVAL,'||CHR(10)||
    '   s.VNEXTEFF,'||CHR(10)||
    '   s.VNEXTVAL'||CHR(10)||
    '  FROM CH'||CHR(10)||
    '  LEFT JOIN S'||CHR(10)||
    '    ON S.OBJ_GID = CH.SRC_OBJ_GID'||CHR(10)||
    '       AND S.SOURCE_SYSTEM_ID = CH.SRC_SOURCE_SYSTEM_ID'||CHR(10)||
    '  LEFT JOIN P'||CHR(10)||
    '    ON P.OBJ_GID = CH.SRC_OBJ_GID'||CHR(10)||
    '       AND P.SOURCE_SYSTEM_ID = CH.SRC_SOURCE_SYSTEM_ID'||CHR(10)||
    ') LOOP';
    dbms_lob.writeappend(vSQL,LENGTH(vBuff),vBuff);
    vBuff :=
    '  BEGIN'||CHR(10)||
    '    IF idx.src_effective_start = idx.d_effective_start THEN'||CHR(10)||
    '      vStr := ''DDel_1'';'||CHR(10)||
    '      DELETE FROM /*+ index(a) */ '||lower(CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END)||' a'||CHR(10)||
    '        WHERE sign_name = UPPER(idx.src_sign_name)'||CHR(10)||
    '          AND obj_gid = idx.src_obj_gid'||CHR(10)||
    '          AND source_system_id = idx.src_source_system_id'||CHR(10)||
    '          AND idx.src_effective_start BETWEEN effective_start AND effective_end;'||CHR(10)||
    '    ELSE'||CHR(10)||
    '      vStr := ''DUpd_1'';'||CHR(10)||
    '      UPDATE /*+ index(a) */ '||lower(CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END)||' a'||CHR(10)||
    '        SET effective_end = idx.src_effective_start - 1'||CHR(10)||
    '        WHERE sign_name = UPPER(idx.src_sign_name)'||CHR(10)||
    '          AND obj_gid = idx.src_obj_gid'||CHR(10)||
    '          AND source_system_id = idx.src_source_system_id'||CHR(10)||
    '          AND idx.src_effective_start BETWEEN effective_start AND effective_end;'||CHR(10)||
    '    END IF; '||CHR(10)||
        --
    '    IF idx.vNextEff < to_date(''31.12.5999'',''DD.MM.YYYY'') AND '||lower(vOwner)||'.pkg_etl_signs.isEqual(idx.src_sign_val,idx.vNextVal) = 1 THEN'||CHR(10)||
    '      vStr := ''DUpd_2'';'||CHR(10)||
    '      UPDATE /*+ index(a) */'||lower(CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END)||' a SET effective_start = idx.src_effective_start'||CHR(10)||
    '        WHERE sign_name = UPPER(idx.src_sign_name)'||CHR(10)||
    '          AND obj_gid = idx.src_obj_gid'||CHR(10)||
    '          AND source_system_id = idx.src_source_system_id'||CHR(10)||
    '          AND idx.vNextEff BETWEEN effective_start AND effective_end;'||CHR(10)||
    '    ELSIF idx.src_effective_start - idx.vPrevEff = 1  AND '||lower(vOwner)||'.pkg_etl_signs.isEqual(idx.src_sign_val,idx.vPrevVal) = 1 THEN'||CHR(10)||
    '      vStr := ''DUpd_4'';'||CHR(10)||
    '      UPDATE /*+ index(a) */'||lower(CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END)||' a SET effective_end = NVL(idx.vNextEff - 1,idx.src_effective_end)'||CHR(10)||
    '        WHERE sign_name = UPPER(idx.src_sign_name)'||CHR(10)||
    '          AND obj_gid = idx.src_obj_gid'||CHR(10)||
    '          AND source_system_id = idx.src_source_system_id'||CHR(10)||
    '          AND idx.vPrevEff BETWEEN effective_start AND effective_end;'||CHR(10)||
    '    ELSE'||CHR(10)||
    '      IF idx.src_sign_val IS NOT NULL THEN'||CHR(10)||
    '        vStr := ''DIns_2'';'||CHR(10)||
    '        INSERT INTO '||lower(CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END)||CHR(10)||
    '          (effective_start,effective_end,obj_gid,source_system_id,sign_name,sign_val)'||CHR(10)||
    '          VALUES (idx.src_effective_start'||CHR(10)||
    '                 ,NVL(idx.vNextEff - 1,idx.src_effective_end)'||CHR(10)||
    '                 ,idx.src_obj_gid'||CHR(10)||
    '                 ,idx.src_source_system_id'||CHR(10)||
    '                 ,UPPER(idx.src_sign_name)'||CHR(10)||
    '                 ,idx.src_sign_val);'||CHR(10)||
    '      END IF;  '||CHR(10)||
    '    END IF;'||CHR(10)||
    '  EXCEPTION WHEN OTHERS THEN'||CHR(10)||
    --'    IF NOT vLogged THEN'||CHR(10)||
    '      vStr := ''ERROR :: "'||UPPER(inSign)||'" - "''||to_char(idx.src_effective_start,''DD.MM.YYYY'')||''" - OBJ_SID = ''||idx.src_obj_gid*10+idx.src_source_system_id||'' :: ''||SQLERRM||Chr(10)||vStr;'||CHR(10)||
    --'      '||lower(vOwner)||'.pkg_etl_signs.pr_log_write('''||lower(vOwner)||'.pkg_etl_signs.tb_load_daily'',vStr);'||CHR(10)||
    --'      vLogged := TRUE;'||CHR(10)||
    --'    END IF;'||CHR(10)||
    '  END;'||CHR(10)||
    '  vCou := vCou + 1;'||CHR(10)||
    'END LOOP;'||CHR(10)||
    CASE WHEN inAnltCode IS NULL THEN
      ':3 := vCou;' ELSE ':4 := vCou;'
    END||CHR(10)||
    'END;';
    dbms_lob.writeappend(vSQL,LENGTH(vBuff),vBuff);
      IF inAnltCode IS NULL THEN
        EXECUTE IMMEDIATE vSQL USING IN inBegDate+days
               ,IN UPPER(inSign)
               ,OUT vCou;
      ELSE
        EXECUTE IMMEDIATE vSQL USING IN inBegDate+days
               ,IN UPPER(inSign)
               ,IN UPPER(inAnltCode)
               ,OUT vCou;
      END IF;
    --dbms_output.put_line(vSQL);
    COMMIT;
    vMes := 'SUCCESSFULLY :: "'||UPPER(inSign)||'" - "'||to_char(inBegDate + days,'DD.MM.YYYY')||'" - '||vCou||' rows proccessed in table "'||lower(CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END)||'"';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_daily',vMes);
    dbms_lob.freetemporary(vSQL);
  END LOOP;
EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: "'||UPPER(inSign)||'" - "'||to_char(inBegDate,'DD.MM.YYYY')||'" :: '||SQLERRM;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_daily',vMes);
  vMes := dbms_lob.substr(vSQL,32700,1);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_daily',vMes);
END tb_load_daily;

PROCEDURE ptb_load_daily(inBegDate IN DATE,inEndDate IN DATE,inSign VARCHAR2,inAnltCode IN VARCHAR2)
  IS
    vDays INTEGER;
    vMes VARCHAR2(32700);
    vBuff VARCHAR2(32700);
    vCou INTEGER := 0;
    vFctTable VARCHAR2(256);
    vFctATable VARCHAR2(256);
    vSPCode VARCHAR2(256);
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  EXECUTE IMMEDIATE 'alter session set "_FIX_CONTROL" = "11814428:0"';
  vDays := inEndDate - inBegDate;
  -- Получение наименования таблицы для загрузки
  BEGIN
    SELECT UPPER(vOwner||'.'||e.fct_table_name) AS fct_table_name
          ,lower(vOwner)||'.'||ae.fct_table_name AS fct_a_table_name
          ,p.sp_code
      INTO vFctTable,vFctATable,vSPCode
      FROM tb_signs_pool p
           INNER JOIN tb_entity e
             ON e.id = p.entity_id
           LEFT JOIN tb_sign_2_anlt s2a
             ON s2a.sign_name = p.sign_name
                AND s2a.anlt_code = UPPER(inAnltCode)
           LEFT JOIN tb_signs_anlt a
             ON a.anlt_code = s2a.anlt_code
                AND inEndDate BETWEEN a.effective_start AND a.effective_end
           LEFT JOIN tb_entity ae
             ON ae.id = a.entity_id
      WHERE p.sign_name = UPPER(inSign);
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Показатель "'||inSign||'" не найден в таблице '||lower(vOwner)||'.tb_signs_pool');
  END;

  FOR days IN 0..vDays LOOP
    vBuff :=
    'DECLARE'||CHR(10)||
    '  vCou INTEGER := 0;'||CHR(10)||
    'BEGIN'||CHR(10)||
    'FOR rw IN ('||CHR(10)||
    '   SELECT  :1 as as_of_date,obj_gid,source_system_id,sign_name,sign_val'||CHR(10)||
    CASE WHEN inAnltCode IS NULL THEN
    '       FROM TABLE('||lower(vOwner)||'.pkg_etl_signs.get_sign(:2,:1))'||CHR(10)
    ELSE
    '       FROM TABLE('||lower(vOwner)||'.pkg_etl_signs.get_sign_anlt(:2,:1,:3,'||CASE WHEN UPPER(inSign) = UPPER(inAnltCode) THEN '1' ELSE '0' END||'))'||CHR(10)
    END||
    'WHERE sign_val IS NOT NULL'||CHR(10)||
    ') LOOP'||CHR(10)||
    '  INSERT INTO '||CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END||' subpartition('||vSPCode||'_'||to_char(inBegDate+days,'YYYYMMDD')||') (as_of_date,obj_gid,source_system_id,sign_name,sign_val)'||CHR(10)||
    '    VALUES(rw.as_of_date,rw.obj_gid,rw.source_system_id,rw.sign_name,rw.sign_val);'||CHR(10)||
    '  vCou := vCou + 1;'||CHR(10)||
    'END LOOP;'||CHR(10)||
    CASE WHEN inAnltCode IS NULL THEN ':3 := vCou;' ELSE ':4 := vCou;' END||CHR(10)||
    'END;';
    IF inAnltCode IS NULL THEN
      EXECUTE IMMEDIATE vBuff USING IN inBegDate+days
             ,IN UPPER(inSign)
             ,OUT vCou;
    ELSE
      EXECUTE IMMEDIATE vBuff USING IN inBegDate+days
             ,IN UPPER(inSign)
             ,IN UPPER(inAnltCode)
             ,OUT vCou;
    END IF;
    COMMIT;
    vMes := 'SUCCESSFULLY :: "'||UPPER(inSign)||'" - "'||to_char(inBegDate + days,'DD.MM.YYYY')||'" - '||vCou||' rows inserted into table "'||lower(CASE WHEN inAnltCode IS NULL THEN vFCTTable ELSE vFCTATable END)||'"';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.ptb_load_daily',vMes);
  END LOOP;
EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: "'||UPPER(inSign)||'" - '||SQLERRM;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.ptb_load_daily',vMes);
END ptb_load_daily;

PROCEDURE load_sign(inBegDate IN DATE,inEndDate IN DATE,inSign IN VARCHAR2,inAnltCode IN VARCHAR2,inPrepareSegments NUMBER)
  IS
    vDays INTEGER;
    vMes VARCHAR2(2000);
    vTIBegin DATE;
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vHistFlg NUMBER;
    vCond NUMBER;
    vBuff VARCHAR2(32700);
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  vDays := inEndDate - inBegDate;
  vMes := 'START :: "'||inSign||'" "'||to_char(inBegDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.load_sign" started.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.load_sign',vMes);
  BEGIN
    SELECT p.hist_flg,GetConditionResult(p.condition) AS vCond
      INTO vHistFlg,vCond
      FROM tb_signs_pool p
      WHERE p.sign_name = UPPER(inSign);
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Показатель "'||UPPER(inSign)||'" не найден в таблице '||lower(vOwner)||'.tb_signs_pool');
  END;

  IF vCond = 1 THEN
    FOR idx IN 0..vDays
    LOOP
      IF inPrepareSegments = 1 THEN
        -- Подготовка субпартиций
        vTIBegin := SYSDATE;
        vMes := CheckSubpartition(inBegDate+idx,inBegDate+idx,UPPER(inSign),inAnltCode);
        -- Сохранение времени  подготовки в таблицу статистики расчетов
        vEndTime := SYSDATE;
        pr_stat_write(inSign,inAnltCode,(vEndTime - vTIBegin)*24*60*60,'PREPARE');
      END IF;
      -- Вставка данных в таблицу
      vTIBegin := SYSDATE;
      IF vHistFlg = 0 THEN -- Для "FCT" показателей
        vBuff :=
        'BEGIN'||CHR(10)||
        lower(vOwner)||'.pkg_etl_signs.ptb_load_daily(:1,:2,:3,:4);'||CHR(10)||
        'END;';
        EXECUTE IMMEDIATE vBuff USING IN inBegDate+idx,IN inBegDate+idx,IN UPPER(inSign),IN inAnltCode;
      ELSE -- Для "HIST" показателей
        vBuff :=
        'BEGIN'||CHR(10)||
           lower(vOwner)||'.pkg_etl_signs.tb_load_daily(:1,:2,:3,:4);'||CHR(10)||
        'END;';
        EXECUTE IMMEDIATE vBuff USING IN inBegDate+idx,IN inBegDate+idx,IN UPPER(inSign),IN inAnltCode;
      END IF;

      -- Сохранение времени расчета в таблицу статистики расчетов
      vEndTime := SYSDATE;
      pr_stat_write(inSign,inAnltCode,(vEndTime - vTIBegin)*24*60*60,'CALC');
      --Сжатие субпартиций
      vTIBegin := SYSDATE;
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.load_sign',CompressSubpartition(inBegDate+idx,UPPER(inSign),inAnltCode));
      -- Сохранение времени сжатия в таблицу статистики расчетов
      vEndTime := SYSDATE;
      pr_stat_write(inSign,inAnltCode,(vEndTime - vTIBegin)*24*60*60,'COMPRESS');
    END LOOP;
  ELSE
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.load_sign','ERROR :: "'||inSign||'" - Не выполнено доп.условие запуска расчета показателя, расчет не может быть запущен');
  END IF;

  vEndTime := SYSDATE;
  vMes := 'FINISH :: "'||inSign||'" "'||to_char(inBegDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.load_sign" finished in '||get_ti_as_hms(vEndTime - vBegTime)||' successfully';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.load_sign',vMes);
EXCEPTION
  WHEN OTHERS THEN
    vEndTime := SYSDATE;
    vMes := 'ERROR :: "'||UPPER(inSign)||'" - '||SQLERRM;
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.load_sign',vMes);
    vMes := 'FINISH :: "'||inSign||'" "'||to_char(inBegDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.load_sign" finished in '||get_ti_as_hms(vEndTime - vBegTime)||' with errors';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.load_sign',vMes);
END load_sign;

PROCEDURE load_new(inSQL IN CLOB,inJobName IN VARCHAR2 DEFAULT NULL,inCalcPoolId NUMBER DEFAULT NULL)
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
    vJobName VARCHAR2(256) := NVL(inJobName,UPPER(vOwner)||'.'||'LOADJOB_'||tb_signs_job_id_seq.nextval);
    vCalcPoolId NUMBER := inCalcPoolId;
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
BEGIN
  MERGE INTO tb_signs_job dest
    USING (SELECT vJobName AS job_name,vBegTime AS start_time,SUBSTR(inSQL,1,4000) AS action_sql,vCalcPoolId AS calc_pool_id FROM dual) src
      ON (src.job_name = dest.job_name)
  WHEN NOT MATCHED THEN INSERT (job_name,start_time,action_sql,head_job_name,calc_pool_id) VALUES (src.job_name,src.start_time,src.action_sql,src.job_name,src.calc_pool_id)
  WHEN MATCHED THEN UPDATE SET dest.start_time = src.start_time,dest.action_sql = src.action_sql;
  COMMIT;

  EXECUTE IMMEDIATE 'ALTER SESSION SET nls_date_format = ''DD.MM.RRRR HH24:MI:SS''';
  ChainKiller(ChainStarter(ChainBuilder(inSQL),vJobName));

  vEndTime := SYSDATE;
  UPDATE tb_signs_job j SET j.elapsed_time = get_ti_as_hms(vEndTime - vBegTime), state = 'FINISHED', last_update = vEndTime
    WHERE job_name = vJobName AND state IS NULL;
  COMMIT;
EXCEPTION WHEN OTHERS THEN
  pr_log_write(LOWER(vOwner)||'.pkg_etl_signs.load_new',SQLERRM);
END load_new;

PROCEDURE load(inBegDate IN DATE,inEndDate IN DATE)
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
    vBegDate VARCHAR2(30) := to_char(inBegDate,'DD.MM.YYYY');
    vEndDate VARCHAR2(30) := to_char(inEndDate,'DD.MM.YYYY');
    vBuff VARCHAR2(32700);
    vJobName VARCHAR2(256) := UPPER(vOwner)||'.'||'LOADALLJOB_'||tb_signs_job_id_seq.nextval;
BEGIN
  vBuff :=
    q'[SELECT p.sign_name AS ID
          ,s.prev_sign_name AS parent_id
          ,']'||vOwner||q'[.pkg_etl_signs.'||CASE WHEN p.sign_sql IS NOT NULL THEN 'load_sign' ELSE 'mass_load' END AS unit
          ,']'||vBegDate||'#!#'||vEndDate||q'[#!#'||p.sign_name||'#!##!#1' AS params
          ,CASE WHEN (p.condition IS NULL OR pkg_etl_signs.GetConditionResult(p.condition) = 1) AND p.archive_flg = 0 THEN 0 ELSE 1 END AS skip
      FROM tb_signs_pool p
           LEFT JOIN tb_sign_2_sign s
            ON s.sign_name = p.sign_name]';
   load_new(vBuff,vJobName);
   --dbms_output.put_line(vBuff);
END load;

PROCEDURE mass_load(inBegDate IN DATE,inEndDate IN DATE,inSign IN VARCHAR2,inAnltCode IN VARCHAR2,inPrepareSegments NUMBER)
  IS
    vMes VARCHAR2(2000);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vTIBegin DATE;
    vHistFlg NUMBER;
    vMassSQL CLOB;
    vMassDDL CLOB;
    --
    vHistTable VARCHAR2(256);
    vFctTable VARCHAR2(256);
    vTmpTable VARCHAR2(256);
    vHistATable VARCHAR2(256);
    vFctATable VARCHAR2(256);
    vTmpATable VARCHAR2(256);
    vSPCode VARCHAR2(30);
    vBuff VARCHAR2(32700);
    vMAsk VARCHAR2(30);
    --
    vRowCount INTEGER := 0;
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  vMes := 'START :: Procedure "'||lower(vOwner)||'.pkg_etl_ctr_signs.mass_load" started.';
  pr_log_write(lower(vOwner)||'.pkg_etl_ctr_signs.mass_load',vMes);

  EXECUTE IMMEDIATE 'alter session set "_FIX_CONTROL" = "11814428:0"';

  BEGIN
    SELECT p.hist_flg,p.mass_sql,p.sp_code
          ,UPPER(vOwner||'.'||e.hist_table_name) AS hist_table_name
          ,UPPER(vOwner||'.'||e.fct_table_name) AS fct_table_name
          ,UPPER(vOwner||'.'||e.tmp_table_name) AS tmp_table_name
          ,UPPER(vOwner||'.'||ae.fct_table_name) AS fct_a_table_name
          ,UPPER(vOwner||'.'||ae.hist_table_name) AS hist_a_table_name
          ,UPPER(vOwner||'.'||ae.tmp_table_name) AS tmp_a_table_name
      INTO vHistFlg,vMassSQL,vSPCode,vHistTable,vFctTable,vTmpTable,vFctATable,vHistATable,vTmpATable
      FROM tb_signs_pool p
           INNER JOIN tb_entity e
             ON e.id = p.entity_id
           LEFT JOIN tb_sign_2_anlt s2a
             ON s2a.sign_name = p.sign_name
                AND s2a.anlt_code = UPPER(inAnltCode)
           LEFT JOIN tb_signs_anlt a
             ON a.anlt_code = s2a.anlt_code
                AND inEndDate BETWEEN a.effective_start AND a.effective_end
           LEFT JOIN tb_entity ae
             ON ae.id = a.entity_id
      WHERE p.sign_name = UPPER(inSign);
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Показатель "'||UPPER(inSign)||'" не найден в таблице '||lower(vOwner)||'.tb_signs_pool');
  END;

  -- Установка архивного флага в таблице показателей (чтобы не было пересечения с ежедневной
  -- загрузкой. Ежедневка смотрит на этот флаг и если 1, то не расчитывает показатель)
  vBuff :=
  'BEGIN'||CHR(10)||
  '  UPDATE '||lower(vOwner)||'.tb_signs_pool SET archive_flg = 1 WHERE sign_name = '''||UPPER(inSign)||''';'||CHR(10)||
  '  COMMIT;'||CHR(10)||
  'END;';
  BEGIN
    EXECUTE IMMEDIATE vBuff;
  EXCEPTION WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20000,'ERROR :: UPD_1');
  END;

 -- Загрузка данных
 IF inPrepareSegments = 1 AND vMassSQL IS NOT NULL AND vHistFlg = 1 AND inAnltCode IS NULL THEN
   -- Если в "HIST" показателе заполнено поле MASS_SQL, то используем его для быстрой заливки

   -- Подготовка субпартиций в промежуточной таблице
   vBuff := 'ALTER TABLE '||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||' DROP PARTITION '||UPPER(inSign);
   BEGIN
     EXECUTE IMMEDIATE vBuff;
   EXCEPTION WHEN OTHERS THEN
     NULL;
   END;

   vBuff := 'ALTER TABLE '||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||' ADD PARTITION '||UPPER(inSign)||' VALUES('''||UPPER(inSign)||''') NOLOGGING STORAGE(INITIAL 64K NEXT 4M) (SUBPARTITION '||vSPCode||'_NEW VALUES LESS THAN (MAXVALUE))';
   EXECUTE IMMEDIATE vBuff;
   -- Окончание подготовки субпартиций в промежуточной таблице

   -- Вставка данных в промежуточную таблицу
   vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - вставка данных во временную таблицу --------';
   pr_log_write(lower(vOwner)||'.pkg_etl_signs.mass_load',vMes);

   vTIBegin := SYSDATE;
   dbms_lob.createtemporary(vMassDDL,FALSE);
   vBuff :=
   'BEGIN'||CHR(10)||
   '  INSERT /*+ APPEND */ INTO '||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||CHR(10)||
   '   (effective_start,effective_end,obj_gid,source_system_id,sign_name,sign_val)'||CHR(10);
   dbms_lob.writeappend(vMassDDL,LENGTH(vBuff),vBuff);

   vMassDDL := vMassDDL||vMassSQL||';'||CHR(10);

   vBuff :=
   ' :1 := SQL%ROWCOUNT;'||CHR(10)||
   'COMMIT;'||CHR(10)||'END;';
   dbms_lob.writeappend(vMassDDL,LENGTH(vBuff),vBuff);

   BEGIN
     EXECUTE IMMEDIATE vMassDDL USING OUT vRowCount;
     --dbms_output.put_line(vMassDDL);
     vEndTime := SYSDATE;
     vMes := 'SUCCESSFULLY :: "'||UPPER(inSign)||'" - '||vRowCount||' rows inserted into "'||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||'" in '||get_ti_as_hms(vEndTime - vTIBegin);
     pr_log_write(lower(vOwner)||'.pkg_etl_signs.mass_load',vMes);
   EXCEPTION WHEN OTHERS THEN
     vEndTime := SYSDATE;
     vMes := 'ERROR :: "'||UPPER(inSign)||'" not inserted into "'||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||'" in '||get_ti_as_hms(vEndTime - vTIBegin)||' with errors :: '||SQLERRM||CHR(10)||'------'||CHR(10)||dbms_lob.substr(vMassDDL,3000);
     pr_log_write(lower(vOwner)||'.pkg_etl_signs.mass_load',vMes);
   END;

   vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - окончание вставки данных во временную таблицу. Время выполнения - '||get_ti_as_hms(vEndTime - vTIBegin);
   pr_log_write(lower(vOwner)||'.pkg_etl_signs.mass_load',vMes);

   -- Склеивание в целевую таблицу
   sign_gluing(UPPER(inSign),UPPER(inAnltCode),'011');

  ELSE
    IF vHistFlg = 0 THEN -- для "FCT" показателей
      vTIBegin := SYSDATE;
      vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - загрузка данных --------';
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.mass_load',vMes);

      vMes := CheckSubpartition(inBegDate,inEndDate,UPPER(inSign),UPPER(inAnltCode));
      -- Сохранение времени  подготовки в таблицу статистики расчетов
      /*vEndTime := SYSDATE;
      INSERT INTO tb_signs_calc_stat (sign_name,anlt_code,action,sec)
        VALUES(inSign,inAnltCode,'PREPARE',ROUND((vEndTime - vTIBegin)*24*60*60/(inEndDate - inBegDate),1));*/

      --mass_load_parallel_by_date_pe(inBegDate,inEndDate,lower(vOwner)||'.pkg_etl_signs.load_sign','VARCHAR2 '||UPPER(inSign)||'::VARCHAR2 '||inAnltCode);
      mass_load_parallel_by_month(inBegDate,inEndDate,lower(vOwner)||'.pkg_etl_signs.load_sign','VARCHAR2 '||UPPER(inSign)||'::VARCHAR2 '||UPPER(inAnltCode)||'::NUMBER 0');

      vEndTime := SYSDATE;
      vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - окончание загрузки данных. Время выполнения - '||get_ti_as_hms(vEndTime - vTIBegin);
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.mass_load',vMes);
    ELSE -- для "HIST" показателей
      vMask := '11'||'0'||'100';
      tb_load_mass(inBegDate,inEndDate,UPPER(inSign),inAnltCode,vMask);
    END IF;
  END IF;
  -- Возврат архивного флага в исходную
  vBuff :=
  'BEGIN'||CHR(10)||
  '  UPDATE tb_signs_pool SET archive_flg = 0 WHERE sign_name = '''||UPPER(inSign)||''';'||CHR(10)||
  '  COMMIT;'||CHR(10)||
  'END;';
  EXECUTE IMMEDIATE vBuff;

  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.mass_load" finished in '||get_ti_as_hms(vEndTime - vBegTime)||' successfully';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.mass_load',vMes);
EXCEPTION WHEN OTHERS THEN
  vEndTime := SYSDATE;
  vMes := 'ERROR :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.mass_load" :: '||SQLERRM||Chr(10)||vBuff;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.mass_load',vMes);
  vMes := 'FINISH :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.mass_load" finished in '||get_ti_as_hms(vEndTime - vBegTime)||' with errors.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.mass_load',vMes);
END mass_load;

PROCEDURE sign_gluing(inSign IN VARCHAR2,inAnltCode IN VARCHAR2,inMask IN VARCHAR2 DEFAULT '111')
 IS
   vBegTime DATE := SYSDATE;
   vEndTime DATE;
   vTIBegin DATE;
   vMes VARCHAR2(32700);
   vSPCode VARCHAR2(256);
   vHistTable VARCHAR2(256);
   vTmpTable VARCHAR2(256);
   vHistFlg NUMBER;
   vHistATable VARCHAR2(256);
   vTmpATable VARCHAR2(256);
   vBuff VARCHAR2(32700);
   vCou INTEGER := 0;
   vMask VARCHAR2(256) := NVL(inMask,'111');
   vTmpStage BOOLEAN := SUBSTR(vMask,1,1) = '1';
   vTargetStage BOOLEAN := SUBSTR(vMask,2,1) = '1';
   vTargetTruncate BOOLEAN := SUBSTR(vMask,3,1) = '1';
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  vMes := 'START :: "'||inSign||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.sign_gluing" started.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.sign_gluing',vMes);
  -- Получение метаданных
  BEGIN
    SELECT p.sp_code
          ,UPPER(vOwner||'.'||e.tmp_table_name) AS tmp_table_name
          ,UPPER(vOwner||'.'||e.hist_table_name) AS hist_table_name
          ,p.hist_flg
          ,UPPER(vOwner||'.'||ae.tmp_table_name) AS tmp_a_table_name
          ,UPPER(vOwner||'.'||ae.hist_table_name) AS hist_a_table_name
      INTO vSPCode
          ,vTmpTable
          ,vHistTable
          ,vHistFlg
          ,vTmpATable
          ,vHistATable
      FROM tb_signs_pool p
           INNER JOIN tb_entity e
             ON e.id = p.entity_id
           LEFT JOIN tb_sign_2_anlt s2a
             ON s2a.sign_name = p.sign_name
                AND s2a.anlt_code = UPPER(inAnltCode)
           LEFT JOIN tb_signs_anlt a
             ON a.anlt_code = s2a.anlt_code
                AND SYSDATE BETWEEN a.effective_start AND a.effective_end
           LEFT JOIN tb_entity ae
             ON ae.id = a.entity_id
      WHERE p.sign_name = UPPER(inSign);
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Показатель "'||inSign||'" не найден в таблице '||lower(vOwner)||'.tb_signs_pool');
  END;

  IF vTmpStage THEN
    vTIBegin := SYSDATE;
    vMes := 'CONTINUE :: ------ Вставка '||UPPER(inSign)||' во временную таблицу ------';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.sign_gluing',vMes);

    vBuff := 'ALTER TABLE '||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||' TRUNCATE PARTITION '||UPPER(inSign);
    BEGIN
      EXECUTE IMMEDIATE vBuff;
      --dbms_output.put_line(vBuff);

      vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||'" - Partition '||UPPER(inSign)||' truncated';
    EXCEPTION WHEN OTHERS THEN
      vBuff := 'ALTER TABLE '||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||' ADD PARTITION '||UPPER(inSign)||' VALUES('''||UPPER(inSign)||''') STORAGE (INITIAL 64K NEXT 4M) NOLOGGING';
      BEGIN
        EXECUTE IMMEDIATE vBuff;
        vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||'" - Partition '||UPPER(inSign)||' added';
      EXCEPTION WHEN OTHERS THEN
       vMes := 'ERROR :: Table "'||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||'" - Partition '||UPPER(inSign)||' not proccessed :: '||SQLERRM;
      END;
    END;
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.sign_gluing',vMes);

    vBuff :=
    'BEGIN'||CHR(10)||
    '  INSERT /*+ APPEND */ INTO '||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||' (effective_start,effective_end,obj_gid,source_system_id,sign_name,sign_val)'||CHR(10)||
    '    SELECT effective_start,effective_end,obj_gid,source_system_id,sign_name,sign_val'||CHR(10)||
    '      FROM '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||' WHERE sign_name = :1;'||CHR(10)||
    '  :2 := SQL%ROWCOUNT;'||CHR(10)||
    '  COMMIT;'||CHR(10)||
    'END;';
    BEGIN
      EXECUTE IMMEDIATE vBuff USING IN UPPER(inSign),OUT vCou;
      --dbms_output.put_line(vBuff);

      vEndTime := SYSDATE;
      vMes := 'SUCCESSFULLY :: "'||UPPER(inSign)||'" - '||vCou||' rows inserted into table "'||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||'" in '||get_ti_as_hms(vEndTime - vTIBegin);
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.sign_gluing',vMes);
    EXCEPTION WHEN OTHERS THEN
      vEndTime := SYSDATE;
      vMes := 'ERROR :: Table "'||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||'" - "'||UPPER(inSign)||'" not inserted :: '||SQLERRM;
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.sign_gluing',vMes);
    END;

    vMes := 'CONTINUE :: ------ Окончание вставки '||UPPER(inSign)||' во временную таблицу. Время выполнения '||get_ti_as_hms(vEndTime - vTIBegin)||' ------';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.sign_gluing',vMes);
  END IF;
  -------
  IF vTargetStage THEN
    vTIBegin := SYSDATE;
    vMes := 'CONTINUE :: ------ Склеивание '||UPPER(inSign)||' в целевую таблицу ------';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.sign_gluing',vMes);

    IF vTargetTruncate THEN
      vBuff := 'ALTER TABLE '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||' TRUNCATE PARTITION '||UPPER(inSign);
      BEGIN
        EXECUTE IMMEDIATE vBuff;
        --dbms_output.put_line(vBuff);

        vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'" - Partition '||UPPER(inSign)||' truncated';
      EXCEPTION WHEN OTHERS THEN
        vMes := 'ERROR :: Table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'" - Partition '||UPPER(inSign)||' not truncated :: '||SQLERRM;
      END;
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.sign_gluing',vMes);
    END IF;

    vBuff :=
    'BEGIN'||CHR(10)||
    '  INSERT INTO '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||' (effective_start,effective_end,obj_gid,source_system_id,sign_name,sign_val)'||CHR(10)||
    '    SELECT MIN(effective_start) AS effective_start'||CHR(10)||
    '          ,effective_end    '||CHR(10)||
    '          ,obj_gid'||CHR(10)||
    '          ,source_system_id'||CHR(10)||
    '          ,sign_name'||CHR(10)||
    '          ,sign_val '||CHR(10)||
    '      FROM ('||CHR(10)||
    '        SELECT effective_start'||CHR(10)||
    '              ,NVL2(NVL2(LEAD(next_start) OVER (PARTITION BY obj_gid,source_system_id ORDER BY effective_start)'||CHR(10)||
    '                        ,LEAD(effective_start) OVER (PARTITION BY obj_gid,source_system_id ORDER BY effective_start) - 1'||CHR(10)||
    '                        ,LEAD(effective_end) OVER (PARTITION BY obj_gid,source_system_id ORDER BY effective_start))'||CHR(10)||
    '                   ,CASE WHEN next_start - effective_end = 1 THEN'||CHR(10)||
    '                      CASE WHEN '||lower(vOwner)||'.pkg_etl_signs.isEqual(LEAD(sign_val) OVER (PARTITION BY obj_gid,source_system_id ORDER BY effective_start), sign_val) = 1'||CHR(10)||
    '                             THEN LEAD(effective_end) OVER (PARTITION BY obj_gid,source_system_id ORDER BY effective_start)'||CHR(10)||
    '                        ELSE LEAD(effective_start) OVER (PARTITION BY obj_gid,source_system_id ORDER BY effective_start) - 1'||CHR(10)||
    '                      END'||CHR(10)||
    '                      ELSE effective_end'||CHR(10)||
    '                    END'||CHR(10)||
    '                   ,effective_end'||CHR(10)||
    '                   ) AS effective_end'||CHR(10)||
    '              ,obj_gid'||CHR(10)||
    '              ,source_system_id'||CHR(10)||
    '              ,sign_name'||CHR(10)||
    '              ,sign_val'||CHR(10)||
    '          FROM (SELECT /*+ no_index(s) */'||CHR(10)||
    '                       obj_gid'||CHR(10)||
    '                      ,source_system_id'||CHR(10)||
    '                      ,effective_start'||CHR(10)||
    '                      ,effective_end'||CHR(10)||
    '                      ,LEAD(effective_start) OVER (PARTITION BY obj_gid,source_system_id ORDER BY effective_start) AS next_start'||CHR(10)||
    '                      ,sign_name'||CHR(10)||
    '                      ,sign_val'||CHR(10)||
    '                      ,CASE WHEN '||lower(vOwner)||'.pkg_etl_signs.isEqual(LAG(sign_val) OVER (PARTITION BY obj_gid,source_system_id ORDER BY effective_start), sign_val) = 0'||CHR(10)||
    '                                 OR effective_start - LAG(effective_end) OVER (PARTITION BY obj_gid,source_system_id ORDER BY effective_start) > 1'||CHR(10)||
    '                                 OR LEAD(effective_start) OVER (PARTITION BY obj_gid,source_system_id ORDER BY effective_start) - effective_end > 1'||CHR(10)||
    '                                 OR NVL(LEAD(effective_start) OVER (PARTITION BY obj_gid,source_system_id ORDER BY effective_start),to_date(''31.12.5999'',''DD.MM.YYYY'')) - effective_end > 1'||CHR(10)||
    '                                 OR effective_start - NVL(LAG(effective_end) OVER (PARTITION BY obj_gid,source_system_id ORDER BY effective_start),to_date(''01.01.0001'',''DD.MM.YYYY'')) > 1'||CHR(10)||
    '                                 OR effective_end = to_date(''31.12.5999'',''DD.MM.YYYY'')'||CHR(10)||
    '                              THEN 1'||CHR(10)||
    '                       ELSE 0'||CHR(10)||
    '                       END AS flg'||CHR(10)||
    '                  FROM '||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||' s'||CHR(10)||
    '                  WHERE sign_name = :1'||CHR(10)||
    '          ) WHERE flg = 1'||CHR(10)||
    '    ) WHERE effective_end IS NOT NULL AND sign_val IS NOT NULL'||CHR(10)||
    '  GROUP BY obj_gid'||CHR(10)||
    '          ,source_system_id'||CHR(10)||
    '          ,effective_end'||CHR(10)||
    '          ,sign_name'||CHR(10)||
    '          ,sign_val;'||CHR(10)||
    '  :2 := SQL%ROWCOUNT;'||CHR(10)||
    '  COMMIT;'||CHR(10)||
    ' END;';
    BEGIN
      EXECUTE IMMEDIATE vBuff USING IN UPPER(inSign),OUT vCou;
      --dbms_output.put_line(vBuff);

      -- Сохранение времени расчета в таблицу статистики расчетов
      /*
      INSERT INTO tb_signs_calc_stat (sign_name,anlt_code,action,sec)
        VALUES(inSign,inAnltCode,'GLUING',(vEndTime - vTIBegin)*24*60*60);*/

      vEndTime := SYSDATE;
      vMes := 'SUCCESSFULLY :: "'||UPPER(inSign)||'" - '||vCou||' rows inserted into table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'" in '||get_ti_as_hms(vEndTime - vTIBegin);
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.sign_gluing',vMes);
    EXCEPTION WHEN OTHERS THEN
      vEndTime := SYSDATE;
      vMes := 'ERROR :: Table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'" - "'||UPPER(inSign)||'" not inserted :: '||SQLERRM;
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.sign_gluing',vMes);
    END;

    -- Удаление временной партиции
    vBuff := 'ALTER TABLE '||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||' DROP PARTITION '||UPPER(inSign);
    BEGIN
      EXECUTE IMMEDIATE vBuff;
      vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||'" - Partition '||UPPER(inSign)||' dropped';
    EXCEPTION WHEN OTHERS THEN
      vMes := 'ERROR :: Table "'||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||'" - Partition '||UPPER(inSign)||' not dropped :: '||SQLERRM;
    END;
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.sign_gluing',vMes);

    vMes := 'CONTINUE :: ------ Окончание склеивания '||UPPER(inSign)||' в целевую таблицу. Время выполнения: '||get_ti_as_hms(vEndTime - vTIBegin)||'------';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.sign_gluing',vMes);

    HistTableService(CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END,'111',inSign);

  END IF;

  vEndTime := SYSDATE;
  vMes := 'FINISH :: "'||inSign||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.sign_gluing" finished in '||get_ti_as_hms(vEndTime - vBegTime)||' successfully';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.sign_gluing',vMes);
EXCEPTION WHEN OTHERS THEN
  vEndTime := SYSDATE;
  vMes := 'ERROR :: Procedure "'||lower(vOwner)||'.pkg_etl_ctr_signs.sign_gluing" :: '||SQLERRM||Chr(10)||vBuff;
  pr_log_write(lower(vOwner)||'.pkg_etl_ctr_signs.sign_gluing',vMes);
  vMes := 'FINISH :: Procedure "'||lower(vOwner)||'.pkg_etl_ctr_signs.sign_gluing" finished in '||get_ti_as_hms(vEndTime - vBegTime)||' with errors.';
  pr_log_write(lower(vOwner)||'.pkg_etl_ctr_signs.sign_gluing',vMes);
END sign_gluing;

PROCEDURE tmp_load_prev(inBegDate IN DATE,inEndDate IN DATE,inSign IN VARCHAR2,inAnltCode IN VARCHAR2)
  IS
    vDays INTEGER;
    vMes VARCHAR2(4000);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    --
    vTmpTable VARCHAR2(256);
    vTmpATable VARCHAR2(256);
    vCou INTEGER := 0;
    vBuff VARCHAR2(32700);
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  vDays := inEndDate - inBegDate;
  BEGIN
    SELECT UPPER(vOwner||'.'||e.tmp_table_name) AS tmp_table_name
          ,UPPER(vOwner||'.'||ae.tmp_table_name) AS tmp_a_table_name
      INTO vTmpTable,vTmpATable
      FROM tb_signs_pool p
           INNER JOIN tb_entity e
             ON e.id = p.entity_id
           LEFT JOIN tb_sign_2_anlt s2a
             ON s2a.sign_name = p.sign_name
                AND s2a.anlt_code = UPPER(inAnltCode)
           LEFT JOIN tb_signs_anlt a
             ON a.anlt_code = s2a.anlt_code
                AND inEndDate BETWEEN a.effective_start AND a.effective_end
           LEFT JOIN tb_entity ae
             ON ae.id = a.entity_id
      WHERE p.sign_name = UPPER(inSign);
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Показатель "'||UPPER(inSign)||'" не найден в таблице '||lower(vOwner)||'.tb_signs_pool');
  END;

  FOR idx IN 0..vDays
  LOOP
    vMes := 'CONTINUE :: "'||to_char(inBegDate+idx,'DD.MM.YYYY')||'" - "'||UPPER(inSign)||'" - loading started';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tmp_load_prev',vMes);

    vBuff :=
    'BEGIN'||CHR(10)||
    '  INSERT INTO '||lower(CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END)||' (effective_start,effective_end,obj_gid,source_system_id,sign_name,sign_val)'||CHR(10)||
    '     SELECT :1,last_day(:1),obj_gid,source_system_id,sign_name,sign_val'||CHR(10)||
    CASE WHEN inAnltCode IS NULL THEN
    '       FROM TABLE('||lower(vOwner)||'.pkg_etl_signs.get_sign(:2,:1)) WHERE sign_val IS NOT NULL;'||CHR(10)
    ELSE
    '       FROM TABLE('||lower(vOwner)||'.pkg_etl_signs.get_sign_anlt(:2,:1,:3,'||CASE WHEN UPPER(inSign) = UPPER(inAnltCode) THEN '1' ELSE '0' END||')) WHERE sign_val IS NOT NULL;'||CHR(10)
    END||
    CASE WHEN inAnltCode IS NULL THEN ':3 := SQL%ROWCOUNT;' ELSE ':4 := SQL%ROWCOUNT;' END||CHR(10)||
    'COMMIT;'||CHR(10)||
    'END;';

    BEGIN
      IF inAnltCode IS NULL THEN
        EXECUTE IMMEDIATE vBuff USING IN inBegDate+idx
               ,IN UPPER(inSign)
               ,OUT vCou;
      ELSE
        EXECUTE IMMEDIATE vBuff USING IN inBegDate+idx
               ,IN UPPER(inSign)
               ,IN UPPER(inAnltCode)
               ,OUT vCou;
      END IF;
      --dbms_output.put_line(vBuff);
    EXCEPTION WHEN OTHERS THEN
      vMes := 'ERROR :: "'||to_char(inBegDate+idx,'DD.MM.YYYY')||'" :: '||SQLERRM||Chr(10);
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.tmp_load_prev',vMes);
    END;

    vEndTime := SYSDATE;
    vMes := 'SUCCESSFULLY :: "'||to_char(inBegDate+idx,'DD.MM.YYYY')||'" - "'||UPPER(inSign)||'" '||vCou||' rows inserted into table "'||lower(CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END)||'" in '||get_ti_as_hms(vEndTime - vBegTime);
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tmp_load_prev',vMes);
  END LOOP;
END tmp_load_prev;

PROCEDURE tmp_load_daily(inBegDate IN DATE,inEndDate IN DATE,inSign VARCHAR2,inAnltCode IN VARCHAR2)
  IS
    vDays INTEGER;
    vMes VARCHAR2(32700);
    vEndTime DATE;
    vTIBegin DATE;
    --
    vTmpTable VARCHAR2(256);
    vTmpATable VARCHAR2(256);
    vBuff VARCHAR2(32700);
    vSQL CLOB;
    vCou INTEGER := 0;
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  vDays := inEndDate - inBegDate;
  -- Получение наименования таблицы для загрузки
  BEGIN
    SELECT UPPER(vOwner||'.'||e.tmp_table_name) AS tmp_table_name
          ,UPPER(vOwner||'.'||ae.tmp_table_name) AS tmp_a_table_name
      INTO vTmpTable,vTmpATable
      FROM tb_signs_pool p
           INNER JOIN tb_entity e
             ON e.id = p.entity_id
           LEFT JOIN tb_sign_2_anlt s2a
             ON s2a.sign_name = p.sign_name
                AND s2a.anlt_code = UPPER(inAnltCode)
           LEFT JOIN tb_signs_anlt a
             ON a.anlt_code = s2a.anlt_code
                AND inEndDate BETWEEN a.effective_start AND a.effective_end
           LEFT JOIN tb_entity ae
             ON ae.id = a.entity_id
      WHERE p.sign_name = UPPER(inSign);
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Показатель "'||inSign||'" не найден в таблице '||lower(vOwner)||'.tb_signs_pool');
  END;

  FOR days IN 0..vDays LOOP
    vTIBegin := SYSDATE;
    dbms_lob.createtemporary(vSQL,FALSE);
    vBuff :=
    'DECLARE'||CHR(10)||
    '  vStr VARCHAR2(4000);'||CHR(10)||
    '  vCou INTEGER := 0;'||CHR(10)||
    '  vLogged BOOLEAN := FALSE;'||CHR(10)||
    'BEGIN'||CHR(10)||
    'EXECUTE IMMEDIATE ''ALTER SESSION SET nls_date_format = ''''DD.MM.RRRR HH24:MI:SS'''''';'||CHR(10)||
    'FOR idx IN ('||CHR(10)||
    '  SELECT /*+ LEADING(SRC) NO_INDEX(DEST)*/'||CHR(10)||
    '         :1 AS SRC_EFFECTIVE_START,'||CHR(10)||
    '         last_day(:1) AS SRC_EFFECTIVE_END,'||CHR(10)||
    '         SRC.OBJ_GID AS SRC_OBJ_GID,'||CHR(10)||
    '         SRC.SOURCE_SYSTEM_ID AS SRC_SOURCE_SYSTEM_ID,'||CHR(10)||
    '         SRC.SIGN_NAME AS SRC_SIGN_NAME,'||CHR(10)||
    '         SRC.SIGN_VAL AS SRC_SIGN_VAL,'||CHR(10)||
    '         DEST.SIGN_NAME AS D_SIGN_NAME,'||CHR(10)||
    '         DEST.EFFECTIVE_START AS D_EFFECTIVE_START,'||CHR(10)||
    '         DEST.SIGN_VAL AS D_SIGN_VAL'||CHR(10)||
    CASE WHEN inAnltCode IS NULL THEN
    '     FROM TABLE('||lower(vOwner)||'.pkg_etl_signs.get_sign(:2,:1)) src'||CHR(10)
    ELSE
    '     FROM TABLE('||lower(vOwner)||'.pkg_etl_signs.get_sign_anlt(:2,:1,:3,'||CASE WHEN UPPER(inSign) = UPPER(inAnltCode) THEN '1' ELSE '0' END||')) src'||CHR(10)
    END||
    '          LEFT JOIN '||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||' DEST'||CHR(10)||
    '            ON DEST.SIGN_NAME = :2'||CHR(10)||
    '               AND last_day(:1) = DEST.EFFECTIVE_END'||CHR(10)||
    '               AND DEST.OBJ_GID = SRC.OBJ_GID'||CHR(10)||
    '               AND DEST.SOURCE_SYSTEM_ID = SRC.SOURCE_SYSTEM_ID'||CHR(10)||
    '     WHERE '||UPPER(vOwner)||'.PKG_ETL_SIGNS.ISEQUAL(DEST.SIGN_VAL, SRC.SIGN_VAL) = 0'||CHR(10)||
    ') LOOP';
    dbms_lob.writeappend(vSQL,LENGTH(vBuff),vBuff);
    vBuff :=
    '  BEGIN'||CHR(10)||
    '      vStr := ''Upd|''||idx.src_sign_name;'||CHR(10)||
    '      UPDATE '||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||CHR(10)||
    '        SET effective_end = idx.src_effective_start - 1'||CHR(10)||
    '        WHERE sign_name = UPPER(idx.src_sign_name)'||CHR(10)||
    '          AND effective_end = idx.src_effective_end'||CHR(10)||
    '          AND obj_gid = idx.src_obj_gid'||CHR(10)||
    '          AND source_system_id = idx.src_source_system_id;'||CHR(10)||
    '      IF idx.src_sign_val IS NOT NULL THEN'||CHR(10)||
    '        vStr := ''Ins|''||idx.src_sign_name;'||CHR(10)||
    '        INSERT INTO '||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||' (effective_start,effective_end,obj_gid,source_system_id,sign_name,sign_val)'||CHR(10)||
    '          VALUES (idx.src_effective_start'||CHR(10)||
    '                 ,idx.src_effective_end'||CHR(10)||
    '                 ,idx.src_obj_gid'||CHR(10)||
    '                 ,idx.src_source_system_id'||CHR(10)||
    '                 ,UPPER(idx.src_sign_name)'||CHR(10)||
    '                 ,idx.src_sign_val);'||CHR(10)||
    '      END IF;'||CHR(10)||
    '  EXCEPTION WHEN OTHERS THEN'||CHR(10)||
    '    IF NOT vLogged THEN'||CHR(10)||
    '      vStr := ''ERROR :: "'||UPPER(inSign)||'" - "''||to_char(idx.src_effective_start,''DD.MM.YYYY'')||''" - OBJ_SID = ''||idx.src_obj_gid*10+idx.src_source_system_id||'' :: ''||SQLERRM||Chr(10)||vStr;'||CHR(10)||
    '      '||lower(vOwner)||'.pkg_etl_signs.pr_log_write('''||lower(vOwner)||'.pkg_etl_signs.tmp_load_daily'',vStr);'||CHR(10)||
    '      vLogged := TRUE;'||CHR(10)||
    '    END IF;'||CHR(10)||
    '  END;'||CHR(10)||
    '  vCou := vCou + 1;'||CHR(10)||
    'END LOOP;'||CHR(10)||
    CASE WHEN inAnltCode IS NULL THEN ':3 := vCou;' ELSE ':4 := vCou;' END||CHR(10)||
    'COMMIT;'||CHR(10)||
    'END;';
    dbms_lob.writeappend(vSQL,LENGTH(vBuff),vBuff);
    IF inAnltCode IS NULL THEN
      EXECUTE IMMEDIATE vSQL USING IN inBegDate+days
             ,IN UPPER(inSign)
             ,OUT vCou;
    ELSE
      EXECUTE IMMEDIATE vSQL USING IN inBegDate+days
             ,IN UPPER(inSign)
             ,IN UPPER(inAnltCode)
             ,OUT vCou;
    END IF;
    vEndTime := SYSDATE;
    vMes := 'SUCCESSFULLY :: "'||UPPER(inSign)||'" - "'||to_char(inBegDate + days,'DD.MM.YYYY')||'" - '||vCou||' rows proccessed in table "'||lower(CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END)||'" in '||get_ti_as_hms(vEndTime - vTIBegin);
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tmp_load_daily',vMes);
    dbms_lob.freetemporary(vSQL);
  END LOOP;
EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: "'||UPPER(inSign)||'" - "'||to_char(inBegDate,'DD.MM.YYYY')||'" :: '||SQLERRM||Chr(10);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.tmp_load_daily',vMes);
END tmp_load_daily;

PROCEDURE tb_upd_eff_end(inSign IN VARCHAR2,inAnltCode IN VARCHAR2,inDate IN DATE DEFAULT NULL)
  IS
    vMes VARCHAR2(32700);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    --
    vHistTable VARCHAR2(256);
    vHistATable VARCHAR2(256);
    vBuff VARCHAR2(32700);
    vCou INTEGER := 0;
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  vMes := 'START :: "'||UPPER(inSign)||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.tb_upd_eff_end" started.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.load_sign',vMes);
  -- Получение наименования таблицы для апдейта
  BEGIN
    SELECT UPPER(vOwner||'.'||e.hist_table_name) AS hist_table_name
          ,UPPER(vOwner||'.'||ae.hist_table_name) AS hist_a_table_name
      INTO vHistTable,vHistATable
      FROM tb_signs_pool p
           INNER JOIN tb_entity e
             ON e.id = p.entity_id
           LEFT JOIN tb_sign_2_anlt s2a
             ON s2a.sign_name = p.sign_name
                AND s2a.anlt_code = UPPER(inAnltCode)
           LEFT JOIN tb_signs_anlt a
             ON a.anlt_code = s2a.anlt_code
                AND SYSDATE BETWEEN a.effective_start AND a.effective_end
           LEFT JOIN tb_entity ae
             ON ae.id = a.entity_id
      WHERE p.sign_name = UPPER(inSign);
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Показатель "'||inSign||'" не найден в таблице '||lower(vOwner)||'.tb_signs_pool');
  END;
  vBuff :=
  'DECLARE'||CHR(10)||
  '  vCou INTEGER := 0;'||CHR(10)||
  'BEGIN'||CHR(10)||
  '  FOR idx IN ('||CHR(10)||
  CASE WHEN inDate IS NULL THEN
    '    SELECT sign_name,obj_gid,source_system_id,MAX(effective_end) AS effective_end'||CHR(10)||
    '      FROM '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||CHR(10)||
    '      WHERE sign_name = :1'||CHR(10)||
    '    GROUP BY sign_name,obj_gid,source_system_id'||CHR(10)||
    '    HAVING MAX(effective_end) != to_date(''31.12.5999'',''DD.MM.YYYY'')'||CHR(10)
  ELSE
    'WITH'||CHR(10)||
    '  a AS ('||CHR(10)||
    '    SELECT /*+ no_index(c)*/'||CHR(10)||
    '           obj_gid,source_system_id'||CHR(10)||
    '      FROM '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||' c'||CHR(10)||
    '      WHERE sign_name = :1'||CHR(10)||
    '        AND effective_end = to_date(:2,''DD.MM.RRRR'')'||CHR(10)||
    '    MINUS'||CHR(10)||
    '    SELECT obj_gid,source_system_id'||CHR(10)||
    '      FROM '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||CHR(10)||
    '      WHERE sign_name = :1'||CHR(10)||
    '        AND effective_start > to_date(:2,''DD.MM.RRRR''))'||CHR(10)||
    'SELECT /*+ no_index(s) */'||CHR(10)||
    '       sign_name,obj_gid,source_system_id,effective_end'||CHR(10)||
    '  FROM '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||' s'||CHR(10)||
    '  WHERE sign_name = :1'||CHR(10)||
    '    AND effective_end = to_date(:2,''DD.MM.RRRR'')'||CHR(10)||
    '    AND (obj_gid,source_system_id) IN (SELECT obj_gid,source_system_id FROM a)'||CHR(10)

  END||
  '  ) LOOP'||CHR(10)||
  '    UPDATE '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||CHR(10)||
  '      SET effective_end = to_date(''31.12.5999'',''DD.MM.YYYY'')'||CHR(10)||
  '      WHERE sign_name = idx.sign_name'||CHR(10)||
  '        AND obj_gid = idx.obj_gid'||CHR(10)||
  '        AND source_system_id = idx.source_system_id'||CHR(10)||
  '        AND effective_end = idx.effective_end;'||CHR(10)||
  '    vCou := vCou + 1;'||CHR(10)||
  '  END LOOP;'||CHR(10)||
  '  COMMIT;'||CHR(10)||
  CASE WHEN inDate IS NOT NULL THEN '  :3 := vCou;' ELSE '  :2 := vCou;' END||CHR(10)||
  'END;';

  IF inDate/*inAnltCode*/ IS NULL THEN
    EXECUTE IMMEDIATE vBuff USING IN UPPER(inSign),OUT vCou;
  ELSE
    EXECUTE IMMEDIATE vBuff USING IN UPPER(inSign),IN to_char(inDate,'DD.MM.RRRR'),OUT vCou;
  END IF;

  vEndTime := SYSDATE;
  vMes := 'SUCCESSFULLY :: "'||UPPER(inSign)||'" - EFFECTIVE_END -> "31.12.5999" - '||vCou||' rows proccessed in table "'||lower(vHistTable)||'" in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_upd_eff_end',vMes);
  vMes := 'FINISH :: "'||inSign||'" - EFFECTIVE_END -> "31.12.5999" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.tb_upd_eff_end" finished in '||get_ti_as_hms(vEndTime - vBegTime)||' successfully';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_upd_eff_end',vMes);
EXCEPTION WHEN OTHERS THEN
  vEndTime := SYSDATE;
  vMes := 'ERROR :: "'||UPPER(inSign)||'"  - EFFECTIVE_END -> "31.12.5999" :: '||SQLERRM||Chr(10)||vBuff;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_upd_eff_end',vMes);
  vMes := 'FINISH :: "'||inSign||'" - EFFECTIVE_END -> "31.12.5999" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.tb_upd_eff_end" finished in '||get_ti_as_hms(vEndTime - vBegTime)||' with errors';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_upd_eff_end',vMes);
END tb_upd_eff_end;

PROCEDURE tb_load_mass(inBegDate IN DATE,inEndDate IN DATE,inSign IN VARCHAR2,inAnltCode IN VARCHAR2
  ,inMask IN VARCHAR2 DEFAULT '111111')
  IS
    vMes VARCHAR2(4000);
    vTIBegin DATE;
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    --
    vCou INTEGER;
    vSPCode VARCHAR2(30);
    vTmpTable VARCHAR2(256);
    vHistTable VARCHAR2(256);
    vTmpATable VARCHAR2(256);
    vHistATable VARCHAR2(256);
    vIdx VARCHAR2(256);
    vBuff VARCHAR2(32700);
    vPrev BOOLEAN := SUBSTR(inMask,1,1) = '1';
    vDaily BOOLEAN := SUBSTR(inMask,2,1) = '1';
    vTruncateTarget BOOLEAN := SUBSTR(inMask,3,1) = '1';
    vLoadTarget BOOLEAN := SUBSTR(inMask,4,1) = '1';
    vCompress BOOLEAN := SUBSTR(inMask,5,1) = '1';
    vStats BOOLEAN := SUBSTR(inMask,6,1) = '1';
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  vMes := 'START :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.tb_load_mass" started.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);

  -- Получение метаданных
  BEGIN
    SELECT p.sp_code
          ,UPPER(vOwner||'.'||e.tmp_table_name) AS tmp_table_name
          ,UPPER(vOwner||'.'||e.hist_table_name) AS hist_table_name
          ,UPPER(vOwner||'.'||ae.tmp_table_name) AS tmp_a_table_name
          ,UPPER(vOwner||'.'||ae.hist_table_name) AS hist_a_table_name
      INTO vSPCode
          ,vTmpTable
          ,vHistTable
          ,vTmpATable
          ,vHistATable
      FROM tb_signs_pool p
           INNER JOIN tb_entity e
             ON e.id = p.entity_id
           LEFT JOIN tb_sign_2_anlt s2a
             ON s2a.sign_name = p.sign_name
                AND s2a.anlt_code = UPPER(inAnltCode)
           LEFT JOIN tb_signs_anlt a
             ON a.anlt_code = s2a.anlt_code
                AND inEndDate BETWEEN a.effective_start AND a.effective_end
           LEFT JOIN tb_entity ae
             ON ae.id = a.entity_id
      WHERE p.sign_name = UPPER(inSign);
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Показатель "'||inSign||'" не найден в таблице '||lower(vOwner)||'.tb_signs_pool');
  END;

  -- Подготовка субпартиций в промежуточной таблице
  IF vPrev THEN
    vBuff := 'ALTER TABLE '||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||' DROP PARTITION '||UPPER(inSign);
    BEGIN
      EXECUTE IMMEDIATE vBuff;
    EXCEPTION WHEN OTHERS THEN
      NULL;
    END;

    vBuff := 'ALTER TABLE '||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||' ADD PARTITION '||UPPER(inSign)||' VALUES('''||UPPER(inSign)||''') STORAGE(INITIAL 64K NEXT 4M) NOLOGGING (SUBPARTITION '||vSPCode||'_OLD VALUES LESS THAN (to_date('''||to_char(TRUNC(inBegDate,'MM'),'DD.MM.YYYY')||''',''DD.MM.YYYY'')))';
    EXECUTE IMMEDIATE vBuff;

    FOR dt IN (
      SELECT TRUNC(dt,'MM') AS dt FROM (
      SELECT TRUNC(inEndDate,'MM') - ROWNUM + 1 AS dt FROM dual CONNECT BY ROWNUM <= TRUNC(inEndDate,'MM') - TRUNC(inBegDate,'MM') + 1
      ) GROUP BY TRUNC(dt,'MM') ORDER BY 1
    ) LOOP
      vBuff := 'ALTER TABLE '||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||' MODIFY PARTITION '||UPPER(inSign)||' ADD SUBPARTITION '||vSPCode||'_'||to_char(dt.dt,'YYYYMM')||' VALUES LESS THAN (to_date('''||to_char(last_day(dt.dt)+1,'DD.MM.YYYY')||''',''DD.MM.YYYY''))';
      EXECUTE IMMEDIATE vBuff;
    END LOOP;
    vBuff := 'ALTER TABLE '||CASE WHEN inAnltCode IS NULL THEN vTmpTable ELSE vTmpATable END||' MODIFY PARTITION '||UPPER(inSign)||' ADD SUBPARTITION '||vSPCode||'_NEW VALUES LESS THAN (MAXVALUE)';
    EXECUTE IMMEDIATE vBuff;

    vTIBegin := SYSDATE;
    vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - загрузка первых чисел месяца в промежуточную таблицу --------';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);

    -- Вставка данных в промежуточную таблицу за первые числа каждого месяца
    /*mass_load_parallel_by_year(TRUNC(inBegDate,'DD'),inEndDate
      ,lower(vOwner)||'.pkg_etl_signs.tmp_load_prev'
      ,'VARCHAR2 '||UPPER(inSign),FALSE,'01',inHeadJobName);*/
    mass_load_parallel_by_ydate_pe(TRUNC(inBegDate,'DD'),inEndDate
      ,lower(vOwner)||'.pkg_etl_signs.tmp_load_prev'
      ,'VARCHAR2 '||UPPER(inSign)||'::VARCHAR2 '||inAnltCode,FALSE,'01'/*,inHeadJobName*/);

    vEndTime := SYSDATE;
    vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - окончание загрузки первых чисел месяца в промежуточную таблицу. Время выполнения - '||get_ti_as_hms(vEndTime - vTIBegin);
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);
  END IF;

  IF vDaily THEN
    vTIBegin := SYSDATE;
    vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - прогрузка всех чисел месяца в промежуточную таблицу (распараллеливание по месяцам) --------';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);

    FOR idx IN 2..31
      LOOP
        -- Прогрузка всех чисел месяца в промежуточную таблицу (распараллеливание по месяцам)
        /*mass_load_parallel_by_year(TRUNC(inBegDate,'DD'),inEndDate
          ,lower(vOwner)||'.pkg_etl_signs.tmp_load_daily'
          ,'VARCHAR2 '||UPPER(inSign),FALSE,to_char(idx,'00'),inHeadJobName);*/
        mass_load_parallel_by_ydate_pe(TRUNC(inBegDate,'DD'),inEndDate
          ,lower(vOwner)||'.pkg_etl_signs.tmp_load_daily'
          ,'VARCHAR2 '||UPPER(inSign)||'::VARCHAR2 '||inAnltCode,FALSE,to_char(idx,'00')/*,inHeadJobName*/);
      END LOOP;

    vEndTime := SYSDATE;
    vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - окончание прогрузки всех чисел месяца в промежуточную таблицу. Время выполнения - '||get_ti_as_hms(vEndTime - vTIBegin);
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);
  END IF;


  vTIBegin := SYSDATE;
  vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - Подготовка существующих данных в целевой таблице --------';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);

  IF vTruncateTarget THEN
    vBuff := 'ALTER TABLE '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||' TRUNCATE PARTITION '||UPPER(inSign);
    BEGIN
      EXECUTE IMMEDIATE vBuff;
      vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'" - Partition '||UPPER(inSign)||' truncated';
    EXCEPTION WHEN OTHERS THEN
      vMes := 'ERROR :: Table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'" - Partition '||UPPER(inSign)||' not truncated :: '||SQLERRM;
    END;
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);
  ELSE
    IF vLoadTarget THEN
      -- Установка effective_end у записей, соответствующих дате начала периода
      vBuff :=
      'BEGIN'||CHR(10)||
      '  UPDATE '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||' SET effective_end = to_date('''||to_char(inBegDate - 1,'DD.MM.YYYY')||''',''DD.MM.YYYY'')'||CHR(10)||
      '    WHERE sign_name = '''||UPPER(inSign)||''''||CHR(10)||
      '      AND to_date('''||to_char(inBegDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') BETWEEN effective_start AND effective_end'||CHR(10)||
      '      AND effective_start < to_date('''||to_char(inBegDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'');'||CHR(10)||
      '  :1 := SQL%ROWCOUNT;'||CHR(10)||
      '  COMMIT;'||CHR(10)||
      'END;';
      EXECUTE IMMEDIATE vBuff USING OUT vCou;
      vMes := 'SUCCESSFULLY :: ------- "'||UPPER(inSign)||'" - "effective_end" - '||vCou||' rows updated in table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'"';
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);
      -- Установка effective_start у записей, соответствующих дате окончания периода
      vBuff :=
      'BEGIN'||CHR(10)||
      '  UPDATE '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||' SET effective_start = to_date('''||to_char(last_day(inEndDate) + 1,'DD.MM.YYYY')||''',''DD.MM.YYYY'')'||CHR(10)||
      '    WHERE sign_name = '''||UPPER(inSign)||''''||CHR(10)||
      '      AND to_date('''||to_char(last_day(inEndDate),'DD.MM.YYYY')||''',''DD.MM.YYYY'') BETWEEN effective_start AND effective_end'||CHR(10)||
      '      AND effective_end > to_date('''||to_char(inEndDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'');'||CHR(10)||
      '  :1 := SQL%ROWCOUNT;'||CHR(10)||
      '  COMMIT;'||CHR(10)||
      'END;';
      EXECUTE IMMEDIATE vBuff USING OUT vCou;
      vMes := 'SUCCESSFULLY :: ------- "'||UPPER(inSign)||'" - "effective_start" - '||vCou||' rows updated in table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'"';
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);
      -- Удаление записей, с effective_start больше или равно даты начала периода
      vBuff :=
      'BEGIN'||CHR(10)||
      'DELETE FROM '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||CHR(10)||
      '  WHERE sign_name = '''||UPPER(inSign)||''''||CHR(10)||
      '    AND effective_start BETWEEN to_date('''||to_char(inBegDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') AND to_date('''||to_char(last_day(inEndDate),'DD.MM.YYYY')||''',''DD.MM.YYYY'');'||CHR(10)||
      '  :1 := SQL%ROWCOUNT;'||CHR(10)||
      '  COMMIT;'||CHR(10)||
      'END;';
      EXECUTE IMMEDIATE vBuff USING OUT vCou;
      vMes := 'SUCCESSFULLY :: ------- "'||UPPER(inSign)||'" - '||vCou||' rows deleted from table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'"';
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);
      -- Удаление записей, с effective_start больше или равно текущей даты (такие получаются когда считаем всё, по вчерашний день)
      vBuff :=
      'BEGIN'||CHR(10)||
      'DELETE FROM '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||CHR(10)||
      '  WHERE sign_name = '''||UPPER(inSign)||''''||CHR(10)||
      '    AND effective_start >= to_date('''||to_char(trunc(SYSDATE,'DD'),'DD.MM.YYYY')||''',''DD.MM.YYYY'');'||CHR(10)||
      '  :1 := SQL%ROWCOUNT;'||CHR(10)||
      '  COMMIT;'||CHR(10)||
      'END;';
      EXECUTE IMMEDIATE vBuff USING OUT vCou;
      vMes := 'SUCCESSFULLY :: ------- "'||UPPER(inSign)||'" - Technical Fictitious Future - '||vCou||' rows deleted from table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'"';
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);

    END IF;
  END IF;

  vEndTime := SYSDATE;
  vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - окончание подготовки существующих данных в целевой таблице. Время выполнения - '||get_ti_as_hms(vEndTime - vTIBegin);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);

  IF vLoadTarget THEN
    vTIBegin := SYSDATE;
    vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - загрузка данных в целевую таблицу --------';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);

    vTIBegin := SYSDATE;
    sign_gluing(UPPER(inSign),UPPER(inAnltCode),'010');

    vEndTime := SYSDATE;
    vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - окончание загрузки данных в целевую таблицу. Время выполнения - '||get_ti_as_hms(vEndTime - vTIBegin);
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);

    -- Проставляем effective_end = 31.12.5999 на последних записях
    -- !!!ТОЛЬКО ЕСЛИ ДАТА ОКОНЧАНИЯ НЕ РАНЕЕ ВЧЕРАШНЕЙ ИНАЧЕ БУДЕТ ОШИБКА Unique constraint!!!
    IF last_day(inEndDate) >= TRUNC(SYSDATE - 1,'DD') THEN
       vMes := 'CONTINUE :: -------- "'||UPPER(inSign)||'" - EFFECTIVE_END -> "31.12.5999" апдейт последних записей ---------';
       pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);

       vTIBegin := SYSDATE;
       tb_upd_eff_end(UPPER(inSign),UPPER(inAnltCode),last_day(inEndDate));

     ELSE
       vMes := 'SUCCESSFULLY :: ------- "'||UPPER(inSign)||'" Update of column EFFECTIVE_END on date "31.12.5999" not required';
       pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);
     END IF;

     vEndTime := SYSDATE;
     vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - EFFECTIVE_END -> "31.12.5999" окончание апдейта последних записей. Время выполнения - '||get_ti_as_hms(vEndTime - vTIBegin);
     pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);
  END IF;

  IF vCompress THEN
    -- Сжатие данных в целевой таблице
    vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - сжатие данных в целевой таблице --------';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);

    vTIBegin := SYSDATE;
    vBuff := 'ALTER TABLE '||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||' MOVE PARTITION '||UPPER(inSign)||' COMPRESS';
    BEGIN
      EXECUTE IMMEDIATE vBuff;
      vEndTime := SYSDATE;
      vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'" - Partition '||UPPER(inSign)||' compressed in '||get_ti_as_hms(vEndTime - vTIBegin);
    EXCEPTION WHEN OTHERS THEN
      vEndTime := SYSDATE;
      vMes := 'ERROR :: Table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'" - Partition '||UPPER(inSign)||' not compressed :: '||SQLERRM||Chr(10)||'------'||Chr(10)||'Execution time: '||get_ti_as_hms(vEndTime - vTIBegin);
    END;
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);

    vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - окончание сжатия данных в целевой таблице. Время выполнения - '||get_ti_as_hms(vEndTime - vTIBegin);
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);

    -- Перестроение индексов в целевой таблице
    vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - перестроение индексов в целевой таблице --------';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);

    -- Получение наименования индекса
    SELECT index_name INTO vIdx FROM all_indexes
      WHERE owner = UPPER(vOwner) AND table_name = UPPER(SUBSTR(CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END,INSTR(CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END,'.',1,1) + 1,LENGTH(CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END) - INSTR(CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END,'.',1,1)))
        AND uniqueness = 'UNIQUE'
        AND index_name LIKE 'UIX%';

    vTIBegin := SYSDATE;
    vBuff := 'ALTER INDEX '||lower(vOwner||'.'||vIdx)||' REBUILD PARTITION '||UPPER(inSign);
    BEGIN
      EXECUTE IMMEDIATE vBuff;
      vEndTime := SYSDATE;
      vMes := 'SUCCESSFULLY :: Index "'||lower(vOwner||'.'||vIdx)||'" - Partition '||UPPER(inSign)||' rebuilded in '||get_ti_as_hms(vEndTime - vTIBegin);
    EXCEPTION WHEN OTHERS THEN
      vEndTime := SYSDATE;
      vMes := 'ERROR :: Index "'||lower(vOwner||'.'||vIdx)||'" - Partition '||UPPER(inSign)||' not rebuilded :: '||SQLERRM||Chr(10)||'------'||Chr(10)||'Execution time: '||get_ti_as_hms(vEndTime - vTIBegin);
    END;
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);

    vEndTime := SYSDATE;
    vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - окончание перестроения индексов в целевой таблице. Время выполнения - '||get_ti_as_hms(vEndTime - vTIBegin);
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);
  END IF;

  IF vStats THEN
    vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - сбор статистики по целевой таблице --------';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);

    vTIBegin := SYSDATE;
    vBuff := 'BEGIN dbms_stats.gather_table_stats('''||UPPER(vOwner)||''','''||UPPER(SUBSTR(CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END,INSTR(CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END,'.',1,1) + 1,LENGTH(CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END) - INSTR(CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END,'.',1,1)))||''','''||UPPER(inSign)||''',20); END;';
    BEGIN
      EXECUTE IMMEDIATE vBuff;
      vEndTime := SYSDATE;
      vMes := 'SUCCESSFULLY :: Table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'" - Partition '||UPPER(inSign)||' Statistic gathered in '||get_ti_as_hms(vEndTime - vTIBegin);
    EXCEPTION WHEN OTHERS THEN
      vEndTime := SYSDATE;
      vMes := 'ERROR :: Table "'||CASE WHEN inAnltCode IS NULL THEN vHistTable ELSE vHistATable END||'" - Partition '||UPPER(inSign)||' Statistic not gathered :: '||SQLERRM||Chr(10)||'------'||Chr(10)||'Execution time: '||get_ti_as_hms(vEndTime - vTIBegin);
    END;
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);

    vEndTime := SYSDATE;
    vMes := 'CONTINUE :: ------- "'||UPPER(inSign)||'" - окончание сбора статистики по целевой таблице. Время выполнения - '||get_ti_as_hms(vEndTime - vTIBegin);
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);
  END IF;

  vEndTime := SYSDATE;
  vMes := 'FINISH :: "'||inSign||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.tb_load_mass" finished in '||get_ti_as_hms(vEndTime - vBegTime)||' successfully';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);
EXCEPTION
  WHEN OTHERS THEN
    vEndTime := SYSDATE;
    vMes := 'ERROR :: '||SQLERRM;
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);
    vMes := 'FINISH :: "'||inSign||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.tb_load_mass" finished in '||get_ti_as_hms(vEndTime - vBegTime)||' with errors';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.tb_load_mass',vMes);
END tb_load_mass;

PROCEDURE SignExtProcessing(inSign IN VARCHAR2,inDate IN DATE)
  IS
    vStmt CLOB;
    vRes VARCHAR2(32700);
    --
    vMes VARCHAR2(32700);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  vMes := 'START :: "'||UPPER(inSign)||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.SignExtProcessing" started.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.SignExtProcessing',vMes);

  -- Получение ext_plsql
  BEGIN
    SELECT ext_plsql
      INTO vStmt
      FROM tb_signs_pool p
      WHERE p.sign_name = UPPER(inSign);
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Показатель "'||inSign||'" не найден в таблице '||lower(vOwner)||'.tb_signs_pool');
  END;

  EXECUTE IMMEDIATE 'ALTER SESSION SET nls_date_format = ''DD.MM.RRRR HH24:MI:SS''';
  -- Обработка
  EXECUTE IMMEDIATE vStmt USING IN UPPER(inSign),IN inDate,OUT vRes;

  vEndTime := SYSDATE;
  vMes := 'SUCCESSFULLY :: "'||UPPER(inSign)||'" extended processing :: '||vRes;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.SignExtProcessing',vMes);
  vMes := 'FINISH :: "'||UPPER(inSign)||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.SignExtProcessing" finished successfully in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.SignExtProcessing',vMes);
EXCEPTION WHEN OTHERS THEN
  vEndTime := SYSDATE;
  vMes := 'ERROR :: "'||UPPER(inSign)||'" extended processing :: '||SQLERRM;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.SignExtProcessing',vMes);
  vMes := 'FINISH :: "'||UPPER(inSign)||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.SignExtProcessing" finished with errors in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.SignExtProcessing',vMes);
END;


FUNCTION get_empty_sign_id RETURN NUMBER
  IS
    vRes NUMBER;
BEGIN
  SELECT MAX(ID) + 1 INTO vRes FROM tb_signs_pool;

  WITH
    digit AS (
     SELECT LEVEL AS ID FROM dual CONNECT BY ROWNUM <= vRes
    )
  SELECT MIN(d_id) AS ID INTO vRes
    FROM (SELECT digit.id AS d_id,p.id AS p_id FROM digit LEFT JOIN tb_signs_pool p ON p.id = digit.id)
    WHERE p_id IS NULL;
  RETURN vRes;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN vRes;
  WHEN OTHERS THEN
    RETURN -1;
END get_empty_sign_id;

FUNCTION DropSignPartitions(inSign IN VARCHAR2) RETURN VARCHAR2
  IS
    vOut VARCHAR2(4000);
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  vOut := '------------';
  FOR idx IN (
    WITH
      fct AS (
        SELECT UPPER(fct_table_name) AS table_name
          FROM tb_signs_pool p
               INNER JOIN tb_entity e ON e.id = p.entity_id
          WHERE p.sign_name = UPPER(inSign)
            AND p.hist_flg = 0
        UNION
        SELECT UPPER(e.fct_table_name)
          FROM tb_signs_pool p
               INNER JOIN tb_sign_2_anlt s2a ON s2a.sign_name = p.sign_name
               INNER JOIN tb_signs_anlt a
                 ON a.anlt_code = s2a.anlt_code
                    AND SYSDATE BETWEEN a.effective_start AND a.effective_end
               INNER JOIN tb_entity e
                 ON e.id = a.entity_id
          WHERE p.sign_name = UPPER(inSign)
            AND p.hist_flg = 0
      )
     ,hist AS (
        SELECT UPPER(e.hist_table_name) AS table_name
          FROM tb_signs_pool p
               INNER JOIN tb_entity e ON e.id = p.entity_id
          WHERE p.sign_name = UPPER(inSign)
            AND p.hist_flg = 1
        UNION
        SELECT UPPER(e.tmp_table_name)
          FROM tb_signs_pool p
               INNER JOIN tb_entity e ON e.id = p.entity_id
          WHERE p.sign_name = UPPER(inSign)
            AND p.hist_flg = 1
        UNION
        SELECT UPPER(e.hist_table_name)
          FROM tb_signs_pool p
               INNER JOIN tb_sign_2_anlt s2a ON s2a.sign_name = p.sign_name
               INNER JOIN tb_signs_anlt a
                 ON a.anlt_code = s2a.anlt_code
                    AND SYSDATE BETWEEN a.effective_start AND a.effective_end
               INNER JOIN tb_entity e
                 ON e.id = a.entity_id
          WHERE p.sign_name = UPPER(inSign)
            AND p.hist_flg = 1
        UNION
        SELECT UPPER(e.tmp_table_name)
          FROM tb_signs_pool p
               INNER JOIN tb_sign_2_anlt s2a ON s2a.sign_name = p.sign_name
               INNER JOIN tb_signs_anlt a
                 ON a.anlt_code = s2a.anlt_code
                    AND SYSDATE BETWEEN a.effective_start AND a.effective_end
               INNER JOIN tb_entity e
                 ON e.id = a.entity_id
          WHERE p.sign_name = UPPER(inSign)
            AND p.hist_flg = 1
      )

    SELECT fct.table_name,prt.partition_name
      FROM fct
           INNER JOIN all_tab_partitions prt
             ON prt.table_owner = UPPER(vOwner)
                AND prt.table_name = fct.table_name
                AND prt.partition_name = UPPER(inSign)
    UNION
    SELECT hist.table_name,prt.partition_name
      FROM hist
           INNER JOIN all_tab_partitions prt
             ON prt.table_owner = UPPER(vOwner)
                AND prt.table_name = hist.table_name
                AND prt.partition_name = UPPER(inSign)
  ) LOOP
    BEGIN
      EXECUTE IMMEDIATE 'ALTER TABLE '||lower(vOwner||'.'||idx.table_name)||' DROP PARTITION '||UPPER(inSign);
      vOut := vOut||CHR(10)||'SUCCESSFULLY :: Table "'||lower(vOwner||'.'||idx.table_name)||'" - Partition "'||UPPER(inSign)||'" dropped';
      --dbms_output.put_line(idx.table_name||'|'||idx.partition_name);
    EXCEPTION WHEN OTHERS THEN
      vOut := vOut||CHR(10)||'ERROR :: Table "'||lower(vOwner||'.'||idx.table_name)||'" - Partition "'||UPPER(inSign)||'" not dropped :: '||SQLERRM;
    END;
  END LOOP;
  RETURN vOut;
END DropSignPartitions;

PROCEDURE drop_sign(inSign IN VARCHAR2,outRes OUT VARCHAR2)
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  -- Удаление партиции
  outRes := DropSignPartitions(UPPER(inSign));

  -- Удаление привязки к аналитикам
  BEGIN
    DELETE FROM tb_sign_2_anlt WHERE sign_name = UPPER(inSign);
    outRes := outRes||CHR(10)||'------------'||CHR(10)||'SUCCESSFULLY :: "'||UPPER(inSign)||'" - Удалено '||SQL%ROWCOUNT||' привязок к аналитикам';
  EXCEPTION WHEN OTHERS THEN
    outRes := outRes||CHR(10)||'------------'||CHR(10)||'ERROR :: "'||UPPER(inSign)||'" - не возможно удалить привязки к аналитикам :: '||SQLERRM;
    RAISE_APPLICATION_ERROR(-20000,outRes);
  END;

  -- Удаление привязки к группе
  BEGIN
    DELETE FROM tb_signs_2_group WHERE sign_name = UPPER(inSign);
    outRes := outRes||CHR(10)||'SUCCESSFULLY :: "'||UPPER(inSign)||'" - Удалено '||SQL%ROWCOUNT||' привязок к группам';
  EXCEPTION WHEN OTHERS THEN
    outRes := outRes||CHR(10)||'ERROR :: "'||UPPER(inSign)||'" - не возможно удалить привязки к группам :: '||SQLERRM;
    RAISE_APPLICATION_ERROR(-20000,outRes);
  END;
  -- Удаление зависимости от других показателей
  BEGIN
    DELETE FROM tb_sign_2_sign WHERE sign_name = UPPER(inSign) OR prev_sign_name = UPPER(inSign);
    outRes := outRes||CHR(10)||'SUCCESSFULLY :: "'||UPPER(inSign)||'" - Удалено '||SQL%ROWCOUNT||' зависимостей от других показателей';
  EXCEPTION WHEN OTHERS THEN
    outRes := outRes||CHR(10)||'ERROR :: "'||UPPER(inSign)||'" - не возможно удалить зависимости от других показателей :: '||SQLERRM;
    RAISE_APPLICATION_ERROR(-20000,outRes);
  END;

  -- Удаление из списка показателей
  BEGIN
    DELETE FROM tb_signs_pool WHERE sign_name = UPPER(inSign);
    outRes := outRes||CHR(10)||'------------'||CHR(10)||'SUCCESSFULLY :: "'||UPPER(inSign)||'" - Показатель удален из списка показателей';
  EXCEPTION WHEN OTHERS THEN
    outRes := outRes||CHR(10)||'------------'||CHR(10)||'ERROR :: "'||UPPER(inSign)||'" - не возможно удалить показатель в таблице "'||lower(vOwner)||'.tb_signs_pool" :: '||SQLERRM;
  END;
EXCEPTION WHEN OTHERS THEN
  outRes := outRes||CHR(10)||'------------'||CHR(10)||'ERROR :: "'||UPPER(inSign)||'" - '||SQLERRM;
END drop_sign;

FUNCTION GetTreeList(inSQL IN CLOB) RETURN TTabTree PIPELINED
  IS
    rec TRecTree;
      cur INTEGER;       -- хранит идентификатор (ID) курсора
      ret INTEGER;       -- хранит возвращаемое по вызову значение
BEGIN
  cur := dbms_sql.open_cursor;
  dbms_sql.parse(cur, inSQL, dbms_sql.native);
  dbms_sql.define_column(cur,1,rec.Id,4000);
  dbms_sql.define_column(cur,2,rec.ParentId,4000);
  ret := dbms_sql.execute(cur);
  LOOP
    EXIT WHEN dbms_sql.fetch_rows(cur) = 0;
    dbms_sql.column_value(cur,1,rec.Id);
    dbms_sql.column_value(cur,2,rec.ParentId);
    PIPE ROW(rec);
  END LOOP;
  dbms_sql.close_cursor(cur);
END;

FUNCTION GetChainList(inSQL IN CLOB) RETURN TTabCHBuilder PIPELINED
  IS
    rec TRecCHBuilder;
    cur INTEGER;       -- хранит идентификатор (ID) курсора
    ret INTEGER;       -- хранит возвращаемое по вызову значение
BEGIN
    cur := dbms_sql.open_cursor;
    dbms_sql.parse(cur, inSQL, dbms_sql.native);
    dbms_sql.define_column(cur,1,rec.id,4000);
    dbms_sql.define_column(cur,2,rec.parent_id,4000);
    dbms_sql.define_column(cur,3,rec.unit,4000);
    dbms_sql.define_column(cur,4,rec.params,4000);
    dbms_sql.define_column(cur,5,rec.skip);

    ret := dbms_sql.execute(cur);

    LOOP
      EXIT WHEN dbms_sql.fetch_rows(cur) = 0;
      dbms_sql.column_value(cur,1,rec.id);
      dbms_sql.column_value(cur,2,rec.parent_id);
      dbms_sql.column_value(cur,3,rec.unit);
      dbms_sql.column_value(cur,4,rec.params);
      dbms_sql.column_value(cur,5,rec.skip);
      PIPE ROW(rec);
    END LOOP;
    dbms_sql.close_cursor(cur);
END GetChainList;

FUNCTION GetTreeSQL(inFullSQL IN CLOB
                   ,inStartSQL IN CLOB
                   ,inIncludeChilds IN INTEGER DEFAULT 0)
  RETURN CLOB
  IS
    vRes CLOB;
    vBuff VARCHAR2(32700);
    vCou INTEGER :=0;
    vStartSQL CLOB := inStartSQL;
BEGIN
  IF inStartSQL IS NULL THEN vStartSQL := inFullSQL; END IF;

  dbms_lob.createtemporary(vRes,FALSE);

  IF inIncludeChilds = 0 AND inStartSQL IS NOT NULL THEN
    FOR idx IN (
      WITH
        f AS (SELECT * FROM TABLE(GetTreeList(inFullSQL)))
       ,s AS (SELECT * FROM TABLE(GetTreeList(vStartSQL)))
       SELECT DISTINCT s.id,f.parentid
         FROM s INNER JOIN f ON f.id = s.id
         WHERE NVL(f.parentid,s.id) IN (SELECT ID FROM s)
    ) LOOP
      vBuff := CASE WHEN vCou > 0 THEN CHR(10)||'UNION ALL'||CHR(10) END||'SELECT '''||idx.id||''' AS id,'||CASE WHEN idx.parentid IS NOT NULL THEN ''''||idx.parentid||'''' ELSE 'NULL' END||' AS PARENT_ID FROM dual';
      dbms_lob.writeappend(vRes,LENGTH(vBuff),vBuff);
      vCou := vCou + 1;
    END LOOP;
  ELSIF inIncludeChilds = 1  AND inStartSQL IS NOT NULL THEN
    FOR idx IN (
    WITH
      f AS (SELECT * FROM TABLE(GetTreeList(inFullSQL)))
     ,s AS (SELECT * FROM TABLE(GetTreeList(vStartSQL)))
     ,c AS (
        SELECT ID,parentid FROM s
        UNION ALL
        SELECT ID,parentid FROM (
          SELECT ID,parentid FROM f
          MINUS
          SELECT ID,parentid FROM s)
      )
      SELECT DISTINCT ID,parentid FROM (
        SELECT ID,parentid
          FROM c CONNECT BY PRIOR ID = parentid START WITH id IN (SELECT ID FROM s)
      ) WHERE parentid IS NULL OR parentid IN (SELECT ID FROM s)
    ) LOOP
      vBuff := CASE WHEN vCou > 0 THEN CHR(10)||'UNION ALL'||CHR(10) END||'SELECT '''||idx.id||''' AS id,'||CASE WHEN idx.parentid IS NOT NULL THEN ''''||idx.parentid||'''' ELSE 'NULL' END||' AS PARENT_ID FROM dual';
      dbms_lob.writeappend(vRes,LENGTH(vBuff),vBuff);
      vCou := vCou + 1;
    END LOOP;
  ELSE
    FOR idx IN (
      WITH
        f AS (SELECT * FROM TABLE(GetTreeList(inFullSQL)))
       SELECT DISTINCT f.id,f.parentid
         FROM f
    ) LOOP
      vBuff := CASE WHEN vCou > 0 THEN CHR(10)||'UNION ALL'||CHR(10) END||'SELECT '''||idx.id||''' AS id,'||CASE WHEN idx.parentid IS NOT NULL THEN ''''||idx.parentid||'''' ELSE 'NULL' END||' AS PARENT_ID FROM dual';
      dbms_lob.writeappend(vRes,LENGTH(vBuff),vBuff);
      vCou := vCou + 1;
    END LOOP;
  END IF;
  RETURN vRes;
END GetTreeSQL;

FUNCTION ChainBuilder(/*inID VARCHAR2,*/inSQL CLOB) RETURN VARCHAR2
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
    vID VARCHAR2(30) := to_char(tb_signs_job_id_seq.nextval);
    vChainName VARCHAR2(256) := vOwner||'.CHAIN_'||vID;--inID;
    vBuff VARCHAR2(32700);
    vPrg CLOB;
    vArg CLOB;
    vStp CLOB;
    vRul CLOB;
    vAct CLOB;
    ErrAct VARCHAR2(256);
    ErrComm VARCHAR2(256);
    PrgCou INTEGER := 0;
BEGIN
  -- Программы
  dbms_lob.createtemporary(vPrg,FALSE);
  dbms_lob.writeappend(vPrg,LENGTH('BEGIN'||CHR(10)),'BEGIN'||CHR(10));

  vBuff :=
  '  sys.dbms_scheduler.create_program(program_name        => '''||vOwner||'.PRG_START_'||vID||''','||CHR(10)||
  '                                    program_type        => ''PLSQL_BLOCK'','||CHR(10)||
  '                                    program_action      => ''BEGIN NULL; END;'','||CHR(10)||
  '                                    enabled             => true,'||CHR(10)||
  '                                    comments            => ''Старт'');'||CHR(10);
  dbms_lob.writeappend(vPrg,LENGTH(vBuff),vBuff);

  FOR idx IN (
    SELECT DISTINCT
           vOwner||'.PRG_'||ora_hash(ID)||'_'||vID AS prg_name
          ,lower(p.unit) AS action
          ,ID AS comm
          ,SUM(NVL2(a.OBJECT_ID,1,0)) OVER (PARTITION BY p.id,p.parent_id) AS arg_cou
      FROM TABLE(GetChainList(inSQL)) p
           LEFT JOIN all_procedures prc
             ON lower(prc.owner||NVL2(prc.object_name,'.'||prc.object_name,NULL)||NVL2(prc.procedure_name,'.'||prc.procedure_name,NULL)) = lower(p.unit)
           LEFT JOIN all_arguments a
             ON a.OBJECT_ID = prc.object_id AND a.argument_name IS NOT NULL
                AND a.object_name = NVL(prc.procedure_name,prc.object_name)
  ) LOOP
     IF PrgCou <=1 THEN ErrAct := idx.action; ErrComm := idx.comm; END IF;
     PrgCou := PrgCou + 1;
      vBuff :=
      '  sys.dbms_scheduler.create_program(program_name        => '''||idx.prg_name||''','||CHR(10)||
      '                                    program_type        => ''STORED_PROCEDURE'','||CHR(10)||
      '                                    program_action      => '''||idx.action||''','||CHR(10)||
      '                                    number_of_arguments => '||idx.arg_cou||','||CHR(10)||
      '                                    enabled             => false,'||CHR(10)||
      '                                    comments            => '''||idx.comm||''');'||CHR(10);
      dbms_lob.writeappend(vPrg,length(vBuff),vBuff);
  END LOOP;
  dbms_lob.writeappend(vPrg,LENGTH('END;'),'END;');

  -- Параметры программ
  dbms_lob.createtemporary(vArg,FALSE);
  dbms_lob.writeappend(vArg,LENGTH('BEGIN'||CHR(10)),'BEGIN'||CHR(10));
  FOR idx IN (
    SELECT vOwner||'.PRG_'||ora_hash(ID)||'_'||vID AS prg_name
          ,v.ord AS arg_position
          ,a.argument_name AS arg_name
          ,a.data_type arg_type
          ,v.str AS arg_value
      FROM TABLE(GetChainList(inSQL)) p
           CROSS JOIN TABLE(parse_str(p.params,'#!#')) v
           LEFT JOIN all_procedures prc
             ON lower(prc.owner||NVL2(prc.object_name,'.'||prc.object_name,NULL)||NVL2(prc.procedure_name,'.'||prc.procedure_name,NULL)) = lower(p.unit)
           LEFT JOIN all_arguments a
             ON a.OBJECT_ID = prc.object_id
                AND a.object_name = NVL(prc.procedure_name,prc.object_name)
                AND a.position = v.ord
      WHERE a.argument_name IS NOT NULL
    GROUP BY v.ord,p.id,a.argument_name,a.data_type,v.ord,v.str
    ORDER BY p.id,v.ord
  ) LOOP
      vBuff :=
      '  sys.dbms_scheduler.define_program_argument(program_name => '''||idx.prg_name||''','||CHR(10)||
      '                                             argument_position => '||idx.arg_position||','||CHR(10)||
      '                                             argument_name     => '''||idx.arg_name||''','||CHR(10)||
      '                                             argument_type     => '''||idx.arg_type||''','||CHR(10)||
      '                                             default_value     => '''||idx.arg_value||''');'||CHR(10);
      dbms_lob.writeappend(vArg,length(vBuff),vBuff);
  END LOOP;
  dbms_lob.writeappend(vArg,LENGTH('END;'),'END;');

  -- Цепь и шаги
  dbms_lob.createtemporary(vStp,FALSE);
  dbms_lob.writeappend(vStp,LENGTH('BEGIN'||CHR(10)),'BEGIN'||CHR(10));

  vBuff :=
  '  sys.dbms_scheduler.create_chain(chain_name          => '''||vChainName||''','||CHR(10)||
  '                                  evaluation_interval => INTERVAL ''3'' MINUTE,'||CHR(10)||
  '                                  comments            => ''Головной CHAIN'');'||CHR(10);
  dbms_lob.writeappend(vStp,length(vBuff),vBuff);

  vBuff :=
  '  sys.dbms_scheduler.define_chain_step(chain_name   => '''||vChainName||''','||CHR(10)||
  '                                       step_name    => ''STP_START'','||CHR(10)||
  '                                       program_name => '''||vOwner||'.PRG_START_'||vID||''');'||CHR(10);
  dbms_lob.writeappend(vStp,length(vBuff),vBuff);

  FOR idx IN (
    SELECT DISTINCT
           'STP_'||ora_hash(ID) AS stp_name
          ,vOwner||'.PRG_'||ora_hash(ID)||'_'||vID AS prg_name
          ,skip
      FROM TABLE(GetChainList(inSQL)) p
  ) LOOP
    vBuff :=
    '  sys.dbms_scheduler.define_chain_step(chain_name   => '''||vChainName||''','||CHR(10)||
    '                                       step_name    => '''||idx.stp_name||''','||CHR(10)||
    '                                       program_name => '''||idx.prg_name||''');'||CHR(10);
    dbms_lob.writeappend(vStp,length(vBuff),vBuff);

    IF idx.skip = 1 THEN
      vBuff :=
      'dbms_scheduler.alter_chain(chain_name  =>  '''||vChainName||''','||CHR(10)||
      'step_name   =>  '''||idx.stp_name||''','||CHR(10)||
      'attribute   =>  ''SKIP'','||CHR(10)||
      'value       =>  TRUE);'||CHR(10);
      dbms_lob.writeappend(vStp,length(vBuff),vBuff);
    END IF;
  END LOOP;
  dbms_lob.writeappend(vStp,LENGTH('END;'),'END;');

  -- Правила
  dbms_lob.createtemporary(vRul,FALSE);
  dbms_lob.writeappend(vRul,LENGTH('BEGIN'||CHR(10)),'BEGIN'||CHR(10));

  vBuff :=
  '  sys.dbms_scheduler.define_chain_rule(chain_name => '''||vChainName||''','||CHR(10)||
  '                                       rule_name  => '''||vOwner||'.RUL_START_'||vID||''','||CHR(10)||
  '                                       condition  => ''TRUE'','||CHR(10)||
  '                                       action     => ''START "STP_START"'','||CHR(10)||
  '                                       comments   => ''Старт'');'||CHR(10);
  dbms_lob.writeappend(vRul,length(vBuff),vBuff);

  FOR idx IN (
    SELECT 'STP_'||ora_hash(ID) AS stp_name
          ,vOwner||'.RUL_'||ora_hash(ID)||'_'||vID AS rul_name
          ,LISTAGG(CASE WHEN parent_id IS NOT NULL THEN 'STP_'||ora_hash(parent_id)||' COMPLETED' END,' AND ') WITHIN GROUP (ORDER BY ora_hash(parent_id)) AS cond
          ,p.id
      FROM TABLE(GetChainList(inSQL)) p
    GROUP BY p.id
  ) LOOP
    vBuff :=
    '  sys.dbms_scheduler.define_chain_rule(chain_name => '''||vChainName||''','||CHR(10)||
    '                                       rule_name  => '''||idx.rul_name||''','||CHR(10)||
    '                                       condition  => '''||NVL(idx.cond,'STP_START COMPLETED')||''','||CHR(10)||
    '                                       action     => ''START "'||idx.stp_name||'"'','||CHR(10)||
    '                                       comments   => '''||idx.id||''');'||CHR(10);
    dbms_lob.writeappend(vRul,length(vBuff),vBuff);
  END LOOP;
  dbms_lob.writeappend(vRul,LENGTH('END;'),'END;');

  -- Активация программ и цепи
  dbms_lob.createtemporary(vAct,FALSE);
  dbms_lob.writeappend(vAct,LENGTH('BEGIN'||CHR(10)),'BEGIN'||CHR(10));

  FOR idx IN (
    SELECT DISTINCT
           vOwner||'.PRG_'||ora_hash(ID)||'_'||vID AS prg_name
      FROM TABLE(GetChainList(inSQL)) p
  ) LOOP
      vBuff :=
      '  sys.dbms_scheduler.enable('''||idx.prg_name||''');'||CHR(10);
      dbms_lob.writeappend(vAct,length(vBuff),vBuff);
  END LOOP;

  vBuff :=
  '  sys.dbms_scheduler.enable('''||vChainName||''');'||CHR(10);
  dbms_lob.writeappend(vAct,length(vBuff),vBuff);

  dbms_lob.writeappend(vAct,LENGTH('END;'),'END;');


  EXECUTE IMMEDIATE vPrg;
  --dbms_output.put_line(vPrg);
  EXECUTE IMMEDIATE vArg;
  --dbms_output.put_line(vArg);
  EXECUTE IMMEDIATE vStp;
  --dbms_output.put_line(vStp);
  EXECUTE IMMEDIATE vRul;
  --dbms_output.put_line(vRul);
  EXECUTE IMMEDIATE vAct;
  --dbms_output.put_line(vAct);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.ChainBuilder','SUCCESSFULLY :: Chain '||vChainName||' - Action '||ErrAct||' - Comments '||ErrComm||' builded');

  RETURN vChainName;
EXCEPTION WHEN OTHERS THEN
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.ChainBuilder','ERROR :: '||SQLERRM);
  RETURN vChainName;
END ChainBuilder;

FUNCTION ChainStarter(inChainName IN VARCHAR2,inHeadJobName IN VARCHAR2 DEFAULT NULL) RETURN VARCHAR2
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
    vRes VARCHAR2(4000);
    vJobName VARCHAR2(256) := NVL(inHeadJobName,vOwner||'.CHAINJOB_'||to_char(SYSDATE,'RRRRMMDDHH24MISS'));
BEGIN
  vRes := inChainName;
  sys.dbms_scheduler.run_chain(inChainName,'STP_START',vJobName);
  RETURN vRes;
EXCEPTION WHEN OTHERS THEN
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.ChainStarter','ERROR :: '||SQLERRM);
  RETURN vRes;
END ChainStarter;

PROCEDURE ChainKiller(inChainName VARCHAR2)
  IS
  vRunChCou INTEGER := 1;
  curPrg SYS_REFCURSOR;
  vPrgName VARCHAR2(256);
  vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  -- Ожидание пока отработает цепь
  LOOP
    SELECT COUNT(1) INTO vRunChCou
      FROM all_scheduler_running_chains
      WHERE lower(owner)||'.'||lower(chain_name) = LOWER(inChainName)
        AND completed = 'FALSE';
    EXIT WHEN vRunChCou = 0;
    -- ждем 10 секунд, затем проверяем снова
    stage.mysleep(10);
  END LOOP;

  -- Открытие курсора с наименованиями программ
  OPEN curPrg FOR
    SELECT LOWER(owner||'.'||program_name) AS prg_name
      FROM all_scheduler_chain_steps
      WHERE lower(owner)||'.'||lower(chain_name) = LOWER(inChainName);

  -- Удаление цепи
  BEGIN
    sys.dbms_scheduler.drop_chain(LOWER(inChainName),TRUE);
  EXCEPTION WHEN OTHERS THEN
    NULL;
  END;

  -- Удаление программ
  LOOP
    FETCH curPrg INTO vPrgName;
    EXIT WHEN curPrg%NOTFOUND;
    BEGIN
      sys.dbms_scheduler.drop_program(vPrgName,TRUE);
    EXCEPTION WHEN OTHERS THEN
      NULL;
    END;
  END LOOP;

  CLOSE curPrg;
EXCEPTION WHEN OTHERS THEN
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.ChainKiller','ERROR :: '||SQLERRM);
END ChainKiller;

PROCEDURE calc(inBegDate IN DATE,inEndDate IN DATE)
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
    vJobName VARCHAR2(256) := UPPER(vOwner)||'.'||'AUTOCALC_'||tb_signs_job_id_seq.nextval;
    vBuff VARCHAR2(4000);
BEGIN
  vBuff :=
    'SELECT p.id,c2c.parent_id,p.e_unit AS unit'||CHR(10)||
    '      ,REPLACE(REPLACE(p.params,'':INBEGDATE'','''||to_char(inBegDate,'DD.MM.YYYY')||'''),'':INENDDATE'','''||to_char(inEndDate,'DD.MM.YYYY')||''') AS params'||CHR(10)||
    '      ,CASE WHEN p.archive_flag = 0 AND '||vOwner||'.pkg_etl_signs.GetConditionResult(p.condition) = 1 THEN 0 ELSE 1 END AS skip'||CHR(10)||
    ' FROM tb_calc_pool p'||CHR(10)||
    '       LEFT JOIN tb_calc_2_calc c2c'||CHR(10)||
    '         ON c2c.id = p.id /*AND c2c.parent_id IN (SELECT id FROM tb_calc_pool WHERE archive_flag = 0)*/'||CHR(10)||
    '  /*WHERE p.archive_flag = 0*/'||CHR(10);

    load_new(vBuff,vJobName);
EXCEPTION WHEN OTHERS THEN
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.calc',SQLERRM);
END calc;

PROCEDURE CalcSignsByGroup(inBegDate IN DATE,inEndDate IN DATE,inGroupID IN NUMBER,inJobName VARCHAR2)
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
    vBuff VARCHAR2(32700);
    vUnit VARCHAR2(256) := lower(vOwner)||'.pkg_etl_signs.'||CASE WHEN ABS(MONTHS_BETWEEN(inEndDate,inBegDate)) <= 1 THEN 'load_sign' ELSE 'mass_load' END;
    vBegDate VARCHAR2(30) := to_char(inBegDate,'DD.MM.YYYY');
    vEndDate VARCHAR2(30) := to_char(inEndDate,'DD.MM.YYYY');
BEGIN
  vBuff :=
  q'[
  SELECT s2g.sign_name AS id
        ,s2s.prev_sign_name AS parent_id
        ,']'||vUnit||q'[' AS unit
        ,']'||vBegDate||'#!#'||vEndDate||q'[#!#'||s2g.sign_name||'#!##!#1' AS params
        ,CASE WHEN p.condition IS NULL OR pkg_etl_signs.GetConditionResult(p.condition) = 1 THEN 0 ELSE 1 END AS skip
    FROM tb_signs_2_group s2g
         LEFT JOIN tb_signs_pool p ON p.sign_name = s2g.sign_name
         LEFT JOIN tb_sign_2_sign s2s
           ON s2s.sign_name = s2g.sign_name
              AND EXISTS (SELECT NULL FROM tb_signs_pool WHERE sign_name = s2s.prev_sign_name AND archive_flg = 0)
              AND s2s.prev_sign_name IN (SELECT g1.sign_name
                                           FROM tb_signs_2_group g1
                                           WHERE g1.group_id = ]'||inGroupID||q'[)
    WHERE s2g.group_id = ]'||inGroupID||q'[
      AND EXISTS (SELECT NULL FROM tb_signs_pool WHERE sign_name = s2g.sign_name AND archive_flg = 0)
  ORDER BY s2g.sign_name
  ]';

  load_new(vBuff,inJobName);
  --dbms_output.put_line(vBuff);
END CalcSignsByGroup;


PROCEDURE CalcSignsByStar(inBegDate IN DATE,inEndDate IN DATE,inGroupID IN NUMBER,inJobName VARCHAR2)
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
    vBuff VARCHAR2(32700);
    vUnit VARCHAR2(256) := lower(vOwner)||'.pkg_etl_signs.'||CASE WHEN ABS(MONTHS_BETWEEN(inEndDate,inBegDate)) <= 1 THEN 'load_sign' ELSE 'mass_load' END;
    vBegDate VARCHAR2(30) := to_char(inBegDate,'DD.MM.YYYY');
    vEndDate VARCHAR2(30) := to_char(inEndDate,'DD.MM.YYYY');
BEGIN
  vBuff :=
  q'[
  SELECT s2g.sign_name AS ID
        ,s2s.prev_sign_name AS parent_id
        ,']'||vUnit||q'[' AS unit
        ,']'||vBegDate||'#!#'||vEndDate||q'[#!#'||s2g.sign_name||'#!##!#1' AS params
        ,CASE WHEN p.condition IS NULL OR pkg_etl_signs.GetConditionResult(p.condition) = 1 THEN 0 ELSE 1 END AS skip
    FROM tb_signs_2_group s2g
         LEFT JOIN tb_signs_pool p ON p.sign_name = s2g.sign_name
         LEFT JOIN tb_sign_2_sign s2s
           ON s2s.sign_name = s2g.sign_name
              AND EXISTS (SELECT NULL FROM tb_signs_pool WHERE sign_name = s2s.prev_sign_name AND archive_flg = 0)
              AND s2s.prev_sign_name IN (SELECT sg.sign_name
                                           FROM tb_signs_group g1
                                                LEFT JOIN tb_signs_2_group sg
                                                  ON sg.group_id = g1.group_id
                                           WHERE LEVEL <= 2
                                           CONNECT BY PRIOR g1.group_id = g1.parent_group_id
                                           START WITH g1.group_id = ]'||inGroupID||q'[)
    WHERE s2g.group_id IN (SELECT group_id FROM tb_signs_group WHERE LEVEL <= 2 CONNECT BY PRIOR group_id = parent_group_id START WITH group_id = ]'||inGroupID||q'[)
      AND EXISTS (SELECT NULL FROM tb_signs_pool WHERE sign_name = s2g.sign_name AND archive_flg = 0)
  ORDER BY s2g.sign_name
  ]';

  load_new(vBuff,inJobName);
  --dbms_output.put_line(vBuff);
END CalcSignsByStar;

PROCEDURE CalcAnltByGroup(inBegDate IN DATE,inEndDate IN DATE,inGroupID IN NUMBER,inJobName VARCHAR2)
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
    vBuff VARCHAR2(32700);
    vUnit VARCHAR2(256) := lower(vOwner)||'.pkg_etl_signs.'||CASE WHEN ABS(MONTHS_BETWEEN(inEndDate,inBegDate)) <= 1 THEN 'load_sign' ELSE 'mass_load' END;
    vBegDate VARCHAR2(30) := to_char(inBegDate,'DD.MM.YYYY');
    vEndDate VARCHAR2(30) := to_char(inEndDate,'DD.MM.YYYY');
BEGIN
  vBuff :=
  q'[
    SELECT s2g.sign_name||'|'||s2a.anlt_code AS id
          ,NULL AS parent_id
          ,']'||vUnit||q'[' AS unit
          ,']'||vBegDate||'#!#'||vEndDate||q'[#!#'||s2g.sign_name||'#!#'||s2a.anlt_code||'#!#1' AS params
          ,0 AS skip
      FROM tb_signs_2_group s2g
           INNER JOIN tb_signs_pool p
             ON p.sign_name = s2g.sign_name
                AND p.archive_flg = 0
           LEFT JOIN tb_sign_2_anlt s2a
             ON s2g.sign_name = s2a.sign_name
                AND EXISTS (SELECT NULL FROM tb_anlt_2_group a2g WHERE a2g.anlt_code = s2a.anlt_code AND a2g.group_id = ]'||inGroupID||')
      WHERE s2g.group_id = '||inGroupID||'
        AND s2a.anlt_code IS NOT NULL';
  load_new(vBuff,inJobName);
  --dbms_output.put_line(vBuff);
END CalcAnltByGroup;

PROCEDURE CalcAnltByStar(inBegDate IN DATE,inEndDate IN DATE,inGroupID IN NUMBER,inJobName VARCHAR2)
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
    vBuff VARCHAR2(32700);
    vUnit VARCHAR2(256) := lower(vOwner)||'.pkg_etl_signs.'||CASE WHEN ABS(MONTHS_BETWEEN(inEndDate,inBegDate)) <= 1 THEN 'load_sign' ELSE 'mass_load' END;
    vBegDate VARCHAR2(30) := to_char(inBegDate,'DD.MM.YYYY');
    vEndDate VARCHAR2(30) := to_char(inEndDate,'DD.MM.YYYY');
BEGIN
  vBuff :=
  q'[
  SELECT s2g.sign_name||'|'||s2a.anlt_code AS ID
        ,NULL AS parent_id
        ,']'||vUnit||q'[' AS unit
        ,']'||vBegDate||'#!#'||vEndDate||q'[#!#'||s2g.sign_name||'#!#'||s2a.anlt_code||'#!#1' AS params
        ,0 AS skip
    FROM tb_signs_2_group s2g
         LEFT JOIN tb_sign_2_anlt s2a
           ON s2g.sign_name = s2a.sign_name
              AND EXISTS (SELECT NULL FROM tb_anlt_2_group a2g
                            WHERE a2g.anlt_code = s2a.anlt_code
                              AND a2g.group_id = (SELECT group_id FROM tb_signs_group WHERE LEVEL = 3 CONNECT BY PRIOR group_id = parent_group_id START WITH group_id = ]'||inGroupID||q'[))
    WHERE s2g.group_id = (SELECT group_id FROM tb_signs_group WHERE LEVEL = 3 CONNECT BY PRIOR group_id = parent_group_id START WITH group_id = ]'||inGroupID||q'[)
      AND EXISTS (SELECT NULL FROM tb_signs_pool WHERE sign_name = s2g.sign_name AND archive_flg = 0)
  ORDER BY s2g.sign_name
  ]';
  load_new(vBuff,inJobName);
  --dbms_output.put_line(vBuff);
END CalcAnltByStar;

/******************************** ИМПОРТ - ЭКСПОРТ **************************************/
FUNCTION AnltSpecImpGetCondition(inSignName VARCHAR2,inIds VARCHAR2 DEFAULT NULL,inProduct IN NUMBER DEFAULT 0) RETURN CLOB
  IS
    vCond CLOB;
    vBuff VARCHAR2(32700);
    vCou INTEGER := 0;
BEGIN
  dbms_lob.createtemporary(vCond,TRUE);
  FOR idx IN (
    SELECT rul.rule_id
      FROM skb_ecc_new.ecc_rule rul
      WHERE skb_ecc_new.getdim(rul.dim_key,CASE WHEN inProduct = 0 THEN 'D38328296CBF147E5A0794D9AF4FB1F59DFFACBD' ELSE '597074F6BDD5CDBFCBBA37523F1D0C4D72BB0B23' END) = inSignName
        AND (inIds IS NULL OR inIds IS NOT NULL AND rul.rule_id IN (SELECT str FROM TABLE(parse_str(inIds,','))))
  ) LOOP
    IF vCou = 0 THEN
      vBuff := REPLACE(REPLACE(dbms_lob.substr(skb_ecc_new.rule_pkg.getSqlCondition(idx.rule_id,'N')),'t.','anlt.'),'T.','anlt.');
      ELSE vBuff := CHR(10)||' OR '||CHR(10)||REPLACE(REPLACE(dbms_lob.substr(skb_ecc_new.rule_pkg.getSqlCondition(idx.rule_id,'N')),'t.','anlt.'),'T.','anlt.');
    END IF;
    dbms_lob.writeappend(vCond,LENGTH(vBuff),vBuff);
    vCou := vCou + 1;
  END LOOP;
  RETURN vCond;
EXCEPTION WHEN OTHERS THEN
  RETURN 'ERROR :: '||inSignName||' :: '||SQLERRM;
END AnltSpecImpGetCondition;

PROCEDURE AnltSpecImport(inDate IN DATE,inAnltCode IN VARCHAR2)
  IS
    vAnltID NUMBER;
    vMes VARCHAR2(4000);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  vMes := 'START :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.AnltSpecImport" started.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.AnltSpecImport',vMes);

  FOR idx IN (
    SELECT str AS AnltCode FROM TABLE(parse_str(inAnltCode,','))
  ) LOOP
    BEGIN
      -- ИД аналитики
      SELECT id
        INTO vAnltID
        FROM tb_signs_anlt
        WHERE anlt_code = UPPER(idx.AnltCode) AND inDate BETWEEN effective_start AND effective_end;

      MERGE INTO tb_signs_anlt_spec dest
        USING (SELECT vAnltID AS anlt_id,val,parent_val,name,condition
                 FROM TABLE(get_anlt_spec_imp(inDate,UPPER(idx.AnltCode)))
              ) src ON (dest.anlt_id = src.anlt_id AND dest.anlt_spec_val = src.val)
        WHEN NOT MATCHED THEN
          INSERT (dest.id,dest.anlt_id,dest.anlt_spec_val,dest.parent_val,dest.anlt_spec_name,dest.condition)
            VALUES (tb_signs_anlt_spec_id_seq.nextval,src.anlt_id,src.val,src.parent_val,src.name,src.condition)
        WHEN MATCHED THEN
          UPDATE SET dest.parent_val = src.parent_val
                    ,dest.anlt_spec_name = src.name
                    ,dest.condition = src.condition
            WHERE (isEqual(dest.parent_val,src.parent_val) = 0 OR
                   isEqual(dest.anlt_spec_name,src.name) = 0 OR
                   isEqual(dest.condition,src.condition) = 0)
                   AND dbms_lob.substr(src.condition,1,30) != '1 = 0'
                   AND dest.block_import = 0;

      vMes := 'SUCCESSFULLY :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Аналитика "'||UPPER(idx.AnltCode)||'"  - '||SQL%ROWCOUNT||' rows merged into table "'||vOwner||'.tb_signs_anlt_spec"';
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.AnltSpecImport',vMes);
      COMMIT;
    EXCEPTION WHEN NO_DATA_FOUND THEN
      vMes := 'ERROR :: "'||UPPER(idx.AnltCode)||'"  - Аналитика не найдена в таблице "'||lower(vOwner)||'.tb_signs_anlt"';
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.AnltSpecImport',vMes);
    END;
  END LOOP;

  vEndTime := SYSDATE;
  vMes := 'FINISH :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.AnltSpecImport" finished sucessfully in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.AnltSpecImport',vMes);
EXCEPTION WHEN OTHERS THEN
    vEndTime := SYSDATE;
    vMes := 'ERROR :: "'||UPPER(inAnltCode)||'"  - '||SQLERRM;
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.AnltSpecImport',vMes);
    vMes := 'FINISH :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.AnltSpecImport" finished in '||get_ti_as_hms(vEndTime - vBegTime)||' with errors';
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.AnltSpecImport',vMes);
END AnltSpecImport;

/********************* ЗВЕЗДЫ И ВСЁ ЧТО С НИМИ СВЯЗАНО **********************************/
FUNCTION  GetAnltLineSQL(inSQL IN CLOB,inIDName IN VARCHAR2
  ,inPIDName IN VARCHAR2,inName IN VARCHAR2,inValue IN VARCHAR2) RETURN CLOB
  IS
    vMaxLev INTEGER;
    vBuff VARCHAR2(32700);
    vWith CLOB;
    vSQL CLOB;
    vSel VARCHAR2(32700);
    vSelNames VARCHAR2(32700);
    vSelIDs VARCHAR2(32700);
    vSelValues VARCHAR2(32700);
BEGIN
  vBuff :=
  'DECLARE'||CHR(10)||
  '  vMaxLev INTEGER;'||CHR(10)||
  'BEGIN'||CHR(10)||
  'SELECT MAX(LEVEL) INTO vMaxLev FROM ('||inSQL||') CONNECT BY PRIOR '||inIDName||' = '||inPIDName||CHR(10)||
  'START WITH '||inPIDName||' IS NULL;'||CHR(10)||
  ':1 := vMaxLev;'||CHR(10)||
  'END;';

  EXECUTE IMMEDIATE vBuff USING OUT vMaxLev;
  --dbms_output.put_line(vBuff);

  FOR idx IN 1..vMaxLev LOOP
    vBuff :=
    'DECLARE'||CHR(10)||
    '  vId VARCHAR2(32700);'||CHR(10)||
    '  vName VARCHAR2(32700);'||CHR(10)||
    '  vValue VARCHAR2(32700);'||CHR(10)||
    'BEGIN'||CHR(10)||
    '  SELECT id'||idx||',lev_name'||idx||',lev_value'||idx||CHR(10)||
    '    INTO vId,vName,vValue'||CHR(10)||
    '    FROM ('||CHR(10)||
    '      SELECT '||inIDName||' AS id,'||inPIDName||' AS parent_id,'||inName||' AS lev_name,'||inValue||' AS lev_value,LEVEL AS lev'||CHR(10)||
    '        ,SUBSTR(sys_connect_by_path(''lev''||to_char(abs(LEVEL - '||idx||') + 1)||''.id'','',''),2,LENGTH(sys_connect_by_path(''lev''||to_char(abs(LEVEL - '||idx||') + 1)||''.id'','','')) - 1) AS id'||idx||CHR(10)||
    '        ,SUBSTR(sys_connect_by_path(''lev''||to_char(abs(LEVEL - '||idx||') + 1)||''.lev_name'','',''),2,LENGTH(sys_connect_by_path(''lev''||to_char(abs(LEVEL - '||idx||') + 1)||''.lev_name'','','')) - 1) AS lev_name'||idx||CHR(10)||
    '        ,SUBSTR(sys_connect_by_path(''lev''||to_char(abs(LEVEL - '||idx||') + 1)||''.lev_value'','',''),2,LENGTH(sys_connect_by_path(''lev''||to_char(abs(LEVEL - '||idx||') + 1)||''.lev_value'','','')) - 1) AS lev_value'||idx||CHR(10)||
    '        FROM ('||inSQL||')'||CHR(10)||
    '      CONNECT BY PRIOR '||inIDName||' = '||inPIDName||CHR(10)||
    '      START WITH '||inPIDName||' IS NULL'||CHR(10)||
    '  ) WHERE lev = '||idx||'  GROUP BY id'||idx||',lev_name'||idx||',lev_value'||idx||';'||CHR(10)||
    '  :1 := vId;'||CHR(10)||
    '  :2 := vName;'||CHR(10)||
    '  :3 := vValue;'||CHR(10)||
    'END;'||CHR(10);

    EXECUTE IMMEDIATE vBuff USING OUT vSelIDs,OUT vSelNames,OUT vSelValues;
    --dbms_output.put_line(vBuff);

    IF idx = 1 THEN
      vSel := 'lev'||idx||'.id AS id'||idx||',lev'||idx||'.lev_name AS name'||idx||',lev'||idx||'.lev_value AS value'||idx||CHR(10);
    ELSE
      vSel := vSel||',COALESCE('||vSelIDs||') AS id'||idx||',COALESCE('||vSelNames||') AS name'||idx||',COALESCE('||vSelValues||') AS value'||idx||CHR(10);
    END IF;
  END LOOP;

  dbms_lob.createtemporary(vWith,FALSE);
  dbms_lob.createtemporary(vSQL,FALSE);

  vBuff := 'WITH'||CHR(10);
  dbms_lob.writeappend(vWith,LENGTH(vBuff),vBuff);

  FOR idx IN 1..vMaxLev LOOP
    vBuff :=
    '  '||CASE WHEN idx > 1 THEN ',' ELSE NULL END||'lev'||idx||' AS ('||CHR(10)||
    '  SELECT id,parent_id,lev_name,lev_value,lev'||CHR(10)||
    '    FROM ('||CHR(10)||
    '      SELECT '||inIDName||' AS id,'||inPIDName||' AS parent_id,'||inName||' AS lev_name,'||inValue||' AS lev_value, LEVEL AS lev'||CHR(10)||
    '        FROM ('||inSQL||')'||CHR(10)||
    '      CONNECT BY PRIOR '||inIDName||' = '||inPIDName||CHR(10)||
    '      START WITH '||inPIDName||' IS NULL'||CHR(10)||
    '  ) WHERE lev BETWEEN '||idx||' - 1 AND '||idx||CHR(10)||
    ')'||CHR(10);
    dbms_lob.writeappend(vWith,LENGTH(vBuff),vBuff);

    IF idx > 1 THEN
      vBuff := '       LEFT JOIN lev'||idx||' ON lev'||idx||'.lev = '||idx||' AND lev'||idx||'.parent_id = lev'||to_char(idx - 1)||'.id OR'||CHR(10)||
               '                                 lev'||idx||'.lev = '||idx||' - 1 AND lev'||idx||'.id = lev'||to_char(idx - 1)||'.id'||CHR(10);
    ELSE
      vBuff := CHR(10)||'  FROM lev1'||CHR(10);
    END IF;
    dbms_lob.writeappend(vSQL,LENGTH(vBuff),vBuff);
  END LOOP;

  RETURN vWith||'SELECT '||vSel||vSQL;
END GetAnltLineSQL;


PROCEDURE StarPrepareDim(inDate IN DATE,inGroupID IN NUMBER,inEntityID IN NUMBER)
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
    -- список наименований полей через запятую (для использования при построении динамического SQL)
    vFieldsForCreate VARCHAR2(32700);
    --
    vDDL CLOB;

    vBuff VARCHAR2(32700);
    vStarDimTable VARCHAR2(256) := vOwner||'.dim_'||inGroupID||'#'||inEntityID; -- наименование таблицы фактов в звезде
    vGroupName VARCHAR2(4000);   -- наименование группы показателей
    vEntityName VARCHAR2(4000);  -- нименование сущности
    vTabCou INTEGER;

    vMes VARCHAR2(4000);
    vTIBegin DATE;
    vENdTime DATE;
BEGIN
  -- Получение наименования группы
  SELECT group_name INTO vGroupName FROM tb_signs_group WHERE group_id = inGroupID;
  -- Получение наименования сущности
  SELECT entity_name INTO vEntityName FROM tb_entity WHERE id = inEntityID;

  /*******************************************************************/
  vTIBegin := SYSDATE;
  vMes := 'CONTINUE :: ------------ "'||to_char(inDate,'DD.MM.YYYY')||'" - Группа: "'||vGroupName||'" - Сущность: "'||vEntityName||'" - начало подготовки таблицы -----------';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarPrepareDim',vMes);

  /*******************************************************************/

  -- Формирование строковых переменных со списком полей через запятую
  vFieldsForCreate := NULL;
  FOR idx IN (
    SELECT DISTINCT
           NVL(s2g.sgn_alias,p.sign_name) AS sign_name
          ,p.data_type
          ,LISTAGG(p.sign_descr,'; ') WITHIN GROUP (ORDER BY p.id) OVER (PARTITION BY NVL(s2g.sgn_alias,p.sign_name)) AS sign_descr
      FROM tb_signs_2_group s2g
           INNER JOIN tb_signs_pool p
             ON p.sign_name = s2g.sign_name
                AND p.entity_id IN (SELECT id FROM tb_entity CONNECT BY PRIOR id = parent_id
                                    START WITH id = inEntityID)
      WHERE s2g.group_id = inGroupID
  ) LOOP
        vFieldsForCreate := vFieldsForCreate||','||idx.sign_name||' '||
        CASE WHEN idx.data_type = 'Число' THEN 'NUMBER'
             WHEN idx.data_type = 'Дата' THEN 'DATE'
          ELSE 'VARCHAR2(4000)'
        END;
  END LOOP;

  dbms_lob.createtemporary(vDDL,FALSE);

  vBuff :=
  'DECLARE'||CHR(10)||
  '  vBuff VARCHAR2(32700);'||CHR(10)||
  'BEGIN'||CHR(10);
  dbms_lob.writeappend(vDDL,LENGTH(vBuff),vBuff);

  -- Проверка на существование таблицы измерения для звезды
  SELECT COUNT(1) INTO vTabCou FROM dba_all_tables
    WHERE owner = UPPER(vOwner) AND table_name = 'DIM_'||inGroupID||'#'||inEntityID;

  -- ЕСЛИ ТАБЛИЦА ОТСУТСТВУЕТ, ТО СОЗДАЕМ
  IF vTabCou = 0 THEN
    vBuff :=
    '  EXECUTE IMMEDIATE ''CREATE TABLE '||vStarDimTable||CHR(10)||
    '   (as_of_date DATE,obj_sid NUMBER'||vFieldsForCreate||')'||CHR(10)||
    '   PARTITION BY LIST (as_of_date) '||CHR(10)||
    '   (PARTITION P'||to_char(inDate,'RRRRMMDD')||' VALUES(to_date('''''||to_char(inDate,'DD.MM.YYYY')||''''',''''DD.MM.YYYY'''')) STORAGE (INITIAL 64K NEXT 4M)) NOLOGGING'';'||CHR(10)||CHR(10);
    dbms_lob.writeappend(vDDL,LENGTH(vBuff),vBuff);

    -- Комментарии для колонок таблицы
    vBuff := '  EXECUTE IMMEDIATE ''COMMENT ON COLUMN '||vStarDimTable||'.as_of_date IS ''''Отчетная дата'''' '';'||CHR(10);
    dbms_lob.writeappend(vDDL,LENGTH(vBuff),vBuff);
    vBuff := '  EXECUTE IMMEDIATE ''COMMENT ON COLUMN '||vStarDimTable||'.obj_sid IS ''''Ид объекта (уникально в переделах одной даты). Используется для связки с фактами (по ключевым полям фактов).'''' '';'||CHR(10);
    dbms_lob.writeappend(vDDL,LENGTH(vBuff),vBuff);
    FOR idx IN (
      SELECT DISTINCT
             NVL(s2g.sgn_alias,p.sign_name) AS sign_name
            ,p.data_type
            ,LISTAGG(p.sign_descr,'; ') WITHIN GROUP (ORDER BY p.id) OVER (PARTITION BY NVL(s2g.sgn_alias,p.sign_name)) AS sign_descr
        FROM tb_signs_2_group s2g
             INNER JOIN tb_signs_pool p
               ON p.sign_name = s2g.sign_name
                  AND p.entity_id IN (SELECT id FROM tb_entity CONNECT BY PRIOR id = parent_id
                                      START WITH id = inEntityID)
        WHERE s2g.group_id = inGroupID
    ) LOOP
      vBuff := '  EXECUTE IMMEDIATE ''COMMENT ON COLUMN '||vStarDimTable||'.'||LOWER(idx.sign_name)||' IS '''''||REPLACE(idx.sign_descr,'''','''''')||''''' '';'||CHR(10);
      dbms_lob.writeappend(vDDL,LENGTH(vBuff),vBuff);
    END LOOP;
    -- Вешаем комментарий на таблицу
    vBuff :=
    '  EXECUTE IMMEDIATE ''COMMENT ON TABLE '||vStarDimTable||' IS ''''Измерение: Группа - "'||vGroupName||'"; Сущность - "'||vEntityName||'"'''' '';'||CHR(10)||
    '  vBuff := ''SUCCESSFULLY :: Table "'||vStarDimTable||'" created''||CHR(10);'||CHR(10);
    dbms_lob.writeappend(vDDL,LENGTH(vBuff),vBuff);

 -- ЕСЛИ ТАБЛИЦА УЖЕ СУЩЕСТВУЕТ
  ELSE
    -- Если партиция отсутствует - добавляем
    vBuff :=
    '  BEGIN'||CHR(10)||
    '    EXECUTE IMMEDIATE ''ALTER TABLE '||vStarDimTable||' ADD PARTITION P'||to_char(inDate,'RRRRMMDD')||' VALUES (to_date('''''||to_char(inDate,'DD.MM.YYYY')||''''',''''DD.MM.YYYY'''')) STORAGE (INITIAL 64K NEXT 4M) NOLOGGING'';'||CHR(10)||
    '    vBuff := ''SUCCESSFULLY :: Table "'||vStarDimTable||'" - Partition P'||to_char(inDate,'RRRRMMDD')||' added''||CHR(10);'||CHR(10)||
    '  EXCEPTION WHEN OTHERS THEN'||CHR(10)||
    '    NULL;'||CHR(10)||
    '  END;'||CHR(10);
    dbms_lob.writeappend(vDDL,LENGTH(vBuff),vBuff);

    -- Т.к., к моменту текущего разворачивания, ключевые колонки (как количество так и наименование), могут измениться
    -- то необходимо добавить недостающие (если таковые найдутся)
    -- !!!Пока что предполагается, что количество может только увеличиться!!!
    FOR idx IN (
      SELECT DISTINCT
             NVL(s2g.sgn_alias,p.sign_name) AS sign_name
            ,CASE WHEN p.data_type = 'Число' THEN 'NUMBER'
                  WHEN p.data_type = 'Дата' THEN 'DATE'
               ELSE 'VARCHAR2(4000)'
             END AS data_type
            ,LISTAGG(p.sign_descr,'; ') WITHIN GROUP (ORDER BY p.id) OVER (PARTITION BY NVL(s2g.sgn_alias,p.sign_name)) AS sign_descr
        FROM tb_signs_2_group s2g
             INNER JOIN tb_signs_pool p
               ON p.sign_name = s2g.sign_name
                  AND p.entity_id IN (SELECT id FROM tb_entity CONNECT BY PRIOR id = parent_id
                                      START WITH id = inEntityID)
        WHERE s2g.group_id = inGroupID
      MINUS
      SELECT c.column_name
            ,c.data_type
            ,cmnt.comments
        FROM all_tab_columns c
             INNER JOIN all_col_comments cmnt
               ON cmnt.owner = c.owner
                  AND cmnt.table_name = c.table_name
                  AND cmnt.column_name = c.column_name
        WHERE c.owner = UPPER(vOwner)
          AND c.table_name = UPPER(SUBSTR(vStarDimTable,INSTR(vStarDimTable,'.',1) + 1,LENGTH(vStarDimTable) - INSTR(vStarDimTable,'.',1)))
          AND NOT(c.column_name IN ('AS_OF_DATE'))
    ) LOOP
      vBuff :=
      '  BEGIN'||CHR(10)||
      -- Добавление колонки
      '    EXECUTE IMMEDIATE ''ALTER TABLE '||vStarDimTable||' ADD '||idx.sign_name||' '||idx.data_type||' '';'||CHR(10)||
      -- Добавление комментария
      '    EXECUTE IMMEDIATE ''COMMENT ON COLUMN '||vStarDimTable||'.'||LOWER(idx.sign_name)||' IS '''''||REPLACE(idx.sign_descr,'''','''''')||''''' '';'||CHR(10)||
      '    vBuff := vBuff||''SUCCESSFULLY :: Column "'||vStarDimTable||'.'||lower(idx.sign_name)||'" added''||CHR(10);'||CHR(10)||
      '  EXCEPTION WHEN OTHERS THEN'||CHR(10)||
      '    NULL;'||CHR(10)||
      '  END;'||CHR(10);
      dbms_lob.writeappend(vDDL,LENGTH(vBuff),vBuff);
    END LOOP;
  END IF;

  -- Финальный END
  vBuff :=
  '  :1 := vBuff;'||CHR(10)||
  'END;'||CHR(10);
  dbms_lob.writeappend(vDDL,LENGTH(vBuff),vBuff);

  EXECUTE IMMEDIATE vDDL USING OUT vMes;
  --dbms_output.put_line(vDDL);
  IF vMes IS NULL THEN
    vMes := 'SUCCESSFULLY :: Table "'||vStarDimTable||'" - подготовка не требуется';
  END IF;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarPrepareDim',vMes);

  vEndTime := SYSDATE;
  vMes := 'CONTINUE :: ------------ "'||to_char(inDate,'DD.MM.YYYY')||'" - Группа: "'||vGroupName||'" - Сущность: "'||vEntityName||'" - окончание подготовки таблицы. Время выполнения: '||get_ti_as_hms(vEndTime - vTIBegin)||' -----------';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarPrepareDim',vMes);

EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarPrepareDim" :: '||SQLERRM;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarPrepareDim',vMes);
END StarPrepareDim;

PROCEDURE StarPrepareFct(inDate IN DATE,inGroupID IN NUMBER)
  IS
    vResBuff VARCHAR2(500);
    --
    vBuff VARCHAR2(32700);
    vCreateDDL CLOB;
    vAddPartDDL CLOB;
    vAddSubPartDDL CLOB;
    vFields VARCHAR2(32700);
    vCreateFields VARCHAR2(32700);
    vAnltCodes VARCHAR2(32700);
    vPartCou INTEGER := 0;
    vGroupName VARCHAR2(4000);

    vMes VARCHAR2(4000);
    vTIBegin DATE;
    vENdTime DATE;
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  -- Получение наименования группы
  SELECT group_name INTO vGroupName FROM tb_signs_group WHERE group_id = inGroupID;

  vTIBegin := SYSDATE;
  vMes := 'CONTINUE :: ------------ "'||to_char(inDate,'DD.MM.YYYY')||'" - Группа: "'||vGroupName||'" - начало подготовки таблицы -----------';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarPrepareFct',vMes);

  -- Получение и сохранение в строки ключевых колонок
  SELECT LISTAGG(anlt_alias,',') WITHIN GROUP (ORDER BY anlt_alias) AS Fields
        ,LISTAGG(anlt_alias||CASE WHEN data_type = 'Число' THEN ' NUMBER'
                      WHEN data_type = 'Дата' THEN ' DATE'
                 ELSE ' VARCHAR2(4000)' END
                 ,',') WITHIN GROUP (ORDER BY anlt_alias) AS CreateFields
        ,LISTAGG(anlt_alias||CASE WHEN data_type = 'Число' THEN ' NUMBER'
                      WHEN data_type = 'Дата' THEN ' DATE'
                 ELSE ' VARCHAR2(4000)' END||';'||anlt_alias_descr
                 ,',') WITHIN GROUP (ORDER BY anlt_alias) AS anlt_alias_descr
    INTO vFields,vCreateFields,vAnltCodes
    FROM (
      SELECT a.anlt_alias
            ,a.data_type
            ,MAX(a.anlt_alias_descr) AS anlt_alias_descr
        FROM tb_signs_2_group s2g
             INNER JOIN tb_signs_group g
               ON g.parent_group_id = s2g.group_id
             INNER JOIN tb_sign_2_anlt s2a
               ON s2a.sign_name = s2g.sign_name
                  AND EXISTS (SELECT NULL FROM tb_anlt_2_group WHERE anlt_code = s2a.anlt_code AND group_id = g.group_id)
             INNER JOIN tb_signs_anlt a
               ON a.anlt_code = s2a.anlt_code
                  AND inDate BETWEEN a.effective_start AND a.effective_end
        WHERE s2g.group_id = inGroupID
      GROUP BY a.anlt_alias,a.data_type
    );

  /*********************** Формирование и выполнение CreateDDL *****************************/

  dbms_lob.createtemporary(vCreateDDL,FALSE);

  vBuff :=
  'BEGIN'||CHR(10);
  dbms_lob.writeappend(vCreateDDL,LENGTH(vBuff),vBuff);

  -- Формирование добавления вновь появившихся ключевых колонок. Если ошибка, то таблица не существует.
  -- Оборачиваем блок добавления EXCEPTION'ом на такой случай
  FOR alt IN (
   SELECT '  BEGIN'||CHR(10)||
          '    EXECUTE IMMEDIATE ''ALTER TABLE '||LOWER(vOwner)||'.fct_'||inGroupID||' ADD '||SUBSTR(b.str,1,INSTR(b.str,';',1,1)-1)||''';'||CHR(10)||
          '    EXECUTE IMMEDIATE ''COMMENT ON COLUMN '||LOWER(vOwner)||'.fct_'||inGroupID||'.'||LOWER(SUBSTR(b.str,1,INSTR(b.str,' ',1,1)-1))||' IS '''''||a.anlt_alias_descr||''''' '';'||CHR(10)||
          '  EXCEPTION WHEN OTHERS THEN'||CHR(10)||
          '    NULL;'||CHR(10)||
          '  END;'||CHR(10) AS alt_ddl
     FROM TABLE(parse_str(vAnltCodes,',')) b
          LEFT JOIN tb_signs_anlt a
            ON a.anlt_code = SUBSTR(b.str,INSTR(b.str,';',1,1) + 1,LENGTH(b.str))
               AND inDate BETWEEN a.effective_start AND a.effective_end
  ) LOOP
    vBuff := alt.alt_ddl;
    dbms_lob.writeappend(vCreateDDL,LENGTH(vBuff),vBuff);
  END LOOP;

  -- Создание таблицы
  vBuff :=
  '  EXECUTE IMMEDIATE'||CHR(10)||
  '  ''CREATE TABLE '||LOWER(vOwner)||'.fct_'||inGroupID||CHR(10)||
  '    (as_of_date DATE'||CHR(10)||
  '    ,obj_gid NUMBER'||CHR(10)||
  '    ,source_system_id NUMBER'||CHR(10)||
  '    ,sign_name VARCHAR2(256)'||CHR(10)||
  '    ,sgn_alias VARCHAR2(256)'||CHR(10)||
  '    ,sign_val VARCHAR2(4000),'||CHR(10)||vCreateFields||')'||CHR(10)||
  '  PARTITION BY LIST (as_of_date)'||CHR(10)||
  '  SUBPARTITION BY LIST (sgn_alias) ('||CHR(10)||
  '  PARTITION P'||to_char(inDate,'RRRRMMDD')||' VALUES(to_date('''''||to_char(inDate,'DD.MM.YYYY')||''''',''''DD.MM.YYYY'''')) STORAGE(INITIAL 64K NEXT 4M) NOLOGGING ('||CHR(10);
  dbms_lob.writeappend(vCreateDDL,LENGTH(vBuff),vBuff);

  FOR idx IN (
    SELECT DISTINCT
           NVL(s2g.sgn_alias,s2g.sign_name) AS sign_name
          ,'SP'||ora_hash(NVL(s2g.sgn_alias,s2g.sign_name)) AS sp_code
      FROM tb_signs_2_group s2g
           INNER JOIN tb_signs_pool p
             ON p.sign_name = s2g.sign_name
      WHERE s2g.group_id = inGroupID
  ) LOOP
     vBuff :=
     '   '||CASE WHEN vPartCou > 0 THEN ',' END||'SUBPARTITION '||idx.sp_code||'_'||to_char(inDate,'RRRRMMDD')||' VALUES('''''||idx.sign_name||''''')'||CHR(10);
     dbms_lob.writeappend(vCreateDDL,LENGTH(vBuff),vBuff);
     vPartCou := vPartCou + 1;
  END LOOP;

  vBuff := '  )) NOLOGGING''; '||CHR(10)||CHR(10);
  dbms_lob.writeappend(vCreateDDL,LENGTH(vBuff),vBuff);

  -- Добавление комментариев на колонки
  vBuff :=
  '  EXECUTE IMMEDIATE ''COMMENT ON COLUMN '||LOWER(vOwner)||'.fct_'||inGroupID||'.as_of_date IS ''''Отчетная дата'''' '';'||CHR(10)||
  '  EXECUTE IMMEDIATE ''COMMENT ON COLUMN '||LOWER(vOwner)||'.fct_'||inGroupID||'.obj_gid IS ''''ИД объекта (зависит от сущности, например на договорах CONTRACT_GID и т.д.)'''' '';'||CHR(10)||
  '  EXECUTE IMMEDIATE ''COMMENT ON COLUMN '||LOWER(vOwner)||'.fct_'||inGroupID||'.source_system_id IS ''''ИД системы - источника'''' '';'||CHR(10)||
  '  EXECUTE IMMEDIATE ''COMMENT ON COLUMN '||LOWER(vOwner)||'.fct_'||inGroupID||'.sign_name IS ''''Наименование показателя'''' '';'||CHR(10)||
  '  EXECUTE IMMEDIATE ''COMMENT ON COLUMN '||LOWER(vOwner)||'.fct_'||inGroupID||'.sgn_alias IS ''''Альяс показателя'''' '';'||CHR(10)||
  '  EXECUTE IMMEDIATE ''COMMENT ON COLUMN '||LOWER(vOwner)||'.fct_'||inGroupID||'.sign_val IS ''''Значение показателя'''' '';'||CHR(10);
  dbms_lob.writeappend(vCreateDDL,LENGTH(vBuff),vBuff);

  FOR idx IN (
    SELECT DISTINCT
           a.anlt_alias
          ,MAX(a.anlt_alias_descr) KEEP (dense_rank LAST ORDER BY a.effective_start) AS col_descr
      FROM tb_signs_2_group s2g
           INNER JOIN tb_signs_group g
             ON g.parent_group_id = s2g.group_id
           INNER JOIN tb_sign_2_anlt s2a
             ON s2a.sign_name = s2g.sign_name
                AND EXISTS (SELECT NULL FROM tb_anlt_2_group WHERE anlt_code = s2a.anlt_code AND group_id = g.group_id)
           INNER JOIN tb_signs_anlt a
             ON a.anlt_code = s2a.anlt_code
                AND inDate BETWEEN a.effective_start AND a.effective_end
      WHERE s2g.group_id = inGroupID
    GROUP BY a.anlt_alias
  ) LOOP
    vBuff := '  EXECUTE IMMEDIATE ''COMMENT ON COLUMN '||LOWER(vOwner)||'.fct_'||inGroupID||'.'||LOWER(idx.anlt_alias)||' IS '''''||idx.col_descr||''''' '';'||CHR(10);
    dbms_lob.writeappend(vCreateDDL,LENGTH(vBuff),vBuff);
  END LOOP;

  -- Добавление комментария на таблицу
  vBuff := '  EXECUTE IMMEDIATE ''COMMENT ON TABLE '||LOWER(vOwner)||'.fct_'||inGroupID||' IS '''''||vGroupNAme||''''' '';'||CHR(10);
  dbms_lob.writeappend(vCreateDDL,LENGTH(vBuff),vBuff);

  -- Логирование и обработка ошибок
  vBuff :=
  '  :1 := ''SUCCESSFULLY :: Table "'||LOWER(vOwner)||'.fct_'||inGroupID||'" created'';'||CHR(10)||
  'EXCEPTION WHEN OTHERS THEN'||CHR(10)||
  '  :1 := NULL;'||CHR(10)||
  'END;';
  dbms_lob.writeappend(vCreateDDL,LENGTH(vBuff),vBuff);

  EXECUTE IMMEDIATE vCreateDDL USING OUT vResBuff;
  --dbms_output.put_line(vCreateDDL);

  IF vResBuff IS NOT NULL THEN
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarPrepareFct',vResBuff);
  END IF;

  /*********************** Формирование и выполнение AddPartDDL *****************************/
  dbms_lob.createtemporary(vAddPartDDL,FALSE);

  vBuff :=
  'BEGIN'||CHR(10)||
  '  EXECUTE IMMEDIATE ''ALTER TABLE '||LOWER(vOwner)||'.fct_'||inGroupID||' ADD PARTITION P'||to_char(inDate,'RRRRMMDD')||' VALUES(to_date('''''||to_char(inDate,'DD.MM.YYYY')||''''',''''DD.MM.YYYY'''')) STORAGE(INITIAL 64K NEXT 4M) NOLOGGING ('||CHR(10);
  dbms_lob.writeappend(vAddPartDDL,LENGTH(vBuff),vBuff);

  vPartCou := 0;
  FOR idx IN (
    SELECT DISTINCT
           NVL(s2g.sgn_alias,s2g.sign_name) AS sign_name
          ,'SP'||ora_hash(NVL(s2g.sgn_alias,s2g.sign_name)) AS sp_code
      FROM tb_signs_2_group s2g
           INNER JOIN tb_signs_pool p
             ON p.sign_name = s2g.sign_name
      WHERE s2g.group_id = inGroupID
  ) LOOP
     vBuff :=
     '   '||CASE WHEN vPartCou > 0 THEN ',' END||'SUBPARTITION '||idx.sp_code||'_'||to_char(inDate,'RRRRMMDD')||' VALUES('''''||idx.sign_name||''''')'||CHR(10);
     dbms_lob.writeappend(vAddPartDDL,LENGTH(vBuff),vBuff);
     vPartCou := vPartCou + 1;
  END LOOP;

  vBuff :=
  ')'';'||CHR(10)||
  '  :1 := ''SUCCESSFULLY :: Table "'||LOWER(vOwner)||'.fct_'||inGroupID||'" - Partition P'||to_char(inDate,'RRRRMMDD')||' added'';'||CHR(10)||
  'EXCEPTION WHEN OTHERS THEN'||CHR(10)||
  '  :1 := NULL;'||CHR(10)||
  'END;';
  dbms_lob.writeappend(vAddPartDDL,LENGTH(vBuff),vBuff);

  EXECUTE IMMEDIATE vAddPartDDL USING OUT vResBuff;
  --dbms_output.put_line(vAddPartDDL);

  IF vResBuff IS NOT NULL THEN
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarPrepareFct',vResBuff);
  END IF;

  /*********************** Формирование и выполнение AddSubPartDDL *****************************/

  dbms_lob.createtemporary(vAddSubPartDDL,FALSE);

  vBuff :=
  'DECLARE'||CHR(10)||
  '  vCou INTEGER := 0;'||CHR(10)||
  'BEGIN'||CHR(10);
  dbms_lob.writeappend(vAddSubPartDDL,LENGTH(vBuff),vBuff);

  FOR idx IN (
    SELECT DISTINCT
           NVL(s2g.sgn_alias,s2g.sign_name) AS sign_name
          ,'SP'||ora_hash(NVL(s2g.sgn_alias,s2g.sign_name)) AS sp_code
      FROM tb_signs_2_group s2g
           INNER JOIN tb_signs_pool p
             ON p.sign_name = s2g.sign_name
      WHERE s2g.group_id = inGroupID
  ) LOOP
     vBuff :=
     'BEGIN'||CHR(10)||
     '  EXECUTE IMMEDIATE ''ALTER TABLE '||LOWER(vOwner)||'.fct_'||inGroupID||' MODIFY PARTITION P'||to_char(inDate,'RRRRMMDD')||CHR(10)||
     '    ADD SUBPARTITION '||idx.sp_code||'_'||to_char(inDate,'RRRRMMDD')||' VALUES('''''||idx.sign_name||''''') '';'||CHR(10)||
     '  vCou := vCou + 1;'||CHR(10)||
     'EXCEPTION WHEN OTHERS THEN'||CHR(10)||
     '  NULL;'||CHR(10)||
     'END;'||CHR(10);
     dbms_lob.writeappend(vAddSubPartDDL,LENGTH(vBuff),vBuff);
  END LOOP;

  vBuff :=
  '  :1 := ''SUCCESSFULLY :: Table "'||LOWER(vOwner)||'.fct_'||inGroupID||'" - ''||vCou||'' SubPartitions added'';'||CHR(10)||
  'EXCEPTION WHEN OTHERS THEN'||CHR(10)||
  '  :1 := NULL;'||CHR(10)||
  'END;'||CHR(10);
  dbms_lob.writeappend(vAddSubPartDDL,LENGTH(vBuff),vBuff);

  EXECUTE IMMEDIATE vAddSubPartDDL USING OUT vResBuff;
  --dbms_output.put_line(vAddSubPartDDL);

  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarPrepareFct',vResBuff);

  vEndTime := SYSDATE;
  vMes := 'CONTINUE :: ------------ "'||to_char(inDate,'DD.MM.YYYY')||'" - Группа: "'||vGroupName||'" - окончание подготовки таблицы. Время выполнения: '||get_ti_as_hms(vEndTime - vTIBegin)||' -----------';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarPrepareFct',vMes);
EXCEPTION WHEN OTHERS THEN
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarPrepareFct','ERROR :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Группа: "'||vGroupName||' :: '||SQLERRM);
END StarPrepareFct;

PROCEDURE StarFctOnDate(inDate IN DATE,inGroupID IN NUMBER,inEntityID IN NUMBER)
  IS
    vTIBegin DATE;
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vMes VARCHAR2(4000);
    -- список наименований полей через запятую (для использования при построении динамического SQL)
    vOtherFields VARCHAR2(4000);
    vAnltFieldsPref VARCHAR2(4000);
    vAnltFields VARCHAR2(4000);
    vAnltJoins VARCHAR2(4000);
    --
    vDML CLOB;

    vBuff VARCHAR2(32700);
    vHistTable VARCHAR2(256);    -- наименование таблицы хранения периодами
    vFctTable VARCHAR2(256);     -- наименование таблицы хранения по датам
    vGroupName VARCHAR2(4000);   -- наименование группы показателей
    vEntityName VARCHAR2(4000);  -- нименование сущности
    vRowCou INTEGER := 0;
    vAnltCou INTEGER := 0;
    vAlsCou INTEGER := 0;
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  vMes := 'START :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarFctOnDate" started.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarFctOnDate',vMes);
  -- Сохранение наименований сущности и её таблиц хранения в переменные
  BEGIN
    SELECT vOwner||'.'||fct_table_name AS FctTable
          ,vOwner||'.'||hist_table_name AS HistTable
          ,entity_name
      INTO vFctTable,vHistTable/*,vFctView*/,vEntityName
      FROM tb_entity
      WHERE ID = inEntityID;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Описание сущности ID = '||inEntityID||' не найдено в таблице '||vOwner||'.tb_entity');
  END;

  -- Сохранение наименования группы в переменную
  BEGIN
    SELECT group_name
      INTO vGroupName
      FROM tb_signs_group
      WHERE group_id = inGroupID;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Описание группы ID = '||inGroupID||' не найдено в таблице '||vOwner||'.tb_signs_group');
  END;

  vTIBegin := SYSDATE;
  vMes := 'CONTINUE :: ------------ "'||to_char(inDate,'DD.MM.YYYY')||'" - Группа: "'||vGroupName||'" - Сущность: "'||vEntityName||'" - вставка данных -----------';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarFctOnDate',vMes);

  -- Формирование строковых переменных со списком полей через запятую
  FOR idx IN (
    SELECT p.sign_name
          ,p.data_type
          ,p.sign_descr
      FROM tb_signs_2_group s2g
           INNER JOIN tb_signs_pool p
             ON p.sign_name = s2g.sign_name
                AND p.entity_id IN (SELECT id FROM tb_entity CONNECT BY PRIOR id = parent_id
                                    START WITH id = inEntityID)
      WHERE s2g.group_id = inGroupID
  ) LOOP
      vOtherFields := vOtherFields||CHR(10)||','''||idx.sign_name||'''';
  END LOOP;
  vOtherFields := SUBSTR(vOtherFields,3,LENGTH(vOtherFields) - 2);

  -- Формирование строк с полями и джойнов для аналитик
  SELECT LISTAGG(anlt_alias||'.'||'sign_val AS '||anlt_alias,',') WITHIN GROUP (ORDER BY anlt_alias) AS FieldsPref
        ,LISTAGG(anlt_alias,',') WITHIN GROUP (ORDER BY anlt_alias) AS Fields
        ,LISTAGG(' LEFT JOIN '||anlt_alias||CHR(10)||
                 '   ON '||anlt_alias||'.'||'sign_name = fct.sign_name'||CHR(10)||
                 '      AND '||anlt_alias||'.'||'obj_gid = fct.obj_gid'||CHR(10)||
                 '      AND '||anlt_alias||'.'||'source_system_id = fct.source_system_id',CHR(10)
                ) WITHIN GROUP (ORDER BY anlt_alias) AS joins
    INTO vAnltFieldsPref,vAnltFields,vAnltJoins
    FROM (
      SELECT a.anlt_alias
        FROM tb_signs_2_group s2g
             INNER JOIN tb_signs_pool p
               ON p.sign_name = s2g.sign_name
                  AND p.entity_id IN (SELECT id FROM tb_entity CONNECT BY PRIOR id = parent_id
                                      START WITH id = inEntityID)
             LEFT JOIN tb_sign_2_anlt s2a
               ON s2a.sign_name = s2g.sign_name
                  AND EXISTS (SELECT NULL
                                FROM tb_anlt_2_group
                                WHERE anlt_code = s2a.anlt_code
                                  AND group_id IN (SELECT group_id FROM tb_signs_group
                                                   CONNECT BY PRIOR group_id = parent_group_id
                                                   START WITH group_id = inGroupID)
                             )
             LEFT JOIN tb_signs_anlt a
               ON a.anlt_code = s2a.anlt_code
                  AND inDate BETWEEN a.effective_start AND a.effective_end
        WHERE s2g.group_id = inGroupID
      GROUP BY a.anlt_alias
  );

  dbms_lob.createtemporary(vDML,FALSE);
  vBuff :=
  'BEGIN'||CHR(10)||
  'EXECUTE IMMEDIATE ''ALTER SESSION SET nls_numeric_characters = '''', '''''';'||CHR(10)||
  'EXECUTE IMMEDIATE ''ALTER SESSION SET nls_date_format = ''''DD.MM.YYYY HH24:MI:SS'''''';'||CHR(10)||
  'INSERT INTO '||lower(vOwner)||'.fct_'||inGroupID||'(as_of_date,obj_gid,source_system_id,sign_name,sgn_alias,sign_val,'||vAnltFields||')'||CHR(10)||
  'WITH'||CHR(10);
  dbms_lob.writeappend(vDML,LENGTH(vBuff),vBuff);

  -- Формирование подзапросов для аналитик
  FOR als IN (
    SELECT a.anlt_alias
      FROM tb_signs_2_group s2g
           INNER JOIN tb_signs_pool p
             ON p.sign_name = s2g.sign_name
                AND p.entity_id IN (SELECT id FROM tb_entity CONNECT BY PRIOR id = parent_id
                                    START WITH id = inEntityID)
           LEFT JOIN tb_sign_2_anlt s2a
             ON s2a.sign_name = s2g.sign_name
                AND EXISTS (SELECT NULL
                              FROM tb_anlt_2_group
                              WHERE anlt_code = s2a.anlt_code
                                AND group_id IN (SELECT group_id FROM tb_signs_group
                                                 CONNECT BY PRIOR group_id = parent_group_id
                                                 START WITH group_id = inGroupID)
                           )
           LEFT JOIN tb_signs_anlt a
             ON a.anlt_code = s2a.anlt_code
                AND inDate BETWEEN a.effective_start AND a.effective_end
      WHERE s2g.group_id = inGroupID
    GROUP BY a.anlt_alias
  ) LOOP
    vBuff := CASE WHEN vAlsCou > 0 THEN ',' END||als.anlt_alias||' AS ('||CHR(10);
    dbms_lob.writeappend(vDML,LENGTH(vBuff),vBuff);
    vAnltCou := 0;
    FOR idx IN (
      SELECT LISTAGG(''''||p.sign_name||'''',',') WITHIN GROUP (ORDER BY s2g.sign_name) AS sign_name
            ,s2a.anlt_code
            ,lower(vOwner)||'.'||e.fct_table_name AS a_fct_table
            ,lower(vOwner)||'.'||e.hist_table_name AS a_hist_table
            ,a.anlt_alias
        FROM tb_signs_2_group s2g
             INNER JOIN tb_signs_pool p
               ON p.sign_name = s2g.sign_name
                  AND p.entity_id IN (SELECT id FROM tb_entity CONNECT BY PRIOR id = parent_id
                                      START WITH id = inEntityID)
             LEFT JOIN tb_sign_2_anlt s2a
               ON s2a.sign_name = s2g.sign_name
                  AND EXISTS (SELECT NULL
                                FROM tb_anlt_2_group
                                WHERE anlt_code = s2a.anlt_code
                                  AND group_id IN (SELECT group_id FROM tb_signs_group
                                                   CONNECT BY PRIOR group_id = parent_group_id
                                                   START WITH group_id = inGroupID)
                             )
             LEFT JOIN tb_signs_anlt a
               ON a.anlt_code = s2a.anlt_code
                  AND inDate BETWEEN a.effective_start AND a.effective_end
             LEFT JOIN tb_entity e
               ON e.id = a.entity_id
        WHERE s2g.group_id = inGroupID
          AND a.anlt_alias = als.anlt_alias
      GROUP BY a.anlt_alias,s2a.anlt_code,e.fct_table_name,e.hist_table_name
      HAVING s2a.anlt_code IS NOT NULL
    ) LOOP
      vBuff :=
      CASE WHEN vAnltCou > 0 THEN '  UNION ALL'||CHR(10) END||
      '  SELECT sign_name,obj_gid,source_system_id,sign_val'||CHR(10)||
      '    FROM '||idx.a_fct_table||CHR(10)||
      '    WHERE sign_name IN ('||idx.sign_name||')'||CHR(10)||
      '      AND as_of_date = to_date('''||to_char(inDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'')'||CHR(10)||
      '  UNION ALL'||CHR(10)||
      '  SELECT /*+ no_index(v) */ v.sign_name,v.obj_gid,v.source_system_id,v.sign_val'||CHR(10)||
      '    FROM '||idx.a_hist_table||' v'||CHR(10)||
      '    WHERE v.sign_name IN ('||idx.sign_name||')'||CHR(10)||
      '      AND to_date('''||to_char(inDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') BETWEEN v.effective_start AND v.effective_end'||CHR(10);
      dbms_lob.writeappend(vDML,LENGTH(vBuff),vBuff);
      vAnltCou := vAnltCou + 1;
    END LOOP;

    vBuff := ')'||CHR(10);
    dbms_lob.writeappend(vDML,LENGTH(vBuff),vBuff);
    vAlsCou := vAlsCou + 1;
  END LOOP;
  -- Окончание формирования подзапросов для аналитик

  vBuff :=
  ',fct AS ('||CHR(10)||
  'SELECT to_date('''||to_char(inDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') AS as_of_date,fct.obj_gid,fct.source_system_id,fct.sign_name,CASE WHEN fct.sign_val = ''0,'' THEN null ELSE fct.sign_val END AS sign_val'||CHR(10)||
  '  FROM '||vHistTable||' fct'||CHR(10)||
  '  WHERE fct.sign_name IN ('||vOtherFields||')'||CHR(10)||
  '    AND to_date('''||to_char(inDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') BETWEEN fct.effective_start AND fct.effective_end'||CHR(10);
  dbms_lob.writeappend(vDML,LENGTH(vBuff),vBuff);

  vBuff :=
  'UNION ALL'||CHR(10)||
  'SELECT to_date('''||to_char(inDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') AS as_of_date,fct.obj_gid,fct.source_system_id,fct.sign_name,CASE WHEN fct.sign_val = ''0,'' THEN null ELSE fct.sign_val END AS sign_val'||CHR(10)||
  '  FROM '||vFctTable||' fct'||CHR(10)||
  '  WHERE fct.sign_name IN ('||vOtherFields||')'||CHR(10)||
  '    AND fct.as_of_date = to_date('''||to_char(inDate,'DD.MM.YYYY')||''',''DD.MM.YYYY''))'||CHR(10);
  dbms_lob.writeappend(vDML,LENGTH(vBuff),vBuff);

  -- Подзапрос альясов не ключевых показателей
  vBuff :=
  ',als AS ('||CHR(10)||
  '   SELECT /*+ no_index(s2g) */ s2g.sign_name,NVL(s2g.sgn_alias,s2g.sign_name) AS sgn_alias FROM tb_signs_2_group s2g WHERE s2g.group_id = '||inGroupID||' AND s2g.sign_name IN ('||vOtherFields||')'||CHR(10)||
  ')'||CHR(10);
  dbms_lob.writeappend(vDML,LENGTH(vBuff),vBuff);
  -- Окончание подзапроса альясов не ключевых показателей

  vBuff :=
  'SELECT fct.as_of_date,fct.obj_gid,fct.source_system_id,fct.sign_name,als.sgn_alias AS sign_name,fct.sign_val,'||vAnltFieldsPref||CHR(10)||
  '  FROM fct '||CHR(10)||vAnltJoins||CHR(10)||' LEFT JOIN als ON als.sign_name = fct.sign_name'||CHR(10)||
  '  WHERE fct.sign_val IS NOT NULL;'||CHR(10);
  dbms_lob.writeappend(vDML,LENGTH(vBuff),vBuff);

  vBuff :=
  ':1 := SQL%ROWCOUNT;'||CHR(10)||
  'COMMIT;'||CHR(10)||
  'END;'||CHR(10);
  dbms_lob.writeappend(vDML,LENGTH(vBuff),vBuff);

  EXECUTE IMMEDIATE vDML USING OUT vRowCou;
  --dbms_output.put_line(vDML);

  vEndTime := SYSDATE;
  vMes := 'SUCCESSFULLY :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Группа: "'||vGroupName||'" - Сущность: "'||vEntityName||'" - '||vRowCou||' rows inserted into table '||lower(vOwner)||'.fct_'||inGroupID||' in '||get_ti_as_hms(vEndTime - vTIBegin);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarFctOnDate',vMes);

  vMes := 'CONTINUE :: ------------ "'||to_char(inDate,'DD.MM.YYYY')||'" - Группа: "'||vGroupName||'" - Сущность: "'||vEntityName||'" - окончание вставки данных. Время выполнения: '||get_ti_as_hms(vEndTime - vTIBegin)||' -----------';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarFctOnDate',vMes);

  vEndTime := SYSDATE;
  vMes := 'FINISH :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarFctOnDate" finished successfully in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarFctOnDate',vMes);

EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarFctOnDate" :: '||SQLERRM;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarFctOnDate',vMes);
  vEndTime := SYSDATE;
  vMes := 'FINISH :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarFctOnDate" finished with errors in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarFctOnDate',vMes);
END StarFctOnDate;

PROCEDURE StarDimOnDate(inDate IN DATE,inGroupID IN NUMBER,inEntityID IN NUMBER)
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
    vTIBegin DATE;
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vMes VARCHAR2(4000);
    -- список наименований полей через запятую (для использования при построении динамического SQL)
    vKeyFieldsForIns VARCHAR2(32700);
    vKeyFieldsForSel VARCHAR2(32700);
    vKeyFields VARCHAR2(32700);
    vKeyFieldsWithAlias VARCHAR2(32700);

    vDML CLOB;
    vRestrictSQL CLOB;

    vBuff VARCHAR2(32700);
    vHistTable VARCHAR2(256);    -- наименование таблицы хранения периодами
    vFctTable VARCHAR2(256);     -- наименование таблицы хранения по датам
    vFctView VARCHAR2(256);
    vStarDimTable VARCHAR2(256) := vOwner||'.dim_'||inGroupID||'#'||inEntityID; -- наименование таблицы фактов в звезде
    vGroupName VARCHAR2(4000);   -- наименование группы показателей
    vEntityName VARCHAR2(4000);  -- нименование сущности
    vTabCou INTEGER := 0;
    vRowCou INTEGER := 0;
BEGIN
  vMes := 'START :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarDimOnDate" started.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarDimOnDate',vMes);
  -- Сохранение наименований сущности и её таблиц хранения в переменные
  BEGIN
    SELECT vOwner||'.'||fct_table_name AS FctTable
          ,vOwner||'.'||hist_table_name AS HistTable
          ,vOwner||'.v_'||hist_table_name AS FctView
          ,entity_name
      INTO vFctTable,vHistTable,vFctView,vEntityName
      FROM tb_entity
      WHERE ID = inEntityID;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Описание сущности ID = '||inEntityID||' не найдено в таблице '||vOwner||'.tb_entity');
  END;

  -- Сохранение наименования группы в переменную
  BEGIN
    SELECT group_name
      INTO vGroupName
      FROM tb_signs_group
      WHERE group_id = inGroupID;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Описание группы ID = '||inGroupID||' не найдено в таблице '||vOwner||'.tb_signs_group');
  END;

  vTIBegin := SYSDATE;
  vMes := 'CONTINUE :: ------------ "'||to_char(inDate,'DD.MM.YYYY')||'" - Группа: "'||vGroupName||'" - Сущность: "'||vEntityName||'" - вставка данных -----------';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarDimOnDate',vMes);

  vKeyFieldsForIns := NULL;
  vKeyFieldsForSel := NULL;
  vKeyFields := NULL;
  vKeyFieldsWithAlias := NULL;

  -- Формирование строковых переменных со списком полей через запятую
  FOR idx IN (
    SELECT p.sign_name
      FROM tb_signs_2_group s2g
           INNER JOIN tb_signs_pool p
             ON p.sign_name = s2g.sign_name
                AND p.entity_id IN (SELECT id FROM tb_entity CONNECT BY PRIOR id = parent_id
                                    START WITH id = inEntityID)
      WHERE s2g.group_id = inGroupID
  ) LOOP
      vKeyFields := vKeyFields||CHR(10)||','''||idx.sign_name||'''';
      vKeyFieldsWithAlias := vKeyFieldsWithAlias||CHR(10)||','''||idx.sign_name||''' AS '||idx.sign_name;
  END LOOP;

  FOR idx IN (
    SELECT DISTINCT
           NVL(s2g.sgn_alias,p.sign_name) AS sign_name
          ,NVL2(s2g.sgn_alias,'COALESCE('||LISTAGG(p.sign_name,',') WITHIN GROUP (ORDER BY p.id) OVER (PARTITION BY NVL(s2g.sgn_alias,p.sign_name))||',NULL) AS '||s2g.sgn_alias,p.sign_name) AS coal_sign_name
      FROM tb_signs_2_group s2g
           INNER JOIN tb_signs_pool p
             ON p.sign_name = s2g.sign_name
                AND p.entity_id IN (SELECT id FROM tb_entity CONNECT BY PRIOR id = parent_id
                                    START WITH id = inEntityID)
      WHERE s2g.group_id = inGroupID
  ) LOOP
      vKeyFieldsForIns := vKeyFieldsForIns||CHR(10)||','||lower(idx.sign_name);
      vKeyFieldsForSel := vKeyFieldsForSel||CHR(10)||','||lower(idx.coal_sign_name);
  END LOOP;

  vKeyFieldsForIns := SUBSTR(vKeyFieldsForIns,3,LENGTH(vKeyFieldsForIns) - 2);
  vKeyFieldsForSel := SUBSTR(vKeyFieldsForSel,3,LENGTH(vKeyFieldsForSel) - 2);
  vKeyFields := SUBSTR(vKeyFields,3,LENGTH(vKeyFields) - 2);
  vKeyFieldsWithAlias := SUBSTR(vKeyFieldsWithAlias,3,LENGTH(vKeyFieldsWithAlias) - 2);

  dbms_lob.createtemporary(vDML,FALSE);
  vBuff :=
  'BEGIN'||CHR(10)||
  'EXECUTE IMMEDIATE ''ALTER SESSION SET nls_numeric_characters = '''', '''''';'||CHR(10)||
  'EXECUTE IMMEDIATE ''ALTER SESSION SET nls_date_format = ''''DD.MM.YYYY HH24:MI:SS'''''';'||CHR(10)||
  'INSERT INTO '||vStarDimTable||'(as_of_date,obj_sid'||CHR(10)||','||vKeyFieldsForIns||')'||CHR(10);
  dbms_lob.writeappend(vDML,LENGTH(vBuff),vBuff);

  -- Формирование блока ограничения (WITH...) для запроса вставки данных
  vBuff :=
  'WITH '||CHR(10)||'  fct_keys AS ('||CHR(10);
  dbms_lob.writeappend(vDML,LENGTH(vBuff),vBuff);

  dbms_lob.createtemporary(vRestrictSQL,FALSE);
  vBuff := 'SELECT sign_val AS obj_sid FROM ('||CHR(10);
  dbms_lob.writeappend(vRestrictSQL,LENGTH(vBuff),vBuff);

  FOR idx IN (
    SELECT LISTAGG(''''||g1.sign_name||'''',',') WITHIN GROUP (ORDER BY g1.sign_name) AS parts
          ,gr.anlt_alias
          ,CASE WHEN p.hist_flg = 0 THEN gr.fct_table_name ELSE gr.hist_table_name END AS table_name
          ,p.hist_flg
      FROM (
    SELECT g.group_id,g.parent_group_id,a2g.anlt_code,a.anlt_alias,e.entity_name
          ,e.fct_table_name
          ,e.hist_table_name
          ,(SELECT ID FROM tb_entity WHERE parent_id IS NULL CONNECT BY PRIOR parent_id = ID START WITH ID = a.entity_id) AS e_id
      FROM tb_signs_group g
           LEFT JOIN tb_anlt_2_group a2g
             ON a2g.group_id = g.group_id
           LEFT JOIN tb_signs_anlt a
             ON a.anlt_code = a2g.anlt_code
                AND inDate BETWEEN a.effective_start AND a.effective_end
           LEFT JOIN tb_entity e
             ON e.id = a.entity_id
    CONNECT BY PRIOR g.group_id = g.parent_group_id
    START WITH g.group_id = inGroupID
    ) gr LEFT JOIN tb_signs_2_group g1
           ON g1.group_id = gr.parent_group_id
              AND EXISTS (SELECT NULL FROM tb_sign_2_anlt WHERE sign_name = g1.sign_name AND anlt_code = gr.anlt_code)
         LEFT JOIN tb_signs_pool p
           ON p.sign_name = g1.sign_name
    WHERE gr.e_id = inEntityID
    GROUP BY gr.anlt_alias,p.hist_flg,CASE WHEN p.hist_flg = 0 THEN gr.fct_table_name ELSE gr.hist_table_name END
  ) LOOP
    vBuff :=
    CASE WHEN vTabCou > 0 THEN 'UNION ALL'||CHR(10) END||
    'SELECT /*+ no_index(v) */ v.sign_val FROM '||LOWER(vOwner)||'.'||idx.table_name||' v'||CHR(10)||
    '  WHERE v.sign_name IN ('||idx.parts||') AND '||
    CASE WHEN idx.hist_flg = 0 THEN 'v.as_of_date = to_date('''||to_char(inDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'')'
    ELSE 'to_date('''||to_char(inDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') BETWEEN v.effective_start and v.effective_end' END||CHR(10);
    dbms_lob.writeappend(vRestrictSQL,LENGTH(vBuff),vBuff);
    vTabCou := vTabCou + 1;
  END LOOP;

  vBuff := ') GROUP BY sign_val)'||CHR(10);
  dbms_lob.writeappend(vRestrictSQL,LENGTH(vBuff),vBuff);

  vBuff :=
  'SELECT /*+ parallel(2)*/ to_date('''||to_char(inDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') AS as_of_date,obj_gid*10+source_system_id as obj_sid'||CHR(10)||','||vKeyFieldsForSel||' FROM ('||CHR(10)||
  '      SELECT /*+ no_index(s) */ s.obj_gid,s.source_system_id,s.sign_name,s.sign_val'||CHR(10)||
  '        FROM '||vHistTable||' s'||CHR(10)||
  '             INNER JOIN fct_keys ON fct_keys.obj_sid = s.obj_gid*10+s.source_system_id'||CHR(10)||
  '        WHERE s.sign_name IN ('||vKeyFields||')'||CHR(10)||
  '          AND to_date('''||to_char(inDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') BETWEEN s.effective_start AND s.effective_end'||CHR(10)||
  '      UNION ALL'||CHR(10)||
  '      SELECT s.obj_gid,s.source_system_id,s.sign_name,s.sign_val'||CHR(10)||
  '        FROM '||vFctTable||' s'||CHR(10)||
  '             INNER JOIN fct_keys ON fct_keys.obj_sid = s.obj_gid*10+s.source_system_id'||CHR(10)||
  '        WHERE sign_name IN ('||vKeyFields||')'||CHR(10)||
  '          AND s.as_of_date = to_date('''||to_char(inDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'')'||CHR(10)||
  '    ) PIVOT (MAX(sign_val) FOR sign_name IN ('||vKeyFieldsWithAlias||'));'||CHR(10);

  dbms_lob.writeappend(vDML,dbms_lob.getlength(vRestrictSQL),vRestrictSQL);
  dbms_lob.writeappend(vDML,LENGTH(vBuff),vBuff);

  vBuff :=
  ':1 := SQL%ROWCOUNT;'||CHR(10)||
  'COMMIT;'||CHR(10)||
  'END;'||CHR(10);
  dbms_lob.writeappend(vDML,LENGTH(vBuff),vBuff);

  EXECUTE IMMEDIATE vDML USING OUT vRowCou;
  --dbms_output.put_line(vDML);

  vEndTime := SYSDATE;
  vMes := 'SUCESSFULLY :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Группа: "'||vGroupName||'" - Сущность: "'||vEntityName||'" - '||vRowCou||' rows inserted into table '||vStarDimTable||' in '||get_ti_as_hms(vEndTime - vTIBegin);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarDimOnDate',vMes);

  vMes := 'CONTINUE :: ------------ "'||to_char(inDate,'DD.MM.YYYY')||'" - Группа: "'||vGroupName||'" - Сущность: "'||vEntityName||'" - окончание вставки данных. Время выполнения: '||get_ti_as_hms(vEndTime - vTIBegin)||' -----------';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarDimOnDate',vMes);

  vEndTime := SYSDATE;
  vMes := 'FINISH :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarDimOnDate" finished successfully in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarDimOnDate',vMes);

EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarDimOnDate" :: '||SQLERRM;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarDimOnDate',vMes);
  vEndTime := SYSDATE;
  vMes := 'FINISH :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarDimOnDate" finished with errors in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarDimOnDate',vMes);
END StarDimOnDate;

PROCEDURE StarAnltOnDate(inDate IN DATE,inGroupID IN NUMBER,inAnltAlias IN VARCHAR2)
  IS
    vSQL CLOB;
    vGroupName VARCHAR2(4000);
    vAnltName VARCHAR2(4000);
    vAnltSpecID VARCHAR2(4000);
    --
    vMes VARCHAR2(32700);
    vTIBegin DATE;
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vCou1 INTEGER;
    vCou2 INTEGER;
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  vMes := 'START :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarAnltOnDate" started.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarAnltOnDate',vMes);
  -- Сохранение наименования группы в переменную
  BEGIN
    SELECT group_name
      INTO vGroupName
      FROM tb_signs_group
      WHERE group_id = inGroupID;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Описание группы ID = '||inGroupID||' не найдено в таблице '||vOwner||'.tb_signs_group');
  END;

  -- Сохранение наименования аналитики в переменную
  BEGIN
SELECT LISTAGG(a.anlt_code,',') WITHIN GROUP (ORDER BY a.id) AS AnltCode
          ,LISTAGG(a.id,',') WITHIN GROUP (ORDER BY a.id) AS AnltSpecID
      INTO vAnltName,vAnltSpecID
      FROM tb_signs_anlt a
      WHERE a.anlt_alias = inAnltAlias
        AND inDate BETWEEN a.effective_start AND a.effective_end -- 28,46
        AND a.anlt_code IN (SELECT a2g.anlt_code
                              FROM tb_signs_group g
                                   LEFT JOIN tb_anlt_2_group a2g ON a2g.group_id = g.group_id
                              WHERE LEVEL = 3
                            CONNECT BY PRIOR g.group_id = g.parent_group_id
                            START WITH g.group_id = inGroupID);
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20000,'Описание аналитиики ANLT_ALIAS = '||inAnltAlias||' за дату "'||to_char(inDate,'DD.MM.YYYY')||'" не найдено в таблице '||vOwner||'.tb_signs_anlt');
  END;

  vTIBegin := SYSDATE;
  vMes := 'CONTINUE :: ------------ "'||to_char(inDate,'DD.MM.YYYY')||'" - Группа: "'||vGroupName||'" - Аналитика: "'||vAnltName||'" - начало подготовки таблицы -----------';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarAnltOnDate',vMes);

  vSQL := 'SELECT anlt_spec_val AS id,parent_val AS parent_id,anlt_spec_name AS name,anlt_spec_val AS val
       FROM '||lower(vOwner)||'.tb_signs_anlt_spec
     WHERE anlt_id IN ('||vAnltSpecID||')';

  vSQL := GetAnltLineSQL(vSQL,'id','parent_id','name','val');
  BEGIN
      EXECUTE IMMEDIATE
      'BEGIN'||CHR(10)||
      'DELETE FROM '||LOWER(vOwner)||'.anltline_'||inGroupID||'#'||inAnltAlias||' WHERE as_of_date = to_date('''||to_char(inDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'');'||CHR(10)||
      '  :1 := SQL%ROWCOUNT;'||CHR(10)||
      'INSERT INTO '||LOWER(vOwner)||'.anltline_'||inGroupID||'#'||inAnltAlias||CHR(10)||
      'WITH'||CHR(10)||
      '  dt AS ('||CHR(10)||
      '    SELECT to_date('''||to_char(inDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') AS as_of_date FROM dual'||CHR(10)||
      '  )'||CHR(10)||
      '  SELECT * FROM dt CROSS JOIN ('||vSQL||');'||CHR(10)||
      '  :2 := SQL%ROWCOUNT;'||CHR(10)||
      '  COMMIT;'||CHR(10)||
      'END;'
      USING OUT vCou1,OUT vCou2;

      vMes := 'SUCCESSFULLY :: '||vCou1||' rows deleted from table '||LOWER(vOwner)||'.anltline_'||inGroupID||'#'||inAnltAlias;
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarAnltOnDate',vMes);

      vMes := 'SUCCESSFULLY :: '||vCou2||' rows inserted into table '||LOWER(vOwner)||'.anltline_'||inGroupID||'#'||inAnltAlias;
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarAnltOnDate',vMes);
  EXCEPTION WHEN OTHERS THEN
    BEGIN
      vSQL := 'SELECT anlt_spec_val AS id,parent_val AS parent_id,anlt_spec_name AS name,anlt_spec_val AS val
           FROM '||lower(vOwner)||'.tb_signs_anlt_spec
         WHERE anlt_id IN ('||vAnltSpecID||')';

      vSQL := GetAnltLineSQL(vSQL,'id','parent_id','name','val');
      EXECUTE IMMEDIATE
      --dbms_output.put_line(
      'CREATE TABLE '||LOWER(vOwner)||'.anltline_'||inGroupID||'#'||inAnltAlias||' AS '||CHR(10)||
      'WITH'||CHR(10)||
      '  dt AS ('||CHR(10)||
      '    SELECT to_date('''||to_char(inDate,'DD.MM.YYYY')||''',''DD.MM.YYYY'') AS as_of_date FROM dual'||CHR(10)||
      '  )'||CHR(10)||
      '  SELECT * FROM dt CROSS JOIN ('||vSQL||')'
      --)
      ;

      vMes := 'SUCCESSFULLY :: Table '||LOWER(vOwner)||'.anltline_'||inGroupID||'#'||inAnltAlias||' created';
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarAnltOnDate',vMes);

      EXECUTE IMMEDIATE
      --dbms_output.put_line(
      'ALTER TABLE '||LOWER(vOwner)||'.anltline_'||inGroupID||'#'||inAnltAlias||' NOLOGGING'
      --)
      ;
      EXECUTE IMMEDIATE
      --dbms_output.put_line(
      'ALTER TABLE '||LOWER(vOwner)||'.anltline_'||inGroupID||'#'||inAnltAlias||' COMPRESS'
      --)
      ;
      EXECUTE IMMEDIATE
      --dbms_output.put_line(
      'CREATE BITMAP INDEX '||LOWER(vOwner)||'.bidx_anltline_'||inGroupID||'#'||inAnltAlias||' ON'||CHR(10)||
        LOWER(vOwner)||'.anltline_'||inGroupID||'#'||inAnltAlias||' (as_of_date) NOLOGGING'
      --)
      ;

      vMes := 'SUCCESSFULLY :: Index '||LOWER(vOwner)||'.idx_anltline_'||inGroupID||'#'||inAnltAlias||' created';
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarAnltOnDate',vMes);

    EXCEPTION WHEN OTHERS THEN
      vMes := 'ERROR :: Не удалось создать таблицу "'||LOWER(vOwner)||'.anltline_'||inGroupID||'#'||inAnltAlias||'"'||CHR(10)||
              '--------------------------------------'||CHR(10)||SQLERRM;
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarAnltOnDate',vMes);
    END;
  END;
  dbms_lob.freetemporary(vSQL);

  vEndTime := SYSDATE;
  vMes := 'CONTINUE :: ------------ "'||to_char(inDate,'DD.MM.YYYY')||'" - Группа: "'||vGroupName||'" - Аналитика: "'||vAnltName||'" - окончание подготовки таблицы. Время выполнения: '||get_ti_as_hms(vEndTime - vTIBegin)||' -----------';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarAnltOnDate',vMes);

  vEndTime := SYSDATE;
  vMes := 'FINISH :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarAnltOnDate" finished successfully in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarAnltOnDate',vMes);

EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarAnltOnDate" :: '||SQLERRM;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarAnltOnDate',vMes);
  vEndTime := SYSDATE;
  vMes := 'FINISH :: "'||to_char(inDate,'DD.MM.YYYY')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarAnltOnDate" finished with errors in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarAnltOnDate',vMes);
END StarAnltOnDate;

PROCEDURE StarPrepare(inBegDate IN DATE,inEndDate IN DATE,inGroupID IN NUMBER)
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
    vJobName VARCHAR2(256) := UPPER(vOwner)||'.'||'PREPAREJOB_'||tb_signs_job_id_seq.nextval;
    vBuff VARCHAR2(32700);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vMes VARCHAR2(4000);
    vBegDate VARCHAR2(30) := to_char(inBegDate,'DD.MM.YYYY');
    vEndDate VARCHAR2(30) := to_char(inEndDate,'DD.MM.YYYY');
BEGIN
  vMes := 'START :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarPrepare" started.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarPrepare',vMes);

  vBuff :=
  q'[WITH
      dt AS (
        SELECT to_date(']'||vEndDate||q'[','DD.MM.YYYY') - LEVEL + 1 AS as_of_date
          FROM dual CONNECT BY LEVEL <= to_date(']'||vEndDate||q'[','DD.MM.YYYY') - to_date(']'||vBegDate||q'[','DD.MM.YYYY') + 1
        ORDER BY 1)
     ,a AS (
        SELECT group_id||'|'||head_entity_id AS ID
              ,group_id
              ,head_entity_id
          FROM (
            SELECT DISTINCT
                   g.group_id
                  ,CASE WHEN LEVEL = 1 THEN
                           (SELECT ID FROM tb_entity WHERE parent_id IS NULL
                            CONNECT BY ID = PRIOR parent_id START WITH ID = p.entity_id)
                         ELSE NULL END AS head_entity_id
              FROM tb_signs_group g
                   LEFT JOIN tb_signs_2_group s2g
                     ON s2g.group_id = g.group_id
                   LEFT JOIN tb_signs_pool p
                     ON p.sign_name = s2g.sign_name
                    WHERE s2g.sign_name IS NOT NULL AND LEVEL <= 2
            CONNECT BY PRIOR g.group_id = g.parent_group_id
            START WITH g.group_id = ]'||inGroupID||q'[))
      SELECT DISTINCT
             a.id||'|'||to_char(dt.as_of_date,'RRRRMMDD') AS ID
            ,NULL AS parent_id
            ,CASE WHEN a.head_entity_id IS NOT NULL THEN ']'||LOWER(vOwner)||q'[.pkg_etl_signs.StarPrepareDim' ELSE ']'||LOWER(vOwner)||q'[.pkg_etl_signs.StarPrepareFct' END AS unit
            ,to_char(dt.as_of_date,'DD.MM.YYYY')||'#!#'||a.group_id||CASE WHEN a.head_entity_id IS NOT NULL THEN '#!#'||a.head_entity_id END as params
            ,0 AS skip
        FROM dt CROSS JOIN a]';
  load_new(vBuff,vJobName);

  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarPrepare" finished sucessfully in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarPrepare',vMes);

EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarPrepare" :: '||SQLERRM;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarPrepare',vMes);
  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarPrepare" finished with errors in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarPrepare',vMes);
END StarPrepare;

PROCEDURE StarClear(inBegDate IN DATE,inEndDate IN DATE,inGroupID IN NUMBER)
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
    vJobName VARCHAR2(256) := UPPER(vOwner)||'.'||'CLEARJOB_'||tb_signs_job_id_seq.nextval;
    vBuff VARCHAR2(32700);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vMes VARCHAR2(4000);
    vBegDate VARCHAR2(30) := to_char(inBegDate,'DD.MM.YYYY');
    vEndDate VARCHAR2(30) := to_char(inEndDate,'DD.MM.YYYY');
BEGIN
  vMes := 'START :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarClear" started.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarClear',vMes);

  EXECUTE IMMEDIATE 'alter session set "_FIX_CONTROL" = "11814428:0"';

  vBuff :=
    q'[WITH
      dt AS (
        SELECT to_date(']'||vEndDate||q'[','DD.MM.YYYY') - LEVEL + 1 AS as_of_date
          FROM dual CONNECT BY LEVEL <= to_date(']'||vEndDate||q'[','DD.MM.YYYY') - to_date(']'||vBegDate||q'[','DD.MM.YYYY') + 1
        ORDER BY 1)
     ,a AS (
        SELECT DISTINCT
               to_char(g.group_id) AS ID
              ,NULL AS parent_id
              ,CASE WHEN LEVEL = 1 THEN
                 (SELECT ID FROM tb_entity WHERE parent_id IS NULL
                  CONNECT BY ID = PRIOR parent_id START WITH ID = p.entity_id)
               ELSE NULL END AS head_entity_id
              ,']'||LOWER(vOwner)||q'[.pkg_etl_signs.MyExecute' AS unit
              ,CASE WHEN LEVEL = 1 THEN 'dim' ELSE 'fct' END AS StarPart
          FROM tb_signs_group g
               LEFT JOIN tb_signs_2_group s2g
                 ON s2g.group_id = g.group_id
               LEFT JOIN tb_signs_pool p
                 ON p.sign_name = s2g.sign_name
          WHERE s2g.sign_name IS NOT NULL AND LEVEL <= 2
        CONNECT BY PRIOR g.group_id = g.parent_group_id
        START WITH g.group_id = ]'||inGroupID||q'[)
      SELECT a.id||'_'||a.head_entity_id||'_P'||to_char(dt.as_of_date,'RRRRMMDD') AS ID
            ,NULL AS parent_id
            ,a.unit
            ,'ALTER TABLE ]'||LOWER(vOwner)||q'[.'||CASE WHEN a.head_entity_id IS NULL THEN 'fct_' ELSE 'dim_' END||a.id||CASE WHEN a.head_entity_id IS NULL THEN NULL ELSE '#'||a.head_entity_id END||CHR(10)||
            '   TRUNCATE PARTITION P'||to_char(dt.as_of_date,'RRRRMMDD') AS params
            ,0 AS skip
        FROM dt CROSS JOIN a
        WHERE EXISTS (SELECT NULL FROM all_tables WHERE owner = ']'||UPPER(vOwner)||q'[' AND table_name = UPPER(a.StarPart||'_'||a.id||CASE WHEN a.StarPart = 'fct' THEN NULL ELSE '#'||a.head_entity_id END))]';

  load_new(vBuff,vJobName);

  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarClear" finished sucessfully in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarClear',vMes);

EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarClear" :: '||SQLERRM;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarClear',vMes);
  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarClear" finished with errors in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarClear',vMes);
END StarClear;

PROCEDURE StarExpand(inBegDate IN DATE,inEndDate IN DATE,inGroupID IN NUMBER,inMask VARCHAR2 DEFAULT '00',inCalcPoolId NUMBER DEFAULT NULL)
  /************************************
   Описание маски (0 - не выполнять, 1 - выполнять):
   1-й символ - предварительный пересчет всех показателей по кубу
   2-й символ - предварительный пересчет всех аналитик по кубу
  ************************************/
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
    vJobName VARCHAR2(256) := UPPER(vOwner)||'.'||'EXPANDJOB_'||tb_signs_job_id_seq.nextval;
    vBuff VARCHAR2(32700);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vMes VARCHAR2(400);
    vBegDate VARCHAR2(30) := to_char(inBegDate,'DD.MM.YYYY');
    vEndDate VARCHAR2(30) := to_char(inEndDate,'DD.MM.YYYY');
    --
    vDoSign BOOLEAN := SUBSTR(inMask,1,1) = '1';
    vDoAnlt BOOLEAN := SUBSTR(inMask,2,1) = '1';
BEGIN
  vMes := 'START :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarExpand" started.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarExpand',vMes);

  -- Если требуется предварительный пересчет показателей
  IF vDoSign THEN CalcSignsByStar(inBegDate,inEndDate,inGroupID,REPLACE(vJobName,'EXPANDJOB','SIGNSBYSTARJOB')); END IF;

  -- Если требуется предварительный пересчет аналитик
  IF vDoAnlt THEN CalcAnltByStar(inBegDate,inEndDate,inGroupID,REPLACE(vJobName,'EXPANDJOB','ANLTBYSTARJOB')); END IF;

  -- Подготовка
  StarPrepare(inBegDate,inEndDate,inGroupID);

  -- Очистка
  StarClear(inBegDate,inEndDate,inGroupID);

  -- Загрузка
  vBuff :=
    q'[WITH
      dt AS (
        SELECT to_date(']'||vEndDate||q'[','DD.MM.YYYY') - LEVEL + 1 AS as_of_date
          FROM dual CONNECT BY LEVEL <= to_date(']'||vEndDate||q'[','DD.MM.YYYY') - to_date(']'||vBegDate||q'[','DD.MM.YYYY') + 1
        ORDER BY 1)
     ,a AS (
        SELECT DISTINCT
               to_char(g.group_id) AS ID
              ,NULL AS parent_id
              ,(SELECT ID FROM tb_entity WHERE parent_id IS NULL
                CONNECT BY ID = PRIOR parent_id START WITH ID = p.entity_id) AS head_entity_id
              ,CASE WHEN LEVEL = 1 THEN ']'||LOWER(vOwner)||q'[.pkg_etl_signs.StarDimOnDate' ELSE ']'||LOWER(vOwner)||q'[.pkg_etl_signs.StarFctOnDate' END AS unit
              ,CASE WHEN LEVEL = 1 THEN 'dim' ELSE 'fct' END AS StarPart
          FROM tb_signs_group g
               LEFT JOIN tb_signs_2_group s2g
                 ON s2g.group_id = g.group_id
               LEFT JOIN tb_signs_pool p
                 ON p.sign_name = s2g.sign_name
          WHERE s2g.sign_name IS NOT NULL AND LEVEL <= 2
        CONNECT BY PRIOR g.group_id = g.parent_group_id
        START WITH g.group_id = ]'||inGroupID||q'[)
     ,b AS (
        SELECT DISTINCT
               dt.as_of_date
              ,a.anlt_alias
          FROM tb_signs_group g CROSS JOIN dt
               LEFT JOIN tb_anlt_2_group a2g
                 ON a2g.group_id = g.group_id
               LEFT JOIN tb_signs_anlt a
                 ON a.anlt_code = a2g.anlt_code
                    AND dt.as_of_date BETWEEN a.effective_start AND a.effective_end
          WHERE LEVEL = 3 AND EXISTS (SELECT NULL FROM tb_signs_anlt_spec WHERE anlt_id = a.id)
        CONNECT BY PRIOR g.group_id = g.parent_group_id
        START WITH g.group_id = ]'||inGroupID||q'[)
      -- Факты и ПИДАРЫ (ПИДАР - Простое Измерение Для Агрегирования Результатов)
      SELECT DISTINCT
             to_char(dt.as_of_date,'DD.MM.YYYY')||']'||LOWER(vOwner)||q'[.'||a.StarPart||'_'||a.id||'#'||a.head_entity_id AS ID
            ,NULL AS parent_id
            ,a.unit
            ,to_char(dt.as_of_date,'DD.MM.YYYY')||'#!#'||a.id||'#!#'||a.head_entity_id AS params
            ,0 AS skip
        FROM dt CROSS JOIN a
      -- СУКИ (СУКА - Сквозная Унифицированная Комплексная Аналитика)
      UNION ALL
      SELECT DISTINCT
             to_char(b.as_of_date,'DD.MM.YYYY')||']'||LOWER(vOwner)||q'[.anltline_]'||inGroupID||q'[#'||b.anlt_alias AS ID
            ,NULL AS parent_id
            ,']'||LOWER(vOwner)||q'[.pkg_etl_signs.StarAnltOnDate'
            ,to_char(b.as_of_date,'DD.MM.YYYY')||'#!#]'||inGroupID||q'[#!#'||b.anlt_alias AS params
            ,0 AS skip
        FROM b]';

  load_new(vBuff,vJobName,inCalcPoolId);

  -- Сжатие
  StarCompress(inBegDate,inEndDate,inGroupID);

  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarExpand" finished sucessfully in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarExpand',vMes);

EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarExpand" :: '||SQLERRM;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarExpand',vMes);
  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarExpand" finished with errors in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarExpand',vMes);
END StarExpand;

PROCEDURE StarCompress(inBegDate IN DATE,inEndDate IN DATE,inGroupID IN NUMBER)
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
    vJobName VARCHAR2(256) := UPPER(vOwner)||'.'||'COMPRESSJOB_'||tb_signs_job_id_seq.nextval;
    vBuff VARCHAR2(32700);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vMes VARCHAR2(4000);
    vBegDate VARCHAR2(30) := to_char(inBegDate,'DD.MM.YYYY');
    vEndDate VARCHAR2(30) := to_char(inEndDate,'DD.MM.YYYY');
BEGIN
  vMes := 'START :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarCompress" started.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarCompress',vMes);

  vBuff :=
    q'[WITH
      dt AS (
        SELECT to_date(']'||vEndDate||q'[','DD.MM.YYYY') - LEVEL + 1 AS as_of_date
          FROM dual CONNECT BY LEVEL <= to_date(']'||vEndDate||q'[','DD.MM.YYYY') - to_date(']'||vBegDate||q'[','DD.MM.YYYY') + 1
        ORDER BY 1)
     ,a AS (
        SELECT DISTINCT
               to_char(g.group_id) AS ID
              ,NULL AS parent_id
              ,CASE WHEN LEVEL = 1 THEN
                 (SELECT ID FROM tb_entity WHERE parent_id IS NULL
                  CONNECT BY ID = PRIOR parent_id START WITH ID = p.entity_id)
               ELSE NULL END AS head_entity_id
              ,']'||LOWER(vOwner)||q'[.pkg_etl_signs.MyExecute' AS unit
              ,CASE WHEN LEVEL = 1 THEN 'dim' ELSE 'fct' END AS StarPart
              ,'SP'||ora_hash(NVL(s2g.sgn_alias,s2g.sign_name)) AS sp_code
          FROM tb_signs_group g
               LEFT JOIN tb_signs_2_group s2g
                 ON s2g.group_id = g.group_id
               LEFT JOIN tb_signs_pool p
                 ON p.sign_name = s2g.sign_name
          WHERE s2g.sign_name IS NOT NULL AND LEVEL <= 2
        CONNECT BY PRIOR g.group_id = g.parent_group_id
        START WITH g.group_id = ]'||inGroupID||q'[)
      SELECT DISTINCT a.id||'_'||a.head_entity_id||'_P'||to_char(dt.as_of_date,'RRRRMMDD')||CASE WHEN a.head_entity_id IS NULL THEN '_'||a.sp_code END AS ID
            ,NULL AS parent_id
            ,a.unit
            ,'ALTER TABLE ]'||LOWER(vOwner)||q'[.'||CASE WHEN a.head_entity_id IS NULL THEN 'fct_' ELSE 'dim_' END||a.id||CASE WHEN a.head_entity_id IS NULL THEN NULL ELSE '#'||a.head_entity_id END||CHR(10)||
            '   MOVE '||CASE WHEN a.head_entity_id IS NULL THEN 'SUBPARTITION '||a.sp_code||'_'||to_char(dt.as_of_date,'RRRRMMDD') ELSE 'PARTITION P'||to_char(dt.as_of_date,'RRRRMMDD') END||' COMPRESS' AS params
            ,0 AS skip
        FROM dt CROSS JOIN a]';

  load_new(vBuff,vJobName);

  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarCompress" finished sucessfully in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarCompress',vMes);

EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarCompress" :: '||SQLERRM;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarCompress',vMes);
  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarCompress" finished with errors in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarCompress',vMes);
END StarCompress;

PROCEDURE StarDropOldParts(inDate IN DATE,inGroupID IN NUMBER)
  IS
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
    vJobName VARCHAR2(256) := UPPER(vOwner)||'.'||'DROPPARTSJOB_'||tb_signs_job_id_seq.nextval;
    vCou INTEGER := 0;
    vBuff VARCHAR2(32700);
    vDDL CLOB;
    --
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vMes VARCHAR2(4000);
BEGIN
  vMes := 'START :: "'||to_char(inDate,'DD.MM.RRRR')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarDropOldParts" started.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarDropOldParts',vMes);

  dbms_lob.createtemporary(vDDL,FALSE);
  FOR idx IN (
    WITH
      g AS (
        SELECT group_id
              ,LEVEL AS lev
              ,MIN(group_id) KEEP (dense_rank FIRST ORDER BY LEVEL) OVER () AS head_group_id
              ,strg_period
              ,strg_period_type
          FROM tb_signs_group
        CONNECT BY PRIOR group_id = parent_group_id
        START WITH group_id = (SELECT MAX(group_id) KEEP (dense_rank LAST ORDER BY LEVEL) AS group_id
                                 FROM tb_signs_group
                               CONNECT BY PRIOR parent_group_id = group_id
                               START WITH group_id = inGroupID)
      )
    SELECT LOWER(vOwner)||'.'||CASE lev WHEN 1 THEN 'dim_' WHEN 2 THEN 'fct_' ELSE 'anltline_' END||group_id||
             CASE WHEN lev != 2 THEN '#'||entity_id END AS table_name
          ,CASE WHEN strg_period_type = 'D' THEN TRUNC(inDate,'DD') - strg_period
             ELSE add_months(TRUNC(inDate,'DD'),-strg_period) END AS dt
          ,lev
      FROM (
        SELECT DISTINCT
               CASE WHEN g.lev IN (1,2) THEN g.group_id ELSE g.head_group_id END AS group_id
              ,CASE WHEN g.lev = 1 THEN to_char((SELECT MAX(ID) KEEP (dense_rank LAST ORDER BY LEVEL) FROM tb_entity CONNECT BY PRIOR parent_id = ID START WITH ID = p.entity_id))
                    WHEN g.lev = 2 THEN NULL
               ELSE a.anlt_alias END AS entity_id
              ,g.lev
              ,g.strg_period
              ,g.strg_period_type
          FROM g
               LEFT JOIN tb_signs_2_group s2g
                 ON g.lev = 1 AND s2g.group_id = g.group_id
               LEFT JOIN tb_Signs_pool p
                 ON p.sign_name = s2g.sign_name
               LEFT JOIN tb_anlt_2_group a2g
                 ON g.lev = 3 AND a2g.group_id = g.group_id
               LEFT JOIN tb_signs_anlt a
                 ON a.anlt_code = a2g.anlt_code
                    AND inDate BETWEEN a.effective_start AND a.effective_end
                    AND EXISTS (SELECT NULL FROM tb_signs_anlt_spec WHERE anlt_id = a.id)
          WHERE (g.lev IN (1,2) OR a.anlt_alias IS NOT NULL) AND strg_period IS NOT NULL
        ORDER BY lev DESC
    )
  ) LOOP
    IF idx.lev = 3 THEN
      vBuff := CASE WHEN vCou > 0 THEN CHR(10)||'UNION ALL'||CHR(10) END||'SELECT '''||idx.table_name||''' AS id,NULL AS parent_id,'''||LOWER(vOwner)||'.pkg_etl_signs.MyExecute'||''' AS unit,q''['||'DELETE FROM '||idx.table_name||' WHERE as_of_date <= to_date('''''||to_char(idx.dt,'DD.MM.RRRR')||''''',''''DD.MM.RRRR'''')]'' as params,0 AS skip FROM dual';
      dbms_lob.writeappend(vDDL,length(vBuff),vBuff);
      vCou := vCou + 1;
    ELSE
      FOR p IN (
            SELECT UPPER(idx.table_name)||'|'||partition_name AS ID
                  ,NULL AS parent_id
                  ,LOWER(vOwner)||'.pkg_etl_signs.MyExecute' AS unit
                  ,'ALTER TABLE '||idx.table_name||' DROP PARTITION '||partition_name AS params
                  ,to_date(SUBSTR(partition_name,-8),'YYYYMMDD') AS p_dt
                  ,idx.dt AS i_dt
            FROM all_tab_partitions
            WHERE lower(table_owner||'.'||table_name) = LOWER(idx.table_name)
      ) LOOP
        IF p.p_dt <= p.i_dt THEN
          vBuff := CASE WHEN vCou > 0 THEN CHR(10)||'UNION ALL'||CHR(10) END||'SELECT '''||p.id||''' AS id,NULL AS parent_id,'''||p.unit||''' AS unit,'''||p.params||''' AS params,0 AS skip FROM dual';
          dbms_lob.writeappend(vDDL,length(vBuff),vBuff);
        END IF;
      END LOOP;
    END IF;
    vCou := vCou + 1;
  END LOOP;
  IF dbms_lob.getlength(vDDL) > 1
    THEN load_new(vDDL,vJobName);
         --dbms_output.put_line(vDDL);
    ELSE pr_log_write(lower(vOwner)||'.pkg_Etl_signs.StarDropOldParts','INFORMATION :: "'||to_char(inDate,'DD.MM.RRRR')||'" - Для звезды с номером группы '||inGroupID||' не обнаружено сегментов старше периода хранения');
  END IF;

  vEndTime := SYSDATE;
  vMes := 'FINISH :: "'||to_char(inDate,'DD.MM.RRRR')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarDropOldParts" finished sucessfully in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarDropOldParts',vMes);

EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: "'||to_char(inDate,'DD.MM.RRRR')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarDropOldParts" :: '||SQLERRM;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarDropOldParts',vMes);
  vEndTime := SYSDATE;
  vMes := 'FINISH :: "'||to_char(inDate,'DD.MM.RRRR')||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.StarDropOldParts" finished with errors in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.StarDropOldParts',vMes);
END StarDropOldParts;

/****************************************************************************************/

PROCEDURE HistTableService(inTableName IN VARCHAR2,inMask IN VARCHAR2,inSign IN VARCHAR2 DEFAULT NULL)
  IS
    vDDL CLOB;
    vIDX CLOB;
    vStats CLOB;
    vBuff VARCHAR2(32700);
    vCou INTEGER := 0;
    vJobName VARCHAR2(256);
    vCompress BOOLEAN := SUBSTR(inMask,1,1) = '1';
    vRebuildIdx BOOLEAN := SUBSTR(inMask,2,1) = '1';
    vGatherStats BOOLEAN := SUBSTR(inMask,3,1) = '1';
    --
    vMes VARCHAR2(32700);
    vTIBegin DATE;
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
    vOwner VARCHAR2(4000) := GetVarValue('vOwner');
BEGIN
  vMes := 'START :: "'||inTableName||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.HistTableService" started.';
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.HistTableService',vMes);

  -- Если необходим сбор статистики
  IF vGatherStats THEN
    vTIBegin := SYSDATE;
    vJobName := UPPER(vOwner)||'.SERVICEGATHERSTATSJOB_'||tb_signs_job_id_seq.nextval;
    vCou := 0;

    dbms_lob.createtemporary(vStats,FALSE);
    FOR idx IN (
      SELECT p.table_owner||'.'||p.table_name AS table_name
            ,p.partition_name AS partition_name
        FROM all_tab_partitions p
        WHERE p.table_owner = UPPER(vOwner)
          AND p.table_name = UPPER(SUBSTR(inTableName,INSTR(inTableName,'.',1,1) + 1))
          AND (UPPER(inSign) IS NULL OR
               UPPER(inSign) IS NOT NULL AND p.partition_name IN (SELECT str FROM TABLE(parse_str(UPPER(inSign),',')))
              )
    ) LOOP
      vBuff :=
      CASE WHEN vCou > 0 THEN CHR(10)||'UNION ALL'||CHR(10) END||'SELECT '''||idx.table_name||'|'||idx.partition_name||''' AS id'||CHR(10)||
      '      ,NULL AS parent_id'||CHR(10)||
      '      ,'''||LOWER(vOwner)||'.pkg_etl_signs.MyExecute'' AS unit'||CHR(10)||
      '      ,q''[BEGIN dbms_stats.gather_table_stats(ownname => '''''||UPPER(vOwner)||''''', tabname => '''''||SUBSTR(inTableName,INSTR(inTableName,'.',1,1) + 1)||''''', partname => '''''||idx.partition_name||''''', degree => 2, granularity => ''''PARTITION''''); END;]'' AS params'||CHR(10)||
      '      ,0 AS skip'||CHR(10)||
      '  FROM dual';
      dbms_lob.writeappend(vStats,LENGTH(vBuff),vBuff);
      vCou := vCou + 1;
    END LOOP;

    load_new(vStats,vJobName);
    --dbms_output.put_line(vStats);

    vEndTime := SYSDATE;
    vMes := 'SUCCESSFULLY :: Table "'||inTableName||'" - stats gathered in '||get_ti_as_hms(vEndTime - vTIBegin);
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.HistTableService',vMes);

  END IF;

  -- Если необходимо сжатие
  IF vCompress THEN
    vTIBegin := SYSDATE;
    vJobName := UPPER(vOwner)||'.SERVICECOMPRESSJOB_'||tb_signs_job_id_seq.nextval;
    -- После сжатия необходимо обязательное перестроение индексов,
    -- т.к. они становятся UNUSABLE
    -- Устанавливаем соответствующий флаг принудительно
    vRebuildIdx := TRUE;

    dbms_lob.createtemporary(vDDL,FALSE);
    vCou := 0;
    FOR idx IN (
      SELECT LOWER(p.table_owner||'.'||p.table_name) AS table_name
            ,LOWER(p.partition_name) AS partition_name
            ,LOWER(s.subpartition_name) AS subpartition_name
        FROM all_tab_partitions p
             LEFT JOIN all_tab_subpartitions s
               ON s.table_owner = p.table_owner
                  AND s.table_name = p.table_name
                  AND s.partition_name = p.partition_name
                  --AND s.num_rows > 0
        WHERE p.table_owner = UPPER(vOwner)
          AND p.table_name = UPPER(SUBSTR(inTableName,INSTR(inTableName,'.',1,1) + 1))
          --AND p.num_rows > 0
          AND (UPPER(inSign) IS NULL OR
               UPPER(inSign) IS NOT NULL AND p.partition_name IN (SELECT str FROM TABLE(parse_str(UPPER(inSign),',')))
              )
    ) LOOP
      vBuff :=
      CASE WHEN vCou > 0 THEN CHR(10)||'UNION ALL'||CHR(10) END||'SELECT '''||idx.table_name||'|'||CASE WHEN idx.subpartition_name IS NULL THEN idx.partition_name ELSE idx.subpartition_name END||''' AS id'||CHR(10)||
      '      ,NULL AS parent_id'||CHR(10)||
      '      ,'''||LOWER(vOwner)||'.pkg_etl_signs.MyExecute'' AS unit'||CHR(10)||
      '      ,''ALTER TABLE '||idx.table_name||' MOVE'||CASE WHEN idx.subpartition_name IS NULL THEN ' PARTITION '||idx.partition_name ELSE ' SUBPARTITION '||idx.subpartition_name END||' COMPRESS'' AS params'||CHR(10)||
      '      ,0 AS skip'||CHR(10)||
      '  FROM dual';
      dbms_lob.writeappend(vDDL,LENGTH(vBuff),vBuff);
      vCou := vCou + 1;
    END LOOP;

    --dbms_output.put_line(vDDL);
    load_new(vDDL,vJobName);

    vEndTime := SYSDATE;
    vMes := 'SUCCESSFULLY :: Table "'||inTableName||'" - '||vCou||' partitions compressed in '||get_ti_as_hms(vEndTime - vTIBegin);
    pr_log_write(lower(vOwner)||'.pkg_etl_signs.HistTableService',vMes);

  END IF;

  -- Если необходимо перестроение индексов
  IF vRebuildIdx THEN
    vTIBegin := SYSDATE;
    dbms_lob.createtemporary(vIDX,FALSE);
    vBuff := 'BEGIN'||CHR(10);
    dbms_lob.writeappend(vIDX,LENGTH(vBuff),vBuff);
    vCou := 0;
    FOR idx IN (
      SELECT LOWER(i.owner||'.'||i.index_name) AS index_name
            ,LOWER(ip.partition_name) AS partition_name
            ,LOWER(sp.subpartition_name) AS subpartition_name
        FROM all_indexes i
             LEFT JOIN all_ind_partitions ip
               ON ip.index_owner = i.owner
                  AND ip.index_name = i.index_name
                  AND (UPPER(inSign) IS NULL OR
                       UPPER(inSign) IS NOT NULL AND ip.partition_name IN (SELECT str FROM TABLE(dm_skb.pkg_etl_signs.parse_str(UPPER(inSign),',')))
                      )
             LEFT JOIN all_ind_subpartitions sp
               ON sp.index_owner = ip.index_owner
                  AND sp.index_name = ip.index_name
                  AND sp.partition_name = ip.partition_name
        WHERE i.owner = UPPER(vOwner)
          AND i.table_name = UPPER(SUBSTR(inTableName,INSTR(inTableName,'.',1,1) + 1))
    ) LOOP
      vBuff := 'EXECUTE IMMEDIATE ''ALTER INDEX '||idx.index_name||' REBUILD'||CASE WHEN idx.subpartition_name IS NULL THEN ' PARTITION '||idx.partition_name ELSE ' SUBPARTITION '||idx.subpartition_name END||' PARALLEL 16''; '||CHR(10);
      dbms_lob.writeappend(vIDX,LENGTH(vBuff),vBuff);
      vCou := vCou + 1;
    END LOOP;
    vBuff := 'END;';
    dbms_lob.writeappend(vIDX,LENGTH(vBuff),vBuff);

    BEGIN
      EXECUTE IMMEDIATE vIDX;
      --dbms_output.put_line(vIDX);

      vEndTime := SYSDATE;
      vMes := 'SUCCESSFULLY :: Table "'||inTableName||'" - '||vCou||' partitions rebuilded in '||get_ti_as_hms(vEndTime - vTIBegin);
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.HistTableService',vMes);
    EXCEPTION WHEN OTHERS THEN
      vEndTime := SYSDATE;
      vMes := 'ERROR :: Table "'||inTableName||'" :: Rebuild of indexses finished in '||get_ti_as_hms(vEndTime - vTIBegin)||' with error:'||CHR(10)||SQLERRM;
      pr_log_write(lower(vOwner)||'.pkg_etl_signs.HistTableService',vMes);
    END;
  END IF;

  vEndTime := SYSDATE;
  vMes := 'FINISH :: "'||inTableName||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.HistTableService" finished sucessfully in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.HistTableService',vMes);

EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: "'||inTableName||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.HistTableService" :: '||SQLERRM;
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.HistTableService',vMes);
  vEndTime := SYSDATE;
  vMes := 'FINISH :: "'||inTableName||'" - Procedure "'||lower(vOwner)||'.pkg_etl_signs.HistTableService" finished with errors in '||get_ti_as_hms(vEndTime - vBegTime);
  pr_log_write(lower(vOwner)||'.pkg_etl_signs.HistTableService',vMes);
END HistTableService;

FUNCTION GetVarCLOBValue(inVarName VARCHAR2) RETURN CLOB
  IS
    vType VARCHAR2(30);
    vVal CLOB := NULL;
    vRes CLOB := NULL;
    --
    errNotExists EXCEPTION;
BEGIN
  BEGIN
    SELECT var_type INTO vType FROM tb_variable_registry WHERE NAME = inVarName;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RAISE errNotExists;
  END;

  SELECT val INTO vVal FROM tb_variable_registry WHERE NAME = inVarName;

  IF vType = 'Простая' THEN
    RETURN vVal;
  ELSE
    EXECUTE IMMEDIATE vVal USING OUT vRes;
    RETURN vRes;
  END IF;
EXCEPTION
  WHEN errNotExists THEN
    RETURN 'Переменная не найдена';
  WHEN OTHERS THEN
  RETURN SQLERRM;
END;

FUNCTION GetVarValue(inVarName VARCHAR2) RETURN VARCHAR2
IS
BEGIN
  RETURN dbms_lob.substr(pkg_etl_signs.GetVarCLOBValue(inVarName),32700,1);
END;

FUNCTION call_hist(inTable IN VARCHAR2, inID IN VARCHAR2,inAction VARCHAR2) RETURN VARCHAR2
  IS
  vStr VARCHAR2(32700);
  vRes VARCHAR2(4000);
BEGIN
  IF NOT(UPPER(inAction) IN ('ON','OFF')) THEN
    RAISE_APPLICATION_ERROR(-20000,'Неизвестное значение параметра inAction.'||CHR(10)||'Возможные значения параметра inAction: ON - включить; OFF - отключить');
  END IF;

  IF NOT CanHaveHistory(inTable) AND UPPER(inAction) = 'ON' THEN
    RAISE_APPLICATION_ERROR(-20001,'История не может быть включена для таблиц хранения, а так же для фактов и измерений куба');
  END IF;

  IF UPPER(inAction) = 'ON' THEN
    vStr := 'CREATE OR REPLACE TRIGGER '||SUBSTR(inTable,1,24)||'_h_trg';
    vStr := vStr||' AFTER INSERT OR UPDATE OR DELETE'||' ON '||inTable||Chr(10);
    vStr := vStr||'FOR EACH ROW'||Chr(10);
    vStr := vStr||'DECLARE'||Chr(10);
    vStr := vStr||'  vDML_Type VARCHAR2(1);'||Chr(10)||'  vTableID VARCHAR2(255);'||Chr(10);
    vStr := vStr||'BEGIN'||Chr(10);
    vStr := vStr||'  IF DELETING THEN'||Chr(10)||'    vDML_Type := ''D'';'||Chr(10)||'    vTableID := :Old.'||inID||';'||Chr(10)||
                  '  ELSIF INSERTING THEN'||Chr(10)||'    vDML_Type := ''I'';'||Chr(10)||'    vTableID := :New.'||inID||';'||Chr(10)||
                  '  ELSE'||Chr(10)||'    vDML_Type := ''U'';'||Chr(10)||'    vTableID := :Old.'||inID||';'||Chr(10)||
                  '  END IF;'||Chr(10);
    vStr := vStr||'  IF DELETING OR INSERTING THEN'||Chr(10);
    FOR col IN (SELECT column_name,data_type FROM dba_tab_columns
                 WHERE lower(owner||'.'||table_name) = lower(inTable) AND column_name != 'LASTUPDATE'
               )
    LOOP
      vStr := vStr||'    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)'||Chr(10);
      vStr := vStr||'      VALUES('''||UPPER(inTable)||''','''||col.column_name||''',SYSDATE,sys_context(''userenv'',''OS_USER''),sys_context(''userenv'',''IP_ADDRESS''),vDML_Type,'||
        CASE WHEN col.data_type = 'NUMBER' THEN 'to_char(:Old.'||col.column_name||',''FM999999999999999D999999999'',''nls_numeric_characters='''', '''''')'
             WHEN col.data_type = 'DATE' THEN 'to_char(:Old.'||col.column_name||',''DD.MM.YYYY HH24:MI:SS'')'
        ELSE ':Old.'||col.column_name
        END||','||
        CASE WHEN col.data_type = 'NUMBER' THEN 'to_char(:New.'||col.column_name||',''FM999999999999999D999999999'',''nls_numeric_characters='''', '''''')'
             WHEN col.data_type = 'DATE' THEN 'to_char(:New.'||col.column_name||',''DD.MM.YYYY HH24:MI:SS'')'
        ELSE ':New.'||col.column_name
        END||',vTableID);'||Chr(10);
    END LOOP;
    vStr := vStr||'  ELSE'||Chr(10);
    FOR col IN (SELECT column_name,data_type FROM dba_tab_columns
                 WHERE lower(owner||'.'||table_name) = lower(inTable) AND column_name != 'LASTUPDATE'
               )
    LOOP
      vStr := vStr||'    IF :Old.'||col.column_name||' != :New.'||col.column_name||' OR'||Chr(10);
      vStr := vStr||'       :Old.'||col.column_name||' IS NULL AND :New.'||col.column_name||' IS NOT NULL OR'||Chr(10);
      vStr := vStr||'       :Old.'||col.column_name||' IS NOT NULL AND :New.'||col.column_name||' IS NULL'||Chr(10);
      vStr := vStr||'      THEN'||Chr(10);
      vStr := vStr||'        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)'||Chr(10);
      vStr := vStr||'          VALUES('''||UPPER(inTable)||''','''||col.column_name||''',SYSDATE,sys_context(''userenv'',''OS_USER''),sys_context(''userenv'',''IP_ADDRESS''),vDML_Type,'||
        CASE WHEN col.data_type = 'NUMBER' THEN 'to_char(:Old.'||col.column_name||',''FM999999999999999D999999999'',''nls_numeric_characters='''', '''''')'
             WHEN col.data_type = 'DATE' THEN 'to_char(:Old.'||col.column_name||',''DD.MM.YYYY HH24:MI:SS'')'
        ELSE ':Old.'||col.column_name
        END||','||
        CASE WHEN col.data_type = 'NUMBER' THEN 'to_char(:New.'||col.column_name||',''FM999999999999999D999999999'',''nls_numeric_characters='''', '''''')'
             WHEN col.data_type = 'DATE' THEN 'to_char(:New.'||col.column_name||',''DD.MM.YYYY HH24:MI:SS'')'
        ELSE ':New.'||col.column_name
        END||',vTableID);'||Chr(10);
      vStr := vStr||'    END IF;'||Chr(10);
    END LOOP;
    vStr := vStr||'  END IF;'||Chr(10);
    --vStr := vStr||'EXCEPTION WHEN OTHERS THEN NULL;'||Chr(10);
    vStr := vStr||'END;';
    EXECUTE IMMEDIATE vStr;
    BEGIN
      EXECUTE IMMEDIATE 'ALTER TABLE tb_signs_history ADD PARTITION '||UPPER(REPLACE(inTable,'.','#'))||' VALUES('''||UPPER(inTable)||''') STORAGE(INITIAL 64K NEXT 1M)';
    EXCEPTION WHEN OTHERS THEN
      NULL;
    END;
    EXECUTE IMMEDIATE 'GRANT SELECT,INSERT ON tb_signs_history TO '||SUBSTR(inTable,1,INSTR(inTable,'.',1,1) - 1);
    vRes := 'SUCCESSFULLY :: История по таблице "'||inTable||'" успешно включена';
  ELSE
    vStr := 'DROP TRIGGER '||SUBSTR(inTable,1,24)||'_h_trg';
    EXECUTE IMMEDIATE vStr;
    BEGIN
      EXECUTE IMMEDIATE 'REVOKE SELECT,INSERT ON tb_signs_history FROM '||SUBSTR(inTable,1,INSTR(inTable,'.',1,1) - 1);
    EXCEPTION WHEN OTHERS THEN
      NULL;
    END;
    vRes := 'SUCCESSFULLY :: История по таблице "'||inTable||'" успешно отключена';
  END IF;
  RETURN vRes;
EXCEPTION WHEN OTHERS THEN
  RETURN 'ERROR :: Не удалось включить/отключить историю по таблице "'||inTable||'" :: '||SQLERRM||CHR(10)||'---------------------'||CHR(10)||vStr;
END call_hist;

FUNCTION CanHaveHistory(inTable IN VARCHAR2) RETURN BOOLEAN
  IS
    vCou INTEGER := 0;
BEGIN
  WITH
    a AS (
      SELECT LOWER(pkg_etl_signs.GetVarValue('vOwner')||'.'||fct_table_name) AS table_name
        FROM tb_entity
      UNION ALL
      SELECT LOWER(pkg_etl_signs.GetVarValue('vOwner')||'.'||hist_table_name)
        FROM tb_entity
      UNION ALL
      SELECT LOWER(pkg_etl_signs.GetVarValue('vOwner')||'.'||tmp_table_name)
        FROM tb_entity
      UNION ALL
      SELECT LOWER(pkg_etl_signs.GetVarValue('vOwner')||'.'||'fct_'||group_id)
        FROM tb_signs_group
        WHERE parent_group_id IS NOT NULL
      UNION ALL
      SELECT LOWER(pkg_etl_signs.GetVarValue('vOwner')||'.'||'dim_'||g.group_id||'#'||e.id)
        FROM tb_signs_group g
             CROSS JOIN tb_entity e
        WHERE g.parent_group_id IS NULL
      UNION ALL
      SELECT LOWER(pkg_etl_signs.GetVarValue('vOwner')||'.'||'anltline_'||g.group_id||'#'||a.anlt_alias)
        FROM tb_signs_anlt a
             INNER JOIN tb_signs_group g ON g.parent_group_id IS NULL
        WHERE EXISTS (SELECT NULL FROM tb_signs_anlt_spec WHERE anlt_id = a.id)
    )
   ,b AS (
     SELECT LOWER(inTable) AS table_name FROM dual
    )
  SELECT COUNT(1) INTO vCou FROM a INNER JOIN b ON a.table_name = b.table_name;
  IF vCou > 0 THEN RETURN FALSE; ELSE RETURN TRUE; END IF;
END CanHaveHistory;

PROCEDURE SetFlag
  (inName IN VARCHAR2
  ,inDate IN DATE
  ,inVal IN VARCHAR2 DEFAULT NULL
  ,inAction NUMBER DEFAULT 1 -- 1 - UPSERT, 0 - DELETE
  )
  IS
    vMes VARCHAR2(4000);
    vOwner VARCHAR2(256) := getvarvalue('vOwner');
BEGIN
  IF inAction = 1 THEN
    MERGE INTO tb_flags_pool dest
      USING (SELECT inName AS NAME,inDate AS dt, inVal AS val FROM dual) src
         ON (dest.name = src.name AND dest.dt = src.dt)
      WHEN MATCHED THEN
        UPDATE SET dest.val = src.val
      WHEN NOT MATCHED THEN
        INSERT (dest.id,dest.name,dest.dt,dest.val)
          VALUES (tb_flags_pool_id_seq.nextval,src.name,src.dt,src.val);
  ELSE
    DELETE FROM tb_flags_pool WHERE dt = inDate AND NAME = inName;
  END IF;

  COMMIT;
EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: Procedure "'||vOwner||'.pkg_etl_signs.set_flag" :: '||SQLERRM;
  pr_log_write(vOwner||'.pkg_etl_signs.set_flag',vMes);
  COMMIT;
END SetFlag;

FUNCTION GetFlag(inFlagName IN VARCHAR2, inDate IN DATE) RETURN VARCHAR2
  IS
    vRes VARCHAR2(4000) := NULL;
BEGIN
  SELECT val INTO vRes FROM tb_flags_pool WHERE dt = inDate AND NAME = inFlagName;
  RETURN vRes;
EXCEPTION WHEN OTHERS THEN
  RETURN vRes;
END;

FUNCTION PDCA(inObj IN VARCHAR2, inAnalyzeContent IN NUMBER DEFAULT 0) RETURN VARCHAR2
IS
  --inObj VARCHAR2(256) := 'CRE.NBCH_REQUESTOR';
  vSQL CLOB;
  vBuff VARCHAR2(32700);
  vNumRow INTEGER := 0;
  vCols VARCHAR2(32700);
  vCur SYS_REFCURSOR;
  vCurVal VARCHAR2(32700);
  vAnalyzeContent NUMBER := inAnalyzeContent;
  --
  --vRes VARCHAR2(10);
  --
  errYesColumn EXCEPTION;
  errYesContent EXCEPTION;
BEGIN
  dbms_lob.createtemporary(vSQL,FALSE);
  vBuff := 'SELECT col_val FROM ('||CHR(10)||'SELECT '||CHR(10);
  dbms_lob.writeappend(vSQL,LENGTH(vBuff),vBuff);
  vNumRow := 0;
  FOR idx IN (
    SELECT data_type
          ,column_name
          ,row_number() OVER (ORDER BY column_id) AS col_num
      FROM dba_tab_columns
      WHERE owner = SUBSTR(inObj,1,INSTR(inobj,'.',1,1)-1)
        AND table_name = SUBSTR(inObj,INSTR(inobj,'.',1,1)+1,LENGTH(inObj) - INSTR(inobj,'.',1,1))
        AND data_type IN ('NUMBER','VARCHAR2')
        AND NOT(column_name LIKE '%EMPLOYEE%')
        ORDER BY column_id
  ) LOOP

    IF pkg_etl_signs.GetConditionResult(REPLACE(dm_skb.pkg_etl_signs.GetVarValue('PDCA_ColNameContent'),':CONTENT:',''''||idx.column_name||'''')) = 1 THEN RAISE errYesColumn; END IF;

    vCols := vCols||CASE WHEN vNumRow = 0 THEN '' ELSE ',' END||'COL_'||idx.col_num;
    vBuff := CASE WHEN vNumRow = 0 THEN '        ' ELSE '       ,' END||CASE WHEN idx.data_type = 'NUMBER' THEN 'to_char(' END||inObj||'.'||idx.column_name||CASE WHEN idx.data_type = 'NUMBER' THEN ')' END||' AS '||'COL_'||idx.col_num||CHR(10);
    dbms_lob.writeappend(vSQL,LENGTH(vBuff),vBuff);
    vNumRow := vNumRow + 1;
  END LOOP;
  vBuff := '  FROM '||inObj||' WHERE rownum <= 1000'||CHR(10)||') UNPIVOT (col_val FOR col_name IN ('||vCols||'))';
  dbms_lob.writeappend(vSQL,LENGTH(vBuff),vBuff);

  IF vAnalyzeContent = 1 THEN
    OPEN vCur FOR vSQL;

    IF (vCur IS NOT NULL)
      THEN
          LOOP
              FETCH vCur INTO vCurVal;
              EXIT WHEN vCur%NOTFOUND;
              IF pkg_etl_signs.GetConditionResult(REPLACE(dm_skb.pkg_etl_signs.GetVarValue('PDCA_Content'),':CONTENT:','q''['||vCurVal||']''')) = 1 THEN RAISE errYesContent; END IF;
          END LOOP;
          CLOSE vCur;
    END IF;
  END IF;
  IF vAnalyzeContent = 1 THEN RETURN 'NO'; ELSE RETURN 'NO WITHOUT CONTENT ANALYZE'; END IF;
EXCEPTION
  WHEN errYesColumn THEN
    RETURN 'COLUMN';
  WHEN errYesContent THEN
    RETURN 'CONTENT';
    CLOSE vCur;
  WHEN OTHERS THEN
    RETURN 'ERROR';
END PDCA;

FUNCTION SQLasHTML(inSQL IN CLOB,inColNames IN VARCHAR2,inColAliases IN VARCHAR2,inStyle IN VARCHAR2 DEFAULT NULL,inShowLogo BOOLEAN DEFAULT FALSE,inTabHeader VARCHAR2 DEFAULT NULL) RETURN CLOB
IS
  vSQL CLOB;
  vOut CLOB;
  vBuff VARCHAR2(32700);
  vCur SYS_REFCURSOR;
  vKey NUMBER;
  vKeyName VARCHAR2(30);
  vKeyVal VARCHAR2(4000);
  vPrevRowNum NUMBER := 0;
  --
  errSqlIsNull EXCEPTION;
BEGIN
  IF inSQL IS NULL OR inColNames IS NULL OR inColAliases IS NULL THEN RAISE errSqlIsNull; END IF;
  vSQL := 'SELECT * FROM (SELECT row_number() OVER (ORDER BY null) AS rownum_key,'||REPLACE(inColNames,'#!#',',')||' FROM ('||inSQL||')) UNPIVOT INCLUDE NULLS (key_val FOR key_name IN ('||REPLACE(inColNames,'#!#',',')||'))';
  dbms_lob.createtemporary(vOut,FALSE);
  vBuff :=
  '<!DOCTYPE html>'||Chr(10)||'<html>'||Chr(10)||'<head>'||Chr(10)||pkg_etl_signs.GetVarValue('HTMLEncoding')||CHR(10)||CASE WHEN inStyle IS NULL THEN pkg_etl_signs.GetVarValue('HTMLTableStyle') ELSE inStyle END||Chr(10)||
  '</head>'||Chr(10)||'<body>'||Chr(10)||CASE WHEN inShowLogo THEN pkg_etl_signs.GetVarValue('HTMLLogo')||CHR(10) ELSE NULL END||
  CASE WHEN inTabHeader IS NOT NULL THEN '<br>'||inTabHeader||'<br>' ELSE NULL END||
  '<table>'||Chr(10);
  dbms_lob.writeappend(vOut,LENGTH(vBuff),vBuff);
  vBuff := '<tr><th>'||REPLACE(inColAliases,'#!#','</th><th>');
  dbms_lob.writeappend(vOut,LENGTH(vBuff),vBuff);

  OPEN vCur FOR vSQL;
  IF (vCur IS NOT NULL) THEN
    LOOP
      FETCH vCur INTO vKey,vKeyName,vKeyVal;
      EXIT WHEN vCur%NOTFOUND;
      vKeyVal := '<td>'||vKeyVal||'</td>';
      IF vPrevRowNum < vKey THEN vKeyVal := '</tr>'||CHR(10)||'<tr>'||vKeyVal; END IF;
      vBuff := vKeyVal;
      dbms_lob.writeappend(vOut,LENGTH(vBuff),vBuff);
      vPrevRowNum := vKey;
    END LOOP;
    CLOSE vCur;
  END IF;
  vBuff := '</tr>'||CHR(10)||'</body>'||CHR(10)||'</html>';
  dbms_lob.writeappend(vOut,LENGTH(vBuff),vBuff);
  RETURN vOut;
EXCEPTION
  WHEN errSqlIsNull THEN RETURN ('NULL');
  WHEN OTHERS THEN RETURN SQLERRM;
END SQLasHTML;


END pkg_etl_signs;
/

prompt
prompt Creating package body PKG_REP_AGGR
prompt ==================================
prompt
CREATE OR REPLACE PACKAGE BODY DM_SKB.pkg_rep_aggr
IS

--------------------------------ПОЛУЧЕНИЕ ДАННЫХ---------------------------------------------
FUNCTION get_ptb_bbalance_fact (inDate DATE) RETURN tabGetPtbBbalanceFact PIPELINED
  AS
    rec recGetPtbBbalanceFact;
BEGIN
  FOR idx IN (WITH
               np AS (SELECT /*+ materialize */
                              cc.contract_sid,
                              hh_dm.sname old_p,
                              hh_bal.sname new_p
                        FROM
                        alm.i_contract_corrected cc
                        LEFT OUTER JOIN
                        dwh.ref_product_hist hh_dm
                        ON hh_dm.product_id = old_product_id
                        AND hh_dm.end_date = to_date('31.12.9999','DD.MM.YYYY')
                        LEFT OUTER JOIN
                        dwh.ref_product_hist hh_bal
                        ON hh_bal.product_id = new_product_id
                        AND hh_bal.end_date = to_date('31.12.9999','DD.MM.YYYY')
                     )
              SELECT inDate as_of_date
                    ,dim_key,rule_id
                    --,MAX(abs_department_id) AS abs_department_id
                    ,NVL(abs_department_sid,-1) AS abs_department_id
                    ,cur_id
                    ,SUM(DECODE(flg,1,val,NULL)) val
                    ,SUM(DECODE(flg,2,val,NULL)) val_prev
                    --,NVL(SUM(DECODE(flg,3,val,NULL)),SUM(DECODE(flg,2,val,NULL))) val_mb
                    ,CASE inDate WHEN TRUNC(inDate,'MM') THEN SUM(DECODE(flg,2,val,NULL))
                     ELSE SUM(DECODE(flg,3,val,NULL)) END val_mb
                    ,NVL(new_p,skb_ecc.get_dim(dim_key,1)) product_id
                    ,skb_ecc.get_dim(dim_key,2) dim2_id
                    ,source_system_id
                FROM (SELECT dim_key,rule_id
                            --,MAX(dm.abs_department_id) AS abs_department_id
                            ,dm.cur_id
                            ,SUM(value) AS val
                            ,DECODE(as_of_date,inDate,1,inDate-1,2,TRUNC(inDate,'MM')-1,3) AS flg
                            ,d.abs_department_sid
                            ,MOD(d.abs_department_sid,10) AS source_system_id
                            ,np.new_p
                        FROM skb_ecc.ecc_dm_1 dm
                              /*LEFT JOIN dwh.ref_abs_department a
                               ON a.source_system_id = MOD(dm.abs_department_sid,10)
                                  AND a.abs_department_gid = (dm.abs_department_sid-MOD(dm.abs_department_sid,10))/10
                                  AND a.end_date = to_date('31.12.5999','DD.MM.YYYY')
                                  AND dm.as_of_date BETWEEN a.effective_start AND a.effective_end*/
                            /*LEFT JOIN dwh.ref_contract c
                               ON c.contract_id = dm.contract_id*/
                             LEFT JOIN np
                               ON np.contract_sid = dm.contract_sid
                                  AND np.old_p = SUBSTR(dm.dim_key,2,6)
                             LEFT JOIN dwh.ref_abs_department d ON d.abs_department_id = dm.abs_department_id
                        WHERE as_of_date IN (inDate,TRUNC(inDate,'MM')-1,inDate-1)
                      GROUP BY dim_key,rule_id,d.abs_department_sid,dm.cur_id,as_of_date
                              /*,a.source_system_id*/,np.new_p
                      UNION ALL
                      SELECT dim_key,rule_id
                            --,MAX(dm.abs_department_id) AS abs_department_id
                            ,dm.cur_id
                            ,SUM(value)
                            ,DECODE(as_of_date,inDate,1,inDate-1,2,TRUNC(inDate,'MM')-1,3) AS flg
                            ,d.abs_department_sid
                            ,d.source_system_id
                            ,NULL
                        FROM skb_ecc.ecc_dm_3 dm
                             LEFT JOIN dwh.ref_abs_department d ON d.abs_department_id = dm.abs_department_id
                        WHERE as_of_date IN (inDate,TRUNC(inDate,'MM')-1,inDate-1)
                      GROUP BY dim_key,rule_id,d.abs_department_sid,dm.cur_id,as_of_date,d.source_system_id
                      UNION ALL
                      SELECT dim_key
                            ,rule_id
                            --,MAX(dm.abs_department_id) AS abs_department_id
                            ,dm.cur_id
                            ,SUM(value)
                            ,DECODE(as_of_date,inDate,1,inDate-1,2,TRUNC(inDate,'MM')-1,3) AS flg
                            ,d.abs_department_sid
                            ,c.source_system_id
                            ,np.new_p
                        FROM skb_ecc.ecc_dm_5 dm
                             LEFT JOIN dwh.ref_abs_department d ON d.abs_department_id = dm.abs_department_id
                             LEFT JOIN dwh.ref_contract c
                               ON c.contract_id = dm.contract_id
                             LEFT JOIN np
                               ON np.contract_sid = c.contract_sid
                                  AND np.old_p = SUBSTR(dm.dim_key,2,6)
                        WHERE as_of_date IN (inDate,TRUNC(inDate,'MM')-1,inDate-1)
                      GROUP BY as_of_date,dim_key,rule_id,d.abs_department_sid,dm.cur_id,as_of_date
                              ,c.source_system_id,np.new_p
                     ) a
             GROUP BY dim_key,rule_id,abs_department_sid,cur_id,source_system_id,new_p
             )
  LOOP
    rec.as_of_date := idx.as_of_date;
    rec.dim_key := idx.dim_key;
    rec.rule_id := idx.rule_id;
    rec.abs_department_id := idx.abs_department_id;
    rec.cur_id := idx.cur_id;
    rec.product_id := idx.product_id;
    rec.dim2_id := idx.dim2_id;
    rec.val := idx.val;
    rec.val_prev := idx.val_prev;
    rec.val_mb := idx.val_mb;
    rec.source_system_id := idx.source_system_id;
    PIPE ROW(rec);
  END LOOP;
END get_ptb_bbalance_fact;
------------------------------------ИЗМЕРЕНИЯ------------------------------------------------
--Справочник клиентов (universal client,is_main = 1)
PROCEDURE tb_ref_client_actual_all
  IS
    vMes VARCHAR2(2000);
    vBegTime DATE := SYSDATE;
    vTIBegin DATE := SYSDATE;
    vEndTime DATE;
BEGIN
  vMes := 'START :: Procedure "dm_skb.tb_ref_client_actual_all" started.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_client_actual_all',vMes);

  EXECUTE IMMEDIATE 'TRUNCATE TABLE dm_skb.tb_ref_client_actual';
  vMes := 'SUCCESSFULLY :: Table "dm_skb.tb_ref_client_actual" truncated.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_client_actual_all',vMes);

  BEGIN
  EXECUTE IMMEDIATE 'DROP INDEX dm_skb.idx_tb_ref_client_actual_u001';
  EXECUTE IMMEDIATE 'DROP INDEX dm_skb.idx_tb_ref_client_actual_u002';
  EXCEPTION WHEN OTHERS THEN NULL;
  END;

  vMes := 'SUCCESSFULLY :: 2 indexes dropped from table "dm_skb.tb_ref_client_actual".';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_client_actual_all',vMes);

  vTIBegin := SYSDATE;
  INSERT /*+ APPEND */ INTO dm_skb.tb_ref_client_actual
    (client_id,client_gid,client_type_flg,client_sid
    ,cl_name,short_name,tin,birth_date,place_birth,ogrn,doc_ser
    ,doc_num,doc_date,doc_org,doc_type,source_system_id,bik,sex,resident_flg
    ,uc_id
    ,mobile_phone,work_phone,home_phone,contact_phone
    ,sms_phone,communication_phone,fact_region,fact_area,fact_city,fact_street
    ,fact_house,fact_flat,fact_okato,reg_region,reg_area,reg_city,reg_street
    ,reg_house,reg_flat,reg_okato,e_mail,client_age,fact_address,reg_address
    ,effective_start
    ,date_create_crd_claim
    ,job_place_last_claim
    ,emp_of_accr_company
    ,work_date
    ,work_level
    ,work_title
    ,cp_email
    ,phc_email
    )
  SELECT uu.CLIENT_ID
        ,uu.CLIENT_GID
        ,DECODE(TRIM(uu.CLIENT_TYPE_FLG),NULL,'Не указан','Ф','Физическое лицо','Юридическое лицо') AS CLIENT_TYPE_FLG
        ,uu.client_sid
        ,uu.NAME AS cl_name
        ,uu.SHORT_NAME
        ,uu.tin
        ,uu.BIRTH_DATE
        ,uu.place_birth
        ,uu.OGRN
        ,uu.DOC_SER
        ,uu.DOC_NUM
        ,uu.DOC_DATE
        ,uu.DOC_ORG
        ,uu.DOC_TYPE
        ,uu.source_system_id
        ,uu.bik
        ,uu.sex
        ,uu.resident_flg
        ,a1.uc_id
        ,cp.mobile_phone_calc AS mobile_phone
        ,cp.work_phone
        ,cp.home_phone
        ,cp.contact_phone_calc AS contact_phone
        ,cp.sms_phone
        ,cp.communication_phone
        ,phc.fact_region
        ,phc.fact_area
        ,phc.fact_city
        ,phc.fact_street
        ,phc.fact_house
        ,phc.fact_flat
        ,phc.fact_okato
        ,phc.reg_region
        ,phc.reg_area
        ,phc.reg_city
        ,phc.reg_street
        ,phc.reg_house
        ,phc.reg_flat
        ,phc.reg_okato
        ,NVL(cp.email,phc.p_268) AS e_mail
        ,DECODE(uu.birth_date,to_date('01.01.1900','DD.MM.YYYY'),NULL
                             ,TRUNC(ABS(months_between(uu.birth_date,trunc(SYSDATE)))/12)
                     ) AS client_age
        ,NVL(phc.fact_region,'')||','||NVL(phc.fact_area,'')||','||NVL(phc.fact_city,'')||','||NVL(phc.fact_street,'')||
                     ','||NVL(phc.fact_house,'')||','||NVL(phc.fact_flat,'') AS fact_address
        ,NVL(phc.reg_region,'')||','||NVL(phc.reg_area,'')||','||NVL(phc.reg_city,'')||','||NVL(phc.reg_street,'')||
                     ','||NVL(phc.reg_house,'')||','||NVL(phc.reg_flat,'') AS reg_address
------------
        ,uu.effective_start
        ,phc.date_create_crd_claim
        ,phc.p_239 AS job_place_last_claim
        ,phc.p_239_calc AS emp_of_accr_company
        ,phc.work_date
        ,phc.work_level
        ,phc.work_title
        ,cp.email AS cp_email
        ,phc.p_268 AS phc_email
    FROM dwh.ref_client uu
         LEFT JOIN dm_skb.dm_uc_client a1
                   ON uu.client_id = a1.client_id
         LEFT JOIN dm_clant.dm_client_phone cp
           ON cp.client_sid = uu.client_sid
         LEFT JOIN dm_clant.dm_phys_client phc
           ON phc.client_sid = uu.client_sid

    WHERE uu.end_date = to_Date('31.12.5999','DD.MM.YYYY') AND uu.effective_end = to_Date('31.12.5999','DD.MM.YYYY')
;

  vEndTime := SYSDATE;
  vMes := 'SUCCESSFULLY :: '||SQL%ROWCOUNT||' rows inserted into table "dm_skb.tb_ref_client_actual" in '||dm_skb.get_ti_as_hms(vEndTime - vTIBegin)||' successfully.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_client_actual_all',vMes);

  vTIBegin := SYSDATE;
  EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX dm_skb.idx_tb_ref_client_actual_u001 ON dm_skb.tb_ref_client_actual (client_id)';
  EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX dm_skb.idx_tb_ref_client_actual_u002 ON dm_skb.tb_ref_client_actual (client_sid)';

  vEndTime := SYSDATE;
  vMes := 'SUCCESSFULLY :: 2 indexes created on table "dm_skb.tb_ref_client_actual" in '||dm_skb.get_ti_as_hms(vEndTime - vTIBegin)||' successfully.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_client_actual_all',vMes);

  vMes := 'FINISH :: Procedure "dm_skb.pkg_rep_aggr.tb_ref_client_actual_all" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' successfully.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_client_actual_all',vMes);
EXCEPTION WHEN OTHERS THEN
    vEndTime := SYSDATE;
    vMes := 'ERROR :: Procedure "dm_skb.pkg_rep_aggr.tb_ref_client_actual_all" :: '||SQLERRM;
    dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_client_actual_all',vMes);
    vMes := 'FINISH :: Procedure "dm_skb.pkg_rep_aggr.tb_ref_client_actual_all" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' with errors.';
    dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_client_actual_all',vMes);
END tb_ref_client_actual_all;

PROCEDURE tb_ref_client_actual
  IS
    vMes VARCHAR2(2000);
    vBegTime DATE := SYSDATE;
    vTIBegin DATE := SYSDATE;
    vEndTime DATE;
BEGIN
  vMes := 'START :: Procedure "dm_skb.tb_ref_client_actual" started.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_client_actual',vMes);

  vTIBegin := SYSDATE;
  MERGE INTO dm_skb.tb_ref_client_actual dest
    USING  (SELECT client_id,client_gid,client_type_flg,client_sid
                  ,cl_name,short_name,tin,birth_date,place_birth,ogrn,doc_ser
                  ,doc_num,doc_date,doc_org,doc_type,source_system_id,bik,sex,resident_flg
                  ,uc_id
                  ,mobile_phone,work_phone,home_phone,contact_phone
                  ,sms_phone,communication_phone,fact_region,fact_area,fact_city,fact_street
                  ,fact_house,fact_flat,fact_okato,reg_region,reg_area,reg_city,reg_street
                  ,reg_house,reg_flat,reg_okato,e_mail,client_age,fact_address,reg_address
                  ,effective_start
                  ,date_create_crd_claim
                  ,job_place_last_claim
                  ,emp_of_accr_company
                  ,work_date
                  ,work_level
                  ,work_title
                  ,cp_email
                  ,phc_email
              FROM dm_skb.v_ref_client_actual_for_update
           ) src ON (dest.client_sid = src.client_sid)
    WHEN MATCHED THEN UPDATE SET
      dest.client_id = src.client_id
     ,dest.client_gid = src.client_gid
     ,dest.client_type_flg = src.client_type_flg
     ,dest.cl_name = src.cl_name
     ,dest.short_name = src.short_name
     ,dest.tin = src.tin
     ,dest.birth_date = src.birth_date
     ,dest.place_birth = src.place_birth
     ,dest.ogrn = src.ogrn
     ,dest.doc_ser = src.ogrn
     ,dest.doc_num = src.doc_num
     ,dest.doc_date = src.doc_date
     ,dest.doc_org = src.doc_org
     ,dest.doc_type = src.doc_type
     ,dest.source_system_id = src.source_system_id
     ,dest.uc_id = src.uc_id
     ,dest.mobile_phone = src.mobile_phone
     ,dest.work_phone = src.work_phone
     ,dest.home_phone = src.home_phone
     ,dest.contact_phone = src.contact_phone
     ,dest.sms_phone = src.sms_phone
     ,dest.communication_phone = src.communication_phone
     ,dest.fact_region = src.fact_region
     ,dest.fact_area = src.fact_area
     ,dest.fact_city = src.fact_city
     ,dest.fact_street = src.fact_street
     ,dest.fact_house = src.fact_house
     ,dest.fact_flat = src.fact_flat
     ,dest.fact_okato = src.fact_okato
     ,dest.reg_region = src.reg_region
     ,dest.reg_area = src.reg_area
     ,dest.reg_city = src.reg_city
     ,dest.reg_street = src.reg_street
     ,dest.reg_house = src.reg_house
     ,dest.reg_flat = src.reg_flat
     ,dest.reg_okato = src.reg_okato
     ,dest.e_mail = src.e_mail
     ,dest.client_age = src.client_age
     ,dest.fact_address = src.fact_address
     ,dest.reg_address = src.reg_address
     ,dest.effective_start = src.effective_start
     ,dest.date_create_crd_claim = src.date_create_crd_claim
     ,dest.job_place_last_claim = src.job_place_last_claim
     ,dest.emp_of_accr_company = src.emp_of_accr_company
     ,dest.work_date = src.work_date
     ,dest.work_level = src.work_level
     ,dest.work_title = src.work_title
     ,dest.cp_email = src.cp_email
     ,dest.phc_email = src.phc_email
  WHEN NOT MATCHED THEN INSERT
    (dest.client_id,dest.client_gid,dest.client_type_flg,dest.client_sid
    ,dest.cl_name,dest.short_name,dest.tin,dest.birth_date,dest.place_birth
    ,dest.ogrn,dest.doc_ser
    ,dest.doc_num,dest.doc_date,dest.doc_org,dest.doc_type,dest.source_system_id
    ,dest.uc_id
    ,dest.mobile_phone,dest.work_phone,dest.home_phone,dest.contact_phone
    ,dest.sms_phone,dest.communication_phone,dest.fact_region,dest.fact_area
    ,dest.fact_city,dest.fact_street
    ,dest.fact_house,dest.fact_flat,dest.fact_okato,dest.reg_region,dest.reg_area
    ,dest.reg_city,dest.reg_street
    ,dest.reg_house,dest.reg_flat,dest.reg_okato,dest.e_mail,dest.client_age
    ,dest.fact_address,dest.reg_address
    ,dest.effective_start
    ,dest.date_create_crd_claim
    ,dest.job_place_last_claim
    ,dest.emp_of_accr_company
    ,dest.work_date
    ,dest.work_level
    ,dest.work_title
    ,dest.cp_email
    ,dest.phc_email
    )
    VALUES
    (src.client_id,src.client_gid,src.client_type_flg,src.client_sid
    ,src.cl_name,src.short_name,src.tin,src.birth_date,src.place_birth
    ,src.ogrn,src.doc_ser
    ,src.doc_num,src.doc_date,src.doc_org,src.doc_type,src.source_system_id
    ,src.uc_id
    ,src.mobile_phone,src.work_phone,src.home_phone,src.contact_phone
    ,src.sms_phone,src.communication_phone,src.fact_region,src.fact_area
    ,src.fact_city,src.fact_street
    ,src.fact_house,src.fact_flat,src.fact_okato,src.reg_region,src.reg_area
    ,src.reg_city,src.reg_street
    ,src.reg_house,src.reg_flat,src.reg_okato,src.e_mail,src.client_age
    ,src.fact_address,src.reg_address
    ,src.effective_start
    ,src.date_create_crd_claim
    ,src.job_place_last_claim
    ,src.emp_of_accr_company
    ,src.work_date
    ,src.work_level
    ,src.work_title
    ,src.cp_email
    ,src.phc_email
    );

  vEndTime := SYSDATE;
  vMes := 'SUCCESSFULLY :: '||SQL%ROWCOUNT||' rows merged into table "dm_skb.tb_ref_client_actual" in '||dm_skb.get_ti_as_hms(vEndTime - vTIBegin)||' successfully.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_client_actual',vMes);

  vMes := 'FINISH :: Procedure "dm_skb.pkg_rep_aggr.tb_ref_client_actual" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' successfully.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_client_actual',vMes);
EXCEPTION WHEN OTHERS THEN
    vEndTime := SYSDATE;
    vMes := 'ERROR :: Procedure "dm_skb.pkg_rep_aggr.tb_ref_client_actual" :: '||SQLERRM;
    dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_client_actual',vMes);
    vMes := 'FINISH :: Procedure "dm_skb.pkg_rep_aggr.tb_ref_client_actual" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' with errors.';
    dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_client_actual',vMes);
END tb_ref_client_actual;

-- Справочник сводных счетов
PROCEDURE tb_ref_account
  IS
    vMes VARCHAR2(2000);
    vBegTime DATE := SYSDATE;
    vTIBegin DATE := SYSDATE;
    vEndTime DATE;
BEGIN
  vMes := 'START :: Procedure "dm_skb.tb_ref_account" started.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_account',vMes);

  EXECUTE IMMEDIATE 'TRUNCATE TABLE dm_skb.tb_ref_account';

  vMes := 'SUCCESSFULLY :: Table "dm_skb.tb_ref_account" truncated.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_account',vMes);

  vTIBegin := SYSDATE;
  INSERT INTO dm_skb.tb_ref_account (account_number)
    SELECT DISTINCT b.account_number
      FROM (
            SELECT summary_account_sid
              FROM DWH.REF_ACCOUNT
              WHERE SYSDATE BETWEEN effective_start AND effective_end
                    AND end_date = to_date('31.12.5999','DD.MM.YYYY')
            GROUP BY  summary_account_sid
           ) a INNER JOIN DWH.REF_ACCOUNT b
                 ON b.account_sid = a.summary_account_sid
                    AND SYSDATE BETWEEN b.effective_start AND b.effective_end
                    AND b.end_date = to_date('31.12.5999','DD.MM.YYYY');

  vEndTime := SYSDATE;
  vMes := 'SUCCESSFULLY :: '||SQL%ROWCOUNT||' rows inserted into table "dm_skb.tb_ref_account" in '||dm_skb.get_ti_as_hms(vEndTime - vTIBegin)||' successfully.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_account',vMes);

  vMes := 'FINISH :: Procedure "dm_skb.pkg_rep_aggr.tb_ref_account" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' successfully.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_account',vMes);
EXCEPTION WHEN OTHERS THEN
    vEndTime := SYSDATE;

    vMes := 'ERROR :: Procedure "dm_skb.pkg_rep_aggr.tb_ref_account" :: '||SQLERRM;
    dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_account',vMes);
    vMes := 'FINISH :: Procedure "dm_skb.pkg_rep_aggr.tb_ref_account" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' with errors.';
    dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_ref_account',vMes);
END tb_ref_account;

-- Универсальный клиент (surce - destination)
PROCEDURE tb_rep_uclient_fact
  IS
    vMes VARCHAR2(4000) := 'START :: Procedure "dm_skb.pkg_rep_aggr.tb_rep_uclient_fact" started.';
    vBegTime DATE := SYSDATE;
    vTIBegin DATE := SYSDATE;
    vEndTime DATE;
BEGIN
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_rep_uclient_fact',vMes);

  EXECUTE IMMEDIATE 'TRUNCATE TABLE dm_skb.tb_rep_uclient_fact';

  vMes := 'SUCCESSFULLY :: Table "dm_skb.tb_rep_uclient_fact" truncated.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_rep_uclient_fact',vMes);


  /*EXECUTE IMMEDIATE 'DROP INDEX dm_skb.idx_tb_rep_uclient_fact_u001';
  EXECUTE IMMEDIATE 'DROP INDEX dm_skb.idx_tb_rep_uclient_fact_002';
  EXECUTE IMMEDIATE 'DROP INDEX dm_skb.idx_tb_rep_uclient_fact_003';
  EXECUTE IMMEDIATE 'DROP INDEX dm_skb.idx_tb_rep_uclient_fact_004';
  EXECUTE IMMEDIATE 'DROP INDEX dm_skb.idx_tb_rep_uclient_fact_005';
  EXECUTE IMMEDIATE 'DROP INDEX dm_skb.idx_tb_rep_uclient_fact_006';
  EXECUTE IMMEDIATE 'DROP INDEX dm_skb.idx_tb_rep_uclient_fact_007';
  EXECUTE IMMEDIATE 'DROP INDEX dm_skb.idx_tb_rep_uclient_fact_008';
  EXECUTE IMMEDIATE 'DROP INDEX dm_skb.idx_tb_rep_uclient_fact_009';
  EXECUTE IMMEDIATE 'DROP INDEX dm_skb.idx_tb_rep_uclient_fact_010';
  EXECUTE IMMEDIATE 'DROP INDEX dm_skb.idx_tb_rep_uclient_fact_011';
  EXECUTE IMMEDIATE 'DROP INDEX dm_skb.idx_tb_rep_uclient_fact_012';

  vMes := 'SUCCESSFULLY :: 12 indexes dropped from table "dm_skb.tb_rep_uclient_fact" successfully.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_rep_uclient_fact',vMes);*/

  vTIBegin := SYSDATE;
  INSERT INTO dm_skb.tb_rep_uclient_fact
  SELECT a1.client_id AS s_client_id
      ,CASE WHEN trim(rr1.client_type_flg) LIKE 'Ф%' THEN 1 ELSE 0 END AS s_client_type_id
      ,rr1.source_system_id AS s_source_system_id
      ,CASE WHEN rr1.is_vip = 1 OR rr1.rel_warr_bank = 'VIP' THEN 'Да' ELSE 'Нет' END AS s_vip_id
      ,NVL(rr1.sex,-1) AS s_sex_id
      ,a1.client_id AS s_q

      ,a2.client_id AS d_client_id
      ,CASE WHEN trim(rr2.client_type_flg) LIKE 'Ф%' THEN 1 ELSE 0 END AS d_client_type_id
      ,rr2.source_system_id AS d_source_system_id
      ,CASE WHEN rr2.is_vip = 1 OR rr2.rel_warr_bank = 'VIP' THEN 'Да' ELSE 'Нет' END AS d_vip_id
      ,NVL(rr2.sex,-1) AS d_sex_id
      ,a1.uc_id AS d_q

      ,a1.client_sid AS s_client_sid
      ,a2.client_sid AS d_client_sid
      ,a1.is_main

  FROM dm_skb.dm_uc_client a1
       INNER JOIN dm_skb.dm_uc_client a2 ON a1.uc_id = a2.uc_id  AND a2.is_main = 1
       INNER JOIN DWH.REF_CLIENT rr1 ON rr1.client_id = a1.client_id
       INNER JOIN DWH.REF_CLIENT rr2 ON rr2.client_id = a2.client_id
  ;

  vEndTime := SYSDATE;
  vMes := 'SUCCESSFULLY :: '||SQL%ROWCOUNT||' rows inserted into table "dm_skb.tb_rep_uclient_fact" in '||dm_skb.get_ti_as_hms(vEndTime - vTIBegin)||' successfully.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_rep_uclient_fact',vMes);

  /*vTIBegin := SYSDATE;
  EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX dm_skb.idx_tb_rep_uclient_fact_u001 ON dm_skb.tb_rep_uclient_fact (s_client_id)';
  EXECUTE IMMEDIATE 'CREATE INDEX dm_skb.idx_tb_rep_uclient_fact_002 ON dm_skb.tb_rep_uclient_fact (s_client_type_id)';
  EXECUTE IMMEDIATE 'CREATE INDEX dm_skb.idx_tb_rep_uclient_fact_003 ON dm_skb.tb_rep_uclient_fact (s_source_system_id)';
  EXECUTE IMMEDIATE 'CREATE INDEX dm_skb.idx_tb_rep_uclient_fact_004 ON dm_skb.tb_rep_uclient_fact (s_vip_id)';
  EXECUTE IMMEDIATE 'CREATE INDEX dm_skb.idx_tb_rep_uclient_fact_005 ON dm_skb.tb_rep_uclient_fact (s_sex_id)';
  EXECUTE IMMEDIATE 'CREATE INDEX dm_skb.idx_tb_rep_uclient_fact_006 ON dm_skb.tb_rep_uclient_fact (d_client_id)';
  EXECUTE IMMEDIATE 'CREATE INDEX dm_skb.idx_tb_rep_uclient_fact_007 ON dm_skb.tb_rep_uclient_fact (d_client_type_id)';
  EXECUTE IMMEDIATE 'CREATE INDEX dm_skb.idx_tb_rep_uclient_fact_008 ON dm_skb.tb_rep_uclient_fact (d_source_system_id)';
  EXECUTE IMMEDIATE 'CREATE INDEX dm_skb.idx_tb_rep_uclient_fact_009 ON dm_skb.tb_rep_uclient_fact (d_vip_id)';
  EXECUTE IMMEDIATE 'CREATE INDEX dm_skb.idx_tb_rep_uclient_fact_010 ON dm_skb.tb_rep_uclient_fact (d_sex_id)';
  EXECUTE IMMEDIATE 'CREATE INDEX dm_skb.idx_tb_rep_uclient_fact_011 ON dm_skb.tb_rep_uclient_fact (s_client_sid)';
  EXECUTE IMMEDIATE 'CREATE INDEX dm_skb.idx_tb_rep_uclient_fact_012 ON dm_skb.tb_rep_uclient_fact (d_client_sid)';

  vEndTime := SYSDATE;
  vMes := 'SUCCESSFULLY :: 12 indexes created on table "dm_skb.tb_rep_uclient_fact" in '||dm_skb.get_ti_as_hms(vEndTime - vTIBegin)||' successfully.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_rep_uclient_fact',vMes);*/

  vMes := 'FINISH :: Procedure "dm_skb.pkg_rep_aggr.tb_rep_uclient_fact" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' successfully.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_rep_uclient_fact',vMes);
EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: Table "dm_skb.tb_rep_uclient_fact" aggregation failed :: '||SQLERRM;
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_rep_uclient_fact',vMes);

  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "dm_skb.pkg_rep_aggr.tb_rep_uclient_fact" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' with errors.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_rep_uclient_fact',vMes);
END tb_rep_uclient_fact;

-- Справочник продуктов
PROCEDURE mv_rep_product_dim
  IS
    vMes VARCHAR2(2000);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
BEGIN
  vMes := 'START :: Procedure "dm_skb.pkg_rep_aggr.mv_rep_product_dim" started.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.mv_rep_product_dim',vMes);

  dbms_mview.refresh('dm_skb.mv_rep_product_dim');

  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "dm_skb.pkg_rep_aggr.mv_rep_product_dim" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' successfully.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.mv_rep_product_dim',vMes);
EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: MView "dm_skb.mv_rep_product_dim" aggregation failed :: '||SQLERRM;
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.mv_rep_product_dim',vMes);

  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "dm_skb.pkg_rep_aggr.mv_rep_product_dim" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' with errors.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.mv_rep_product_dim',vMes);
END mv_rep_product_dim;

-- Справочник городов по ОКАТО
PROCEDURE mv_ref_city
  IS
    vMes VARCHAR2(2000);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
BEGIN
  vMes := 'START :: Procedure "dm_skb.pkg_rep_aggr.mv_ref_city" started.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.mv_ref_city',vMes);

  dbms_mview.refresh('dm_skb.mv_ref_city');

  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "dm_skb.pkg_rep_aggr.mv_ref_city" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' successfully.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.mv_ref_city',vMes);
EXCEPTION WHEN OTHERS THEN
  vMes := 'ERROR :: MView "dm_skb.mv_ref_city" aggregation failed :: '||SQLERRM;
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.mv_ref_city',vMes);

  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "dm_skb.pkg_rep_aggr.mv_ref_city" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' with errors.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.mv_ref_city',vMes);
END mv_ref_city;

------------------------------------------- ФАКТЫ ----------------------------------------------
PROCEDURE ptb_bbalance_fact (inBegDt IN DATE, inEndDt IN DATE)
  IS
  vMes VARCHAR2(2000);
  vDays INTEGER;
  vBegTime DATE := SYSDATE;
  vEndTime DATE;
BEGIN
  vDays := inEndDt - inBegDt;
  vMes := 'START :: Procedure "dm_skb.pkg_rep_aggr.ptb_bbalance_fact" started.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.ptb_bbalance_fact',vMes);

  FOR idx IN 0..vDays
  LOOP

    BEGIN
      EXECUTE IMMEDIATE 'alter table dm_skb.ptb_bbalance_fact truncate partition P'||to_char(inBegDt+idx,'YYYYMMDD');
      vMes := 'SUCCESSFULLY :: Table "dm_skb.ptb_bbalance_fact" altered. Partition P'||to_char(inBegDt+idx,'YYYYMMDD')||' truncated';
    EXCEPTION WHEN OTHERS THEN

      EXECUTE IMMEDIATE 'alter table dm_skb.ptb_bbalance_fact
                            ADD PARTITION P'||to_char(inBegDt+idx,'YYYYMMDD')||' VALUES (to_Date('''||to_char(inBegDt+idx,'DD.MM.YYYY')||''',''DD.MM.YYYY'')) STORAGE(INITIAL 64K NEXT 1M) NOLOGGING';
      vMes := 'SUCCESSFULLY :: Table "dm_skb.ptb_bbalance_fact" altered. Partition P'||to_char(inBegDt+idx,'YYYYMMDD')||' added.';
    END;

    dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.ptb_bbalance_fact',vMes);

    --EXECUTE IMMEDIATE
    INSERT INTO dm_skb.ptb_bbalance_fact
      (as_of_date,dim_key,rule_id,abs_department_id,cur_id,product_id,dim2_id,val,val_prev,val_mb,source_system_id)
      SELECT as_of_date,dim_key,rule_id,abs_department_id,cur_id,product_id,dim2_id,val,val_prev,val_mb,source_system_id
      FROM TABLE(dm_skb.pkg_rep_aggr.get_ptb_bbalance_fact(inBegDt+idx));

    vMes := 'SUCCESSFULLY :: '||SQL%ROWCOUNT||' rows inserted into table "dm_skb.ptb_bbalance_fact".';
    dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.ptb_bbalance_fact',vMes);

    dm_skb.dm_showcase_set_date('BBALANCE_FACT',1,inBegDt+idx);
  END LOOP;

  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "dm_skb.pkg_rep_aggr.ptb_bbalance_fact" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' successfully.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.ptb_bbalance_fact',vMes);
EXCEPTION
  WHEN OTHERS THEN
    vEndTime := SYSDATE;

    vMes := 'ERROR :: Table "dm_skb.ptb_bbalance_fact" aggregation failed :: '||SQLERRM;
    dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.ptb_bbalance_fact',vMes);
    vMes := 'FINISH :: Procedure "dm_skb.pkg_rep_aggr.ptb_bbalance_fact" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' with errors.';
    dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.ptb_bbalance_fact',vMes);
END ptb_bbalance_fact;

PROCEDURE tb_3card_ibso_d_fact (inBegDt IN DATE, inEndDt IN DATE)
  IS
  vDays INTEGER;
  vMes VARCHAR2(2000);
  vBegTime DATE := SYSDATE;
  vEndTime DATE;
BEGIN
  vDays := inEndDt - inBegDt;
  vMes := 'START :: Procedure "dm_skb.pkg_rep_aggr.tb_3card_ibso_d_fact" started.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_3card_ibso_d_fact',vMes);

  FOR idx IN 0..vDays
  LOOP

    DELETE FROM dm_skb.ptb_3card_ibso_d_fact WHERE as_of_date = inBegDt+idx;

    INSERT INTO dm_skb.ptb_3card_ibso_d_fact
    (as_of_date,acc_5_num,account_number,col_id,c3_val,c3s_val,i_val,d1_val,d2_val)
    WITH
      acc AS (
        SELECT /*+ no_index(a UIX_3871148) no_index(a1 UIX_3871148) no_index(a2 UIX_3871148) */
               a.account_gid
              ,a.source_system_id
              ,a.val_str AS account_number
              ,a2.account_gid AS s_account_gid
              ,a2.val_str AS s_account_number
          FROM dwh.ref_account_new a
               INNER JOIN dwh.ref_account_new a1
                 ON a1.column_name = 'SUMMARY_ACCOUNT_SID'
                    AND a1.end_date = to_date('31.12.5999','DD.MM.YYYY')
                    AND a.account_gid = a1.account_gid
                    AND a.source_system_id = a1.source_system_id
                    AND inBegDt+idx BETWEEN a1.effective_start AND a1.effective_end
                    AND NVL(a1.val_num,0) > 10 -- только аналитические счета
               INNER JOIN dwh.ref_account_new a2
                 ON a2.column_name = 'ACCOUNT_NUMBER'
                    AND a2.end_date = to_date('31.12.5999','DD.MM.YYYY')
                    AND a2.account_gid = TRUNC(a1.val_num/10)
                    AND a2.source_system_id = a1.source_system_id
                    AND inBegDt+idx BETWEEN a2.effective_start AND a2.effective_end
          WHERE a.column_name = 'ACCOUNT_NUMBER'
            AND a.end_date = to_date('31.12.5999','DD.MM.YYYY')
            AND a.source_system_id IN (2) -- 3Card-R
            AND inBegDt+idx BETWEEN a.effective_start AND a.effective_end
      )
     ,s_acc AS (
        SELECT acc.s_account_gid AS account_gid
              ,acc.source_system_id
              ,acc.s_account_number AS account_number
          FROM acc
        GROUP BY acc.s_account_gid,acc.source_system_id,acc.s_account_number
      )
     ,i_acc AS (
        SELECT /*+ no_index(a UIX_3871148) no_index(a1 UIX_3871148) */
               a.account_gid
              ,a.source_system_id
              ,a.val_str AS account_number
          FROM dwh.ref_account_new a
               INNER JOIN s_acc
                 ON s_acc.account_number = a.val_str
          WHERE a.column_name = 'ACCOUNT_NUMBER'
            AND a.end_date = to_date('31.12.5999','DD.MM.YYYY')
            AND a.source_system_id IN (1) -- 3Card-R
            AND inBegDt+idx BETWEEN a.effective_start AND a.effective_end
      )
     ,stock AS (
        SELECT /*+ leading(acc) no_index(abt) */
               inBegDt+idx AS as_of_date
              ,SUBSTR(acc.s_account_number,1,5) AS bal_account_id
              ,acc.s_account_number AS account_number
              ,SUM(abt.balance) AS c3_balance
              ,SUM(abt.balance_rur) AS c3_balance_rur
              ,SUM(abt.turn_debit) AS c3_turn_debit
              ,SUM(abt.turn_credit) AS c3_turn_credit
              ,SUM(abt.turn_debit_rur) AS c3_turn_debit_rur
              ,SUM(abt.turn_credit_rur) AS c3_turn_credit_rur
              ,SUM(abt.balance_in) AS c3_balance_in
              ,SUM(abt.balance_in_rur) AS c3_balance_in_rur
              ,NULL AS c3s_balance
              ,NULL AS c3s_balance_rur
              ,NULL AS c3s_turn_debit
              ,NULL AS c3s_turn_credit
              ,NULL AS c3s_turn_debit_rur
              ,NULL AS c3s_turn_credit_rur
              ,NULL AS c3s_balance_in
              ,NULL AS c3s_balance_in_rur
              ,NULL AS i_balance
              ,NULL AS i_balance_rur
              ,NULL AS i_turn_debit
              ,NULL AS i_turn_credit
              ,NULL AS i_turn_debit_rur
              ,NULL AS i_turn_credit_rur
              ,NULL AS i_balance_in
              ,NULL AS i_balance_in_rur
          FROM acc
               INNER JOIN dwh.fct_account_balance_turn abt
                 ON abt.source_system_id IN (2)
                    AND abt.balance_date = inBegDt+idx
                    AND abt.account_sid = acc.account_gid*10+acc.source_system_id
        GROUP BY acc.s_account_number
      )
     ,s_stock AS (
        SELECT /*+ leading(s_acc) no_index(abt) */
               inBegDt+idx AS as_of_date
              ,SUBSTR(s_acc.account_number,1,5) AS bal_account_id
              ,s_acc.account_number
              ,NULL AS c3_balance
              ,NULL AS c3_balance_rur
              ,NULL AS c3_turn_debit
              ,NULL AS c3_turn_credit
              ,NULL AS c3_turn_debit_rur
              ,NULL AS c3_turn_credit_rur
              ,NULL AS c3_balance_in
              ,NULL AS c3_balance_in_rur
              ,abt.balance AS c3s_balance
              ,abt.balance_rur AS c3s_balance_rur
              ,abt.turn_debit AS c3s_turn_debit
              ,abt.turn_credit AS c3s_turn_credit
              ,abt.turn_debit_rur AS c3s_turn_debit_rur
              ,abt.turn_credit_rur AS c3s_turn_credit_rur
              ,abt.balance_in AS c3s_balance_in
              ,abt.balance_in_rur AS c3s_balance_in_rur
              ,NULL AS i_balance
              ,NULL AS i_balance_rur
              ,NULL AS i_turn_debit
              ,NULL AS i_turn_credit
              ,NULL AS i_turn_debit_rur
              ,NULL AS i_turn_credit_rur
              ,NULL AS i_balance_in
              ,NULL AS i_balance_in_rur
          FROM s_acc
               INNER JOIN dwh.fct_account_balance_turn abt
                 ON abt.source_system_id IN (2)
                    AND abt.balance_date = inBegDt+idx
                    AND abt.account_sid = s_acc.account_gid*10+s_acc.source_system_id
      )
     ,i_stock AS (
        SELECT /*+ leading(s_acc) no_index(abt) */
               inBegDt+idx AS as_of_date
              ,SUBSTR(i_acc.account_number,1,5) AS bal_account_id
              ,i_acc.account_number
              ,NULL AS c3_balance
              ,NULL AS c3_balance_rur
              ,NULL AS c3_turn_debit
              ,NULL AS c3_turn_credit
              ,NULL AS c3_turn_debit_rur
              ,NULL AS c3_turn_credit_rur
              ,NULL AS c3_balance_in
              ,NULL AS c3_balance_in_rur
              ,NULL AS c3s_balance
              ,NULL AS c3s_balance_rur
              ,NULL AS c3s_turn_debit
              ,NULL AS c3s_turn_credit
              ,NULL AS c3s_turn_debit_rur
              ,NULL AS c3s_turn_credit_rur
              ,NULL AS c3s_balance_in
              ,NULL AS c3s_balance_in_rur
              ,abt.balance AS i_balance
              ,abt.balance_rur AS i_balance_rur
              ,abt.turn_debit AS i_turn_debit
              ,abt.turn_credit AS i_turn_credit
              ,abt.turn_debit_rur AS i_turn_debit_rur
              ,abt.turn_credit_rur AS i_turn_credit_rur
              ,abt.balance_in AS i_balance_in
              ,abt.balance_in_rur AS i_balance_in_rur
          FROM i_acc
               INNER JOIN dwh.fct_account_balance_turn abt
                 ON abt.source_system_id IN (1)
                    AND abt.balance_date = inBegDt+idx
                    AND abt.account_sid = i_acc.account_gid*10+i_acc.source_system_id
      )
      SELECT *
        FROM (
        SELECT as_of_date AS as_of_date
              ,bal_account_id AS acc_5_symb
              ,account_number
              ,SUM(c3_balance) AS c3_balance
              ,SUM(c3s_balance) AS c3s_balance
              ,SUM(i_balance) AS i_balance
              ,SUM(c3_balance_rur) AS c3_balance_rur
              ,SUM(c3s_balance_rur) AS c3s_balance_rur
              ,SUM(i_balance_rur) AS i_balance_rur
              ,SUM(c3_turn_debit) AS c3_turn_debit
              ,SUM(c3s_turn_debit) AS c3s_turn_debit
              ,SUM(i_turn_debit) AS i_turn_debit
              ,SUM(c3_turn_credit) AS c3_turn_credit
              ,SUM(c3s_turn_credit) AS c3s_turn_credit
              ,SUM(i_turn_credit) AS i_turn_credit
              ,SUM(c3_turn_debit_rur) AS c3_turn_debit_rur
              ,SUM(c3s_turn_debit_rur) AS c3s_turn_debit_rur
              ,SUM(i_turn_debit_rur) AS i_turn_debit_rur
              ,SUM(c3_turn_credit_rur) AS c3_turn_credit_rur
              ,SUM(c3s_turn_credit_rur) AS c3s_turn_credit_rur
              ,SUM(i_turn_credit_rur) AS i_turn_credit_rur
              ,SUM(c3_balance_in) AS c3_balance_in
              ,SUM(c3s_balance_in) AS c3s_balance_in
              ,SUM(i_balance_in) AS i_balance_in
              ,SUM(c3_balance_in_rur) AS c3_balance_in_rur
              ,SUM(c3s_balance_in_rur) AS c3s_balance_in_rur
              ,SUM(i_balance_in_rur) AS i_balance_in_rur
              ,ABS(NVL(SUM(c3_balance),0) - NVL(SUM(c3s_balance),0)) AS d1_balance
              ,ABS(NVL(SUM(c3_balance_rur),0) - NVL(SUM(c3s_balance_rur),0)) AS d1_balance_rur
              ,ABS(NVL(SUM(c3_turn_debit),0) - NVL(SUM(c3s_turn_debit),0)) AS d1_turn_debit
              ,ABS(NVL(SUM(c3_turn_credit),0) - NVL(SUM(c3s_turn_credit),0)) AS d1_turn_credit
              ,ABS(NVL(SUM(c3_turn_debit_rur),0) - NVL(SUM(c3s_turn_debit_rur),0)) AS d1_turn_debit_rur
              ,ABS(NVL(SUM(c3_turn_credit_rur),0) - NVL(SUM(c3s_turn_credit_rur),0)) AS d1_turn_credit_rur
              ,ABS(NVL(SUM(c3_balance_in),0) - NVL(SUM(c3s_balance_in),0)) AS d1_balance_in
              ,ABS(NVL(SUM(c3_balance_in_rur),0) - NVL(SUM(c3s_balance_in_rur),0)) AS d1_balance_in_rur
              --
              ,ABS(NVL(SUM(c3s_balance),0) - NVL(SUM(i_balance),0)) AS d2_balance
              ,ABS(NVL(SUM(c3s_balance_rur),0) - NVL(SUM(i_balance_rur),0)) AS d2_balance_rur
              ,ABS(NVL(SUM(c3s_turn_debit),0) - NVL(SUM(i_turn_debit),0)) AS d2_turn_debit
              ,ABS(NVL(SUM(c3s_turn_credit),0) - NVL(SUM(i_turn_credit),0)) AS d2_turn_credit
              ,ABS(NVL(SUM(c3s_turn_debit_rur),0) - NVL(SUM(i_turn_debit_rur),0)) AS d2_turn_debit_rur
              ,ABS(NVL(SUM(c3s_turn_credit_rur),0) - NVL(SUM(i_turn_credit_rur),0)) AS d2_turn_credit_rur
              ,ABS(NVL(SUM(c3s_balance_in),0) - NVL(SUM(i_balance_in),0)) AS d2_balance_in
              ,ABS(NVL(SUM(c3s_balance_in_rur),0) - NVL(SUM(i_balance_in_rur),0)) AS d2_balance_in_rur
          FROM
        (SELECT stock.as_of_date
               ,stock.bal_account_id
               ,stock.account_number
               ,stock.c3_balance_in
               ,stock.c3_balance_in_rur
               ,stock.c3_turn_debit
               ,stock.c3_turn_debit_rur
               ,stock.c3_turn_credit
               ,stock.c3_turn_credit_rur
               ,stock.c3_balance
               ,stock.c3_balance_rur
               ,s_stock.c3s_balance_in
               ,s_stock.c3s_balance_in_rur
               ,s_stock.c3s_turn_debit
               ,s_stock.c3s_turn_debit_rur
               ,s_stock.c3s_turn_credit
               ,s_stock.c3s_turn_credit_rur
               ,s_stock.c3s_balance
               ,s_stock.c3s_balance_rur
               ,i_stock.i_balance_in
               ,i_stock.i_balance_in_rur
               ,i_stock.i_turn_debit
               ,i_stock.i_turn_debit_rur
               ,i_stock.i_turn_credit
               ,i_stock.i_turn_credit_rur
               ,i_stock.i_balance
               ,i_stock.i_balance_rur
           FROM stock
                LEFT JOIN s_stock ON s_stock.account_number = stock.account_number
                LEFT JOIN i_stock ON i_stock.account_number = stock.account_number
        ) GROUP BY as_of_date,bal_account_id, account_number
          HAVING (SUM(c3_balance) IS NOT NULL OR SUM(c3s_balance) IS NOT NULL) AND
                 (
                 ABS(NVL(SUM(c3_balance),0) - NVL(SUM(c3s_balance),0)) > 0 OR
                 ABS(NVL(SUM(c3_balance_rur),0) - NVL(SUM(c3s_balance_rur),0)) > 0 OR
                 ABS(NVL(SUM(c3_turn_debit),0) - NVL(SUM(c3s_turn_debit),0)) > 0 OR
                 ABS(NVL(SUM(c3_turn_credit),0) - NVL(SUM(c3s_turn_credit),0)) > 0 OR
                 ABS(NVL(SUM(c3_turn_debit_rur),0) - NVL(SUM(c3s_turn_debit_rur),0)) > 0 OR
                 ABS(NVL(SUM(c3_turn_credit_rur),0) - NVL(SUM(c3s_turn_credit_rur),0)) > 0 OR
                 ABS(NVL(SUM(c3_balance_in),0) - NVL(SUM(c3s_balance_in),0)) > 0 OR
                 ABS(NVL(SUM(c3_balance_in_rur),0) - NVL(SUM(c3s_balance_in_rur),0)) > 0 OR
                 --
                 ABS(NVL(SUM(c3_balance),0) - NVL(SUM(i_balance),0)) > 0 OR
                 ABS(NVL(SUM(c3_balance_rur),0) - NVL(SUM(i_balance_rur),0)) > 0 OR
                 ABS(NVL(SUM(c3_turn_debit),0) - NVL(SUM(i_turn_debit),0)) > 0 OR
                 ABS(NVL(SUM(c3_turn_credit),0) - NVL(SUM(i_turn_credit),0)) > 0 OR
                 ABS(NVL(SUM(c3_turn_debit_rur),0) - NVL(SUM(i_turn_debit_rur),0)) > 0 OR
                 ABS(NVL(SUM(c3_turn_credit_rur),0) - NVL(SUM(i_turn_credit_rur),0)) > 0 OR
                 ABS(NVL(SUM(c3_balance_in),0) - NVL(SUM(i_balance_in),0)) > 0 OR
                 ABS(NVL(SUM(c3_balance_in_rur),0) - NVL(SUM(i_balance_in_rur),0)) > 0
                 )
      ) UNPIVOT INCLUDE NULLS ((c3_val,c3s_val,i_val,d1_val,d2_val)
          FOR col_id IN (
            (c3_balance_in,c3s_balance_in,i_balance_in,d1_balance_in,d2_balance_in) AS 'BALANCE_IN',
            (c3_balance_in_rur,c3s_balance_in_rur,i_balance_in_rur,d1_balance_in_rur,d2_balance_in_rur) AS 'BALANCE_IN_RUR',
            (c3_turn_debit,c3s_turn_debit,i_turn_debit,d1_turn_debit,d2_turn_debit) AS 'TURN_DEBIT',
            (c3_turn_debit_rur,c3s_turn_debit_rur,i_turn_debit_rur,d1_turn_debit_rur,d2_turn_debit_rur) AS 'TURN_DEBIT_RUR',
            (c3_turn_credit,c3s_turn_credit,i_turn_credit,d1_turn_credit,d2_turn_credit) AS 'TURN_CREDIT',
            (c3_turn_credit_rur,c3s_turn_credit_rur,i_turn_credit_rur,d1_turn_credit_rur,d2_turn_credit_rur) AS 'TURN_CREDIT_RUR',
            (c3_balance,c3s_balance,i_balance,d1_balance,d2_balance) AS 'BALANCE',
            (c3_balance_rur,c3s_balance_rur,i_balance_rur,d1_balance_rur,d2_balance_rur) AS 'BALANCE_RUR'
          )
        )
;

    vMes := 'SUCCESSFULLY :: '||SQL%ROWCOUNT||' rows inserted into table "dm_skb.tb_3card_ibso_d_fact".';
    dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_3card_ibso_d_fact',vMes);

     dm_skb.dm_showcase_set_date('3CARD_IBSO',1,inBegDt+idx);
 END LOOP;

  vEndTime := SYSDATE;

  vMes := 'FINISH :: Procedure "dm_skb.pkg_rep_aggr.tb_3card_ibso_d_fact" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' successfully.';
  dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_3card_ibso_d_fact',vMes);
EXCEPTION
  WHEN OTHERS THEN
    vEndTime := SYSDATE;

    vMes := 'ERROR :: Table "dm_skb.tb_3card_ibso_d_fact" aggregation failed :: '||SQLERRM;
    dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_3card_ibso_d_fact',vMes);
    vMes := 'FINISH :: Procedure "dm_skb.pkg_rep_aggr.tb_3card_ibso_d_fact" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' with errors.';
    dm_skb.pr_log_write('dm_skb.pkg_rep_aggr.tb_3card_ibso_d_fact',vMes);
END tb_3card_ibso_d_fact;

------------------------------ПРОЦЕДУРЫ ЗАПУСКА ЗАГРУЗКИ--------------------------------------
PROCEDURE load (inBeg IN DATE, inEnd IN DATE, inUnit IN VARCHAR2 DEFAULT NULL)
  IS
    vMes VARCHAR2(2000);
    vBegTime DATE := SYSDATE;
    vEndTime DATE;
BEGIN
  vMes := 'START :: Procedure "dm_skb.pkg_etl_signs.calc" started.';
  dm_skb.pr_log_write('dm_skb.pkg_etl_signs.calc',vMes,1);

  dm_skb.pkg_etl_signs.calc(inBeg,inEnd);
  dm_skb.pkg_etl_signs.pr_log_write('dm_skb.pkg_etl_signs.GetVarValue',dm_skb.pkg_etl_signs.GetVarValue('MartsPlanMessage'));
  vEndTime := SYSDATE;
  vMes := 'FINISH :: Procedure "dm_skb.pkg_etl_signs.calc" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' successfully.';
  dm_skb.pr_log_write('dm_skb.pkg_etl_signs.calc',vMes,1);
EXCEPTION WHEN OTHERS THEN
  vEndTime := SYSDATE;
  vMes := 'ERROR :: Procedure "dm_skb.pkg_etl_signs.calc" :: '||SQLERRM;
  dm_skb.pr_log_write('dm_skb.pkg_etl_signs.calc',vMes);
  vMes := 'FINISH :: Procedure "dm_skb.pkg_etl_signs.calc" finished in '||dm_skb.get_ti_as_hms(vEndTime - vBegTime)||' with errors.';
  dm_skb.pr_log_write('dm_skb.pkg_etl_signs.calc',vMes,1);
END load;

END pkg_rep_aggr;
/

prompt
prompt Creating package body PKG_SKB_PARSER
prompt ====================================
prompt
CREATE OR REPLACE PACKAGE BODY DM_SKB.pkg_skb_parser
IS

FUNCTION parse_ldv_fin_datal (inStr LONG) RETURN tab_ldv_fin_datal PIPELINED
  IS
  rec rec_ldv_fin_datal;
BEGIN
  FOR idx IN (SELECT SUBSTR(a,1,INSTR(a,'=',1)-1) a_name
                    ,SUBSTR(a,INSTR(a,'=',1)+1,LENGTH(a)) a_value
                FROM (SELECT regexp_substr(inStr,'[^~;]+', 1, LEVEL) a
                        FROM dual
                      CONNECT BY instr(inStr, '~;', 1, LEVEL - 1) > 0
                     )
                WHERE a IS NOT NULL
             )
  LOOP
    rec.v1 := idx.a_name;
    rec.v2 := idx.a_value;
    PIPE ROW(rec);
  END LOOP;
END parse_ldv_fin_datal;

FUNCTION parse_str(inStr VARCHAR2,inSeparator IN VARCHAR2) RETURN tabStr PIPELINED
  IS
  rec recStr;
BEGIN
  FOR idx IN (
    SELECT regexp_substr(inStr,'[^'||inSeparator||']+', 1, LEVEL) a
      FROM dual CONNECT BY instr(inStr,inSeparator, 1, LEVEL - 1) > 0
  ) LOOP
    rec.Str := idx.a;
    PIPE ROW(rec);
  END LOOP;
END parse_str;


END pkg_skb_parser;
/

prompt
prompt Creating trigger TB_CALC_POOL_H_TRG
prompt ===================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.TB_CALC_POOL_h_trg AFTER INSERT OR UPDATE OR DELETE ON DM_SKB.TB_CALC_POOL
FOR EACH ROW
DECLARE
  vDML_Type VARCHAR2(1);
  vTableID VARCHAR2(255);
BEGIN
  IF DELETING THEN
    vDML_Type := 'D';
    vTableID := :Old.ID;
  ELSIF INSERTING THEN
    vDML_Type := 'I';
    vTableID := :New.ID;
  ELSE
    vDML_Type := 'U';
    vTableID := :Old.ID;
  END IF;
  IF DELETING OR INSERTING THEN
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_CALC_POOL','CONDITION',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.CONDITION,:New.CONDITION,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_CALC_POOL','DWH_FLG',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.DWH_FLG,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.DWH_FLG,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_CALC_POOL','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_CALC_POOL','CALC_DESCR',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.CALC_DESCR,:New.CALC_DESCR,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_CALC_POOL','ARCHIVE_FLAG',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ARCHIVE_FLAG,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ARCHIVE_FLAG,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_CALC_POOL','E_UNIT',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.E_UNIT,:New.E_UNIT,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_CALC_POOL','PARAMS',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.PARAMS,:New.PARAMS,vTableID);
  ELSE
    IF :Old.CONDITION != :New.CONDITION OR
       :Old.CONDITION IS NULL AND :New.CONDITION IS NOT NULL OR
       :Old.CONDITION IS NOT NULL AND :New.CONDITION IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_CALC_POOL','CONDITION',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.CONDITION,:New.CONDITION,vTableID);
    END IF;
    IF :Old.DWH_FLG != :New.DWH_FLG OR
       :Old.DWH_FLG IS NULL AND :New.DWH_FLG IS NOT NULL OR
       :Old.DWH_FLG IS NOT NULL AND :New.DWH_FLG IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_CALC_POOL','DWH_FLG',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.DWH_FLG,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.DWH_FLG,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.ID != :New.ID OR
       :Old.ID IS NULL AND :New.ID IS NOT NULL OR
       :Old.ID IS NOT NULL AND :New.ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_CALC_POOL','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.CALC_DESCR != :New.CALC_DESCR OR
       :Old.CALC_DESCR IS NULL AND :New.CALC_DESCR IS NOT NULL OR
       :Old.CALC_DESCR IS NOT NULL AND :New.CALC_DESCR IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_CALC_POOL','CALC_DESCR',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.CALC_DESCR,:New.CALC_DESCR,vTableID);
    END IF;
    IF :Old.ARCHIVE_FLAG != :New.ARCHIVE_FLAG OR
       :Old.ARCHIVE_FLAG IS NULL AND :New.ARCHIVE_FLAG IS NOT NULL OR
       :Old.ARCHIVE_FLAG IS NOT NULL AND :New.ARCHIVE_FLAG IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_CALC_POOL','ARCHIVE_FLAG',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ARCHIVE_FLAG,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ARCHIVE_FLAG,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.E_UNIT != :New.E_UNIT OR
       :Old.E_UNIT IS NULL AND :New.E_UNIT IS NOT NULL OR
       :Old.E_UNIT IS NOT NULL AND :New.E_UNIT IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_CALC_POOL','E_UNIT',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.E_UNIT,:New.E_UNIT,vTableID);
    END IF;
    IF :Old.PARAMS != :New.PARAMS OR
       :Old.PARAMS IS NULL AND :New.PARAMS IS NOT NULL OR
       :Old.PARAMS IS NOT NULL AND :New.PARAMS IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_CALC_POOL','PARAMS',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.PARAMS,:New.PARAMS,vTableID);
    END IF;
  END IF;
END;
/

prompt
prompt Creating trigger TB_DEPARTMENTS_LUPD_TRG
prompt ========================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.tb_departments_lupd_trg BEFORE UPDATE ON dm_skb.tb_departments FOR EACH ROW
BEGIN
:NEW.LASTUPDATE := SYSDATE;
END tb_departments_lupd_trg;
/

prompt
prompt Creating trigger TB_EMPLOYEES_LUPD_TRG
prompt ======================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.tb_employees_lupd_trg BEFORE UPDATE ON dm_skb.tb_employees FOR EACH ROW
BEGIN
:NEW.LASTUPDATE := SYSDATE;
END tb_employees_lupd_trg;
/

prompt
prompt Creating trigger TB_EMP_TO_DEP_H_TRG
prompt ====================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.TB_EMP_TO_DEP_h_trg AFTER INSERT OR UPDATE OR DELETE ON DM_SKB.TB_EMP_TO_DEP
FOR EACH ROW
DECLARE
  vDML_Type VARCHAR2(1);
  vTableID VARCHAR2(255);
BEGIN
  IF DELETING THEN
    vDML_Type := 'D';
    vTableID := :Old.ID;
  ELSIF INSERTING THEN
    vDML_Type := 'I';
    vTableID := :New.ID;
  ELSE
    vDML_Type := 'U';
    vTableID := :Old.ID;
  END IF;
  IF DELETING OR INSERTING THEN
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_EMP_TO_DEP','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_EMP_TO_DEP','EMPLOYEE_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.EMPLOYEE_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.EMPLOYEE_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_EMP_TO_DEP','DEP_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.DEP_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.DEP_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
  ELSE
    IF :Old.ID != :New.ID OR
       :Old.ID IS NULL AND :New.ID IS NOT NULL OR
       :Old.ID IS NOT NULL AND :New.ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_EMP_TO_DEP','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.EMPLOYEE_ID != :New.EMPLOYEE_ID OR
       :Old.EMPLOYEE_ID IS NULL AND :New.EMPLOYEE_ID IS NOT NULL OR
       :Old.EMPLOYEE_ID IS NOT NULL AND :New.EMPLOYEE_ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_EMP_TO_DEP','EMPLOYEE_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.EMPLOYEE_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.EMPLOYEE_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.DEP_ID != :New.DEP_ID OR
       :Old.DEP_ID IS NULL AND :New.DEP_ID IS NOT NULL OR
       :Old.DEP_ID IS NOT NULL AND :New.DEP_ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_EMP_TO_DEP','DEP_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.DEP_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.DEP_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
  END IF;
END;
/

prompt
prompt Creating trigger TB_EMP_TO_DEP_LUPD_TRG
prompt =======================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.tb_emp_to_dep_lupd_trg BEFORE UPDATE ON dm_skb.tb_emp_to_dep FOR EACH ROW
BEGIN
:NEW.LASTUPDATE := SYSDATE;
END tb_emp_to_dep_lupd_trg;
/

prompt
prompt Creating trigger TB_FLAGS_POOL_H_TRG
prompt ====================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.TB_FLAGS_POOL_h_trg AFTER INSERT OR UPDATE OR DELETE ON DM_SKB.TB_FLAGS_POOL
FOR EACH ROW
DECLARE
  vDML_Type VARCHAR2(1);
  vTableID VARCHAR2(255);
BEGIN
  IF DELETING THEN
    vDML_Type := 'D';
    vTableID := :Old.ID;
  ELSIF INSERTING THEN
    vDML_Type := 'I';
    vTableID := :New.ID;
  ELSE
    vDML_Type := 'U';
    vTableID := :Old.ID;
  END IF;
  IF DELETING OR INSERTING THEN
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_FLAGS_POOL','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_FLAGS_POOL','NAME',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.NAME,:New.NAME,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_FLAGS_POOL','DT',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.DT,'DD.MM.YYYY HH24:MI:SS'),to_char(:New.DT,'DD.MM.YYYY HH24:MI:SS'),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_FLAGS_POOL','VAL',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.VAL,:New.VAL,vTableID);
  ELSE
    IF :Old.ID != :New.ID OR
       :Old.ID IS NULL AND :New.ID IS NOT NULL OR
       :Old.ID IS NOT NULL AND :New.ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_FLAGS_POOL','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.NAME != :New.NAME OR
       :Old.NAME IS NULL AND :New.NAME IS NOT NULL OR
       :Old.NAME IS NOT NULL AND :New.NAME IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_FLAGS_POOL','NAME',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.NAME,:New.NAME,vTableID);
    END IF;
    IF :Old.DT != :New.DT OR
       :Old.DT IS NULL AND :New.DT IS NOT NULL OR
       :Old.DT IS NOT NULL AND :New.DT IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_FLAGS_POOL','DT',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.DT,'DD.MM.YYYY HH24:MI:SS'),to_char(:New.DT,'DD.MM.YYYY HH24:MI:SS'),vTableID);
    END IF;
    IF :Old.VAL != :New.VAL OR
       :Old.VAL IS NULL AND :New.VAL IS NOT NULL OR
       :Old.VAL IS NOT NULL AND :New.VAL IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_FLAGS_POOL','VAL',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.VAL,:New.VAL,vTableID);
    END IF;
  END IF;
END;
/

prompt
prompt Creating trigger TB_MNG_TASK_H_TRG
prompt ==================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.TB_MNG_TASK_h_trg AFTER INSERT OR UPDATE OR DELETE ON DM_SKB.TB_MNG_TASK
FOR EACH ROW
DECLARE
  vDML_Type VARCHAR2(1);
  vTableID VARCHAR2(255);
BEGIN
  IF DELETING THEN
    vDML_Type := 'D';
    vTableID := :Old.ID;
  ELSIF INSERTING THEN
    vDML_Type := 'I';
    vTableID := :New.ID;
  ELSE
    vDML_Type := 'U';
    vTableID := :Old.ID;
  END IF;
  IF DELETING OR INSERTING THEN
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_MNG_TASK','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_MNG_TASK','DEP_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.DEP_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.DEP_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_MNG_TASK','EMPLOYEE_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.EMPLOYEE_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.EMPLOYEE_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_MNG_TASK','TASK_NAME',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.TASK_NAME,:New.TASK_NAME,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_MNG_TASK','TASK_TARGET',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.TASK_TARGET,:New.TASK_TARGET,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_MNG_TASK','TRACKER_NUM',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.TRACKER_NUM,:New.TRACKER_NUM,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_MNG_TASK','TASK_DESCR',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.TASK_DESCR,:New.TASK_DESCR,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_MNG_TASK','PLAN_BEG_DATE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.PLAN_BEG_DATE,'DD.MM.YYYY HH24:MI:SS'),to_char(:New.PLAN_BEG_DATE,'DD.MM.YYYY HH24:MI:SS'),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_MNG_TASK','PLAN_END_DATE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.PLAN_END_DATE,'DD.MM.YYYY HH24:MI:SS'),to_char(:New.PLAN_END_DATE,'DD.MM.YYYY HH24:MI:SS'),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_MNG_TASK','FACT_BEG_DATE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.FACT_BEG_DATE,'DD.MM.YYYY HH24:MI:SS'),to_char(:New.FACT_BEG_DATE,'DD.MM.YYYY HH24:MI:SS'),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_MNG_TASK','FACT_END_DATE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.FACT_END_DATE,'DD.MM.YYYY HH24:MI:SS'),to_char(:New.FACT_END_DATE,'DD.MM.YYYY HH24:MI:SS'),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_MNG_TASK','TASK_STATUS',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.TASK_STATUS,:New.TASK_STATUS,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_MNG_TASK','TASK_COMMENT',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.TASK_COMMENT,:New.TASK_COMMENT,vTableID);
  ELSE
    IF :Old.ID != :New.ID OR
       :Old.ID IS NULL AND :New.ID IS NOT NULL OR
       :Old.ID IS NOT NULL AND :New.ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_MNG_TASK','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.DEP_ID != :New.DEP_ID OR
       :Old.DEP_ID IS NULL AND :New.DEP_ID IS NOT NULL OR
       :Old.DEP_ID IS NOT NULL AND :New.DEP_ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_MNG_TASK','DEP_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.DEP_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.DEP_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.EMPLOYEE_ID != :New.EMPLOYEE_ID OR
       :Old.EMPLOYEE_ID IS NULL AND :New.EMPLOYEE_ID IS NOT NULL OR
       :Old.EMPLOYEE_ID IS NOT NULL AND :New.EMPLOYEE_ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_MNG_TASK','EMPLOYEE_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.EMPLOYEE_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.EMPLOYEE_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.TASK_NAME != :New.TASK_NAME OR
       :Old.TASK_NAME IS NULL AND :New.TASK_NAME IS NOT NULL OR
       :Old.TASK_NAME IS NOT NULL AND :New.TASK_NAME IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_MNG_TASK','TASK_NAME',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.TASK_NAME,:New.TASK_NAME,vTableID);
    END IF;
    IF :Old.TASK_TARGET != :New.TASK_TARGET OR
       :Old.TASK_TARGET IS NULL AND :New.TASK_TARGET IS NOT NULL OR
       :Old.TASK_TARGET IS NOT NULL AND :New.TASK_TARGET IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_MNG_TASK','TASK_TARGET',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.TASK_TARGET,:New.TASK_TARGET,vTableID);
    END IF;
    IF :Old.TRACKER_NUM != :New.TRACKER_NUM OR
       :Old.TRACKER_NUM IS NULL AND :New.TRACKER_NUM IS NOT NULL OR
       :Old.TRACKER_NUM IS NOT NULL AND :New.TRACKER_NUM IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_MNG_TASK','TRACKER_NUM',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.TRACKER_NUM,:New.TRACKER_NUM,vTableID);
    END IF;
    IF :Old.TASK_DESCR != :New.TASK_DESCR OR
       :Old.TASK_DESCR IS NULL AND :New.TASK_DESCR IS NOT NULL OR
       :Old.TASK_DESCR IS NOT NULL AND :New.TASK_DESCR IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_MNG_TASK','TASK_DESCR',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.TASK_DESCR,:New.TASK_DESCR,vTableID);
    END IF;
    IF :Old.PLAN_BEG_DATE != :New.PLAN_BEG_DATE OR
       :Old.PLAN_BEG_DATE IS NULL AND :New.PLAN_BEG_DATE IS NOT NULL OR
       :Old.PLAN_BEG_DATE IS NOT NULL AND :New.PLAN_BEG_DATE IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_MNG_TASK','PLAN_BEG_DATE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.PLAN_BEG_DATE,'DD.MM.YYYY HH24:MI:SS'),to_char(:New.PLAN_BEG_DATE,'DD.MM.YYYY HH24:MI:SS'),vTableID);
    END IF;
    IF :Old.PLAN_END_DATE != :New.PLAN_END_DATE OR
       :Old.PLAN_END_DATE IS NULL AND :New.PLAN_END_DATE IS NOT NULL OR
       :Old.PLAN_END_DATE IS NOT NULL AND :New.PLAN_END_DATE IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_MNG_TASK','PLAN_END_DATE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.PLAN_END_DATE,'DD.MM.YYYY HH24:MI:SS'),to_char(:New.PLAN_END_DATE,'DD.MM.YYYY HH24:MI:SS'),vTableID);
    END IF;
    IF :Old.FACT_BEG_DATE != :New.FACT_BEG_DATE OR
       :Old.FACT_BEG_DATE IS NULL AND :New.FACT_BEG_DATE IS NOT NULL OR
       :Old.FACT_BEG_DATE IS NOT NULL AND :New.FACT_BEG_DATE IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_MNG_TASK','FACT_BEG_DATE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.FACT_BEG_DATE,'DD.MM.YYYY HH24:MI:SS'),to_char(:New.FACT_BEG_DATE,'DD.MM.YYYY HH24:MI:SS'),vTableID);
    END IF;
    IF :Old.FACT_END_DATE != :New.FACT_END_DATE OR
       :Old.FACT_END_DATE IS NULL AND :New.FACT_END_DATE IS NOT NULL OR
       :Old.FACT_END_DATE IS NOT NULL AND :New.FACT_END_DATE IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_MNG_TASK','FACT_END_DATE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.FACT_END_DATE,'DD.MM.YYYY HH24:MI:SS'),to_char(:New.FACT_END_DATE,'DD.MM.YYYY HH24:MI:SS'),vTableID);
    END IF;
    IF :Old.TASK_STATUS != :New.TASK_STATUS OR
       :Old.TASK_STATUS IS NULL AND :New.TASK_STATUS IS NOT NULL OR
       :Old.TASK_STATUS IS NOT NULL AND :New.TASK_STATUS IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_MNG_TASK','TASK_STATUS',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.TASK_STATUS,:New.TASK_STATUS,vTableID);
    END IF;
    IF :Old.TASK_COMMENT != :New.TASK_COMMENT OR
       :Old.TASK_COMMENT IS NULL AND :New.TASK_COMMENT IS NOT NULL OR
       :Old.TASK_COMMENT IS NOT NULL AND :New.TASK_COMMENT IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_MNG_TASK','TASK_COMMENT',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.TASK_COMMENT,:New.TASK_COMMENT,vTableID);
    END IF;
  END IF;
END;
/

prompt
prompt Creating trigger TB_MNG_TASK_LUPD_TRG
prompt =====================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.TB_MNG_TASK_LUPD_TRG BEFORE UPDATE ON DM_SKB.TB_MNG_TASK FOR EACH ROW
BEGIN
:NEW.LASTUPDATE := SYSDATE;
END TB_MNG_TASK_LUPD_TRG;
/

prompt
prompt Creating trigger TB_PLSQL_REGISTRY_LUPD_TRG
prompt ===========================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.TB_PLSQL_REGISTRY_LUPD_TRG BEFORE INSERT OR UPDATE ON DM_SKB.TB_PLSQL_REGISTRY FOR EACH ROW
BEGIN
:NEW.LASTUPDATE := SYSDATE;
END TB_PLSQL_REGISTRY_LUPD_TRG;
/

prompt
prompt Creating trigger TB_SIGNS_ANLT_H_TRG
prompt ====================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.TB_SIGNS_ANLT_h_trg AFTER INSERT OR UPDATE OR DELETE ON DM_SKB.TB_SIGNS_ANLT
FOR EACH ROW
DECLARE
  vDML_Type VARCHAR2(1);
  vTableID VARCHAR2(255);
BEGIN
  IF DELETING THEN
    vDML_Type := 'D';
    vTableID := :Old.ID;
  ELSIF INSERTING THEN
    vDML_Type := 'I';
    vTableID := :New.ID;
  ELSE
    vDML_Type := 'U';
    vTableID := :Old.ID;
  END IF;
  IF DELETING OR INSERTING THEN
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT','ARCHIVE_FLG',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ARCHIVE_FLG,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ARCHIVE_FLG,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT','ENTITY_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ENTITY_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ENTITY_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT','ANLT_SQL',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.ANLT_SQL,:New.ANLT_SQL,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT','ANLT_ALIAS',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.ANLT_ALIAS,:New.ANLT_ALIAS,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT','DATA_TYPE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.DATA_TYPE,:New.DATA_TYPE,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT','ANLT_ALIAS_DESCR',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.ANLT_ALIAS_DESCR,:New.ANLT_ALIAS_DESCR,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT','SPEC_IMPORT_SQL',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.SPEC_IMPORT_SQL,:New.SPEC_IMPORT_SQL,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT','EFFECTIVE_START',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.EFFECTIVE_START,'DD.MM.YYYY HH24:MI:SS'),to_char(:New.EFFECTIVE_START,'DD.MM.YYYY HH24:MI:SS'),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT','EFFECTIVE_END',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.EFFECTIVE_END,'DD.MM.YYYY HH24:MI:SS'),to_char(:New.EFFECTIVE_END,'DD.MM.YYYY HH24:MI:SS'),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT','ANLT_CODE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.ANLT_CODE,:New.ANLT_CODE,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT','ANLT_NAME',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.ANLT_NAME,:New.ANLT_NAME,vTableID);
  ELSE
    IF :Old.ARCHIVE_FLG != :New.ARCHIVE_FLG OR
       :Old.ARCHIVE_FLG IS NULL AND :New.ARCHIVE_FLG IS NOT NULL OR
       :Old.ARCHIVE_FLG IS NOT NULL AND :New.ARCHIVE_FLG IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT','ARCHIVE_FLG',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ARCHIVE_FLG,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ARCHIVE_FLG,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.ENTITY_ID != :New.ENTITY_ID OR
       :Old.ENTITY_ID IS NULL AND :New.ENTITY_ID IS NOT NULL OR
       :Old.ENTITY_ID IS NOT NULL AND :New.ENTITY_ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT','ENTITY_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ENTITY_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ENTITY_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.ANLT_SQL != :New.ANLT_SQL OR
       :Old.ANLT_SQL IS NULL AND :New.ANLT_SQL IS NOT NULL OR
       :Old.ANLT_SQL IS NOT NULL AND :New.ANLT_SQL IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT','ANLT_SQL',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.ANLT_SQL,:New.ANLT_SQL,vTableID);
    END IF;
    IF :Old.ANLT_ALIAS != :New.ANLT_ALIAS OR
       :Old.ANLT_ALIAS IS NULL AND :New.ANLT_ALIAS IS NOT NULL OR
       :Old.ANLT_ALIAS IS NOT NULL AND :New.ANLT_ALIAS IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT','ANLT_ALIAS',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.ANLT_ALIAS,:New.ANLT_ALIAS,vTableID);
    END IF;
    IF :Old.DATA_TYPE != :New.DATA_TYPE OR
       :Old.DATA_TYPE IS NULL AND :New.DATA_TYPE IS NOT NULL OR
       :Old.DATA_TYPE IS NOT NULL AND :New.DATA_TYPE IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT','DATA_TYPE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.DATA_TYPE,:New.DATA_TYPE,vTableID);
    END IF;
    IF :Old.ANLT_ALIAS_DESCR != :New.ANLT_ALIAS_DESCR OR
       :Old.ANLT_ALIAS_DESCR IS NULL AND :New.ANLT_ALIAS_DESCR IS NOT NULL OR
       :Old.ANLT_ALIAS_DESCR IS NOT NULL AND :New.ANLT_ALIAS_DESCR IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT','ANLT_ALIAS_DESCR',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.ANLT_ALIAS_DESCR,:New.ANLT_ALIAS_DESCR,vTableID);
    END IF;
    IF :Old.SPEC_IMPORT_SQL != :New.SPEC_IMPORT_SQL OR
       :Old.SPEC_IMPORT_SQL IS NULL AND :New.SPEC_IMPORT_SQL IS NOT NULL OR
       :Old.SPEC_IMPORT_SQL IS NOT NULL AND :New.SPEC_IMPORT_SQL IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT','SPEC_IMPORT_SQL',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.SPEC_IMPORT_SQL,:New.SPEC_IMPORT_SQL,vTableID);
    END IF;
    IF :Old.ID != :New.ID OR
       :Old.ID IS NULL AND :New.ID IS NOT NULL OR
       :Old.ID IS NOT NULL AND :New.ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.EFFECTIVE_START != :New.EFFECTIVE_START OR
       :Old.EFFECTIVE_START IS NULL AND :New.EFFECTIVE_START IS NOT NULL OR
       :Old.EFFECTIVE_START IS NOT NULL AND :New.EFFECTIVE_START IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT','EFFECTIVE_START',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.EFFECTIVE_START,'DD.MM.YYYY HH24:MI:SS'),to_char(:New.EFFECTIVE_START,'DD.MM.YYYY HH24:MI:SS'),vTableID);
    END IF;
    IF :Old.EFFECTIVE_END != :New.EFFECTIVE_END OR
       :Old.EFFECTIVE_END IS NULL AND :New.EFFECTIVE_END IS NOT NULL OR
       :Old.EFFECTIVE_END IS NOT NULL AND :New.EFFECTIVE_END IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT','EFFECTIVE_END',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.EFFECTIVE_END,'DD.MM.YYYY HH24:MI:SS'),to_char(:New.EFFECTIVE_END,'DD.MM.YYYY HH24:MI:SS'),vTableID);
    END IF;
    IF :Old.ANLT_CODE != :New.ANLT_CODE OR
       :Old.ANLT_CODE IS NULL AND :New.ANLT_CODE IS NOT NULL OR
       :Old.ANLT_CODE IS NOT NULL AND :New.ANLT_CODE IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT','ANLT_CODE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.ANLT_CODE,:New.ANLT_CODE,vTableID);
    END IF;
    IF :Old.ANLT_NAME != :New.ANLT_NAME OR
       :Old.ANLT_NAME IS NULL AND :New.ANLT_NAME IS NOT NULL OR
       :Old.ANLT_NAME IS NOT NULL AND :New.ANLT_NAME IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT','ANLT_NAME',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.ANLT_NAME,:New.ANLT_NAME,vTableID);
    END IF;
  END IF;
END;
/

prompt
prompt Creating trigger TB_SIGNS_ANLT_SPE_H_TRG
prompt ========================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.TB_SIGNS_ANLT_SPE_h_trg AFTER INSERT OR UPDATE OR DELETE ON DM_SKB.TB_SIGNS_ANLT_SPEC
FOR EACH ROW
DECLARE
  vDML_Type VARCHAR2(1);
  vTableID VARCHAR2(255);
BEGIN
  IF DELETING THEN
    vDML_Type := 'D';
    vTableID := :Old.ID;
  ELSIF INSERTING THEN
    vDML_Type := 'I';
    vTableID := :New.ID;
  ELSE
    vDML_Type := 'U';
    vTableID := :Old.ID;
  END IF;
  IF DELETING OR INSERTING THEN
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT_SPEC','ANLT_SPEC_VAL',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.ANLT_SPEC_VAL,:New.ANLT_SPEC_VAL,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT_SPEC','PARENT_VAL',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.PARENT_VAL,:New.PARENT_VAL,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT_SPEC','CONDITION',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.CONDITION,:New.CONDITION,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT_SPEC','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT_SPEC','ANLT_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ANLT_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ANLT_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_ANLT_SPEC','ANLT_SPEC_NAME',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.ANLT_SPEC_NAME,:New.ANLT_SPEC_NAME,vTableID);
  ELSE
    IF :Old.ANLT_SPEC_VAL != :New.ANLT_SPEC_VAL OR
       :Old.ANLT_SPEC_VAL IS NULL AND :New.ANLT_SPEC_VAL IS NOT NULL OR
       :Old.ANLT_SPEC_VAL IS NOT NULL AND :New.ANLT_SPEC_VAL IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT_SPEC','ANLT_SPEC_VAL',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.ANLT_SPEC_VAL,:New.ANLT_SPEC_VAL,vTableID);
    END IF;
    IF :Old.PARENT_VAL != :New.PARENT_VAL OR
       :Old.PARENT_VAL IS NULL AND :New.PARENT_VAL IS NOT NULL OR
       :Old.PARENT_VAL IS NOT NULL AND :New.PARENT_VAL IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT_SPEC','PARENT_VAL',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.PARENT_VAL,:New.PARENT_VAL,vTableID);
    END IF;
    IF :Old.CONDITION != :New.CONDITION OR
       :Old.CONDITION IS NULL AND :New.CONDITION IS NOT NULL OR
       :Old.CONDITION IS NOT NULL AND :New.CONDITION IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT_SPEC','CONDITION',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.CONDITION,:New.CONDITION,vTableID);
    END IF;
    IF :Old.ID != :New.ID OR
       :Old.ID IS NULL AND :New.ID IS NOT NULL OR
       :Old.ID IS NOT NULL AND :New.ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT_SPEC','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.ANLT_ID != :New.ANLT_ID OR
       :Old.ANLT_ID IS NULL AND :New.ANLT_ID IS NOT NULL OR
       :Old.ANLT_ID IS NOT NULL AND :New.ANLT_ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT_SPEC','ANLT_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ANLT_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ANLT_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.ANLT_SPEC_NAME != :New.ANLT_SPEC_NAME OR
       :Old.ANLT_SPEC_NAME IS NULL AND :New.ANLT_SPEC_NAME IS NOT NULL OR
       :Old.ANLT_SPEC_NAME IS NOT NULL AND :New.ANLT_SPEC_NAME IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_ANLT_SPEC','ANLT_SPEC_NAME',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.ANLT_SPEC_NAME,:New.ANLT_SPEC_NAME,vTableID);
    END IF;
  END IF;
END;
/

prompt
prompt Creating trigger TB_SIGNS_CALC_STAT_ID_TRG
prompt ==========================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.tb_signs_calc_stat_id_trg BEFORE INSERT ON dm_skb.tb_signs_calc_stat
FOR EACH ROW
BEGIN
  SELECT tb_signs_calc_stat_id_seq.nextval INTO :NEW.id FROM dual;
END tb_signs_calc_stat_id_trg;
/

prompt
prompt Creating trigger TB_SIGNS_GROUP_H_TRG
prompt =====================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.TB_SIGNS_GROUP_h_trg AFTER INSERT OR UPDATE OR DELETE ON DM_SKB.TB_SIGNS_GROUP
FOR EACH ROW
DECLARE
  vDML_Type VARCHAR2(1);
  vTableID VARCHAR2(255);
BEGIN
  IF DELETING THEN
    vDML_Type := 'D';
    vTableID := :Old.GROUP_ID;
  ELSIF INSERTING THEN
    vDML_Type := 'I';
    vTableID := :New.GROUP_ID;
  ELSE
    vDML_Type := 'U';
    vTableID := :Old.GROUP_ID;
  END IF;
  IF DELETING OR INSERTING THEN
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_GROUP','STRG_PERIOD',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.STRG_PERIOD,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.STRG_PERIOD,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_GROUP','STRG_PERIOD_TYPE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.STRG_PERIOD_TYPE,:New.STRG_PERIOD_TYPE,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_GROUP','GROUP_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.GROUP_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.GROUP_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_GROUP','GROUP_NAME',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.GROUP_NAME,:New.GROUP_NAME,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_GROUP','PARENT_GROUP_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.PARENT_GROUP_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.PARENT_GROUP_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
  ELSE
    IF :Old.STRG_PERIOD != :New.STRG_PERIOD OR
       :Old.STRG_PERIOD IS NULL AND :New.STRG_PERIOD IS NOT NULL OR
       :Old.STRG_PERIOD IS NOT NULL AND :New.STRG_PERIOD IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_GROUP','STRG_PERIOD',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.STRG_PERIOD,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.STRG_PERIOD,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.STRG_PERIOD_TYPE != :New.STRG_PERIOD_TYPE OR
       :Old.STRG_PERIOD_TYPE IS NULL AND :New.STRG_PERIOD_TYPE IS NOT NULL OR
       :Old.STRG_PERIOD_TYPE IS NOT NULL AND :New.STRG_PERIOD_TYPE IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_GROUP','STRG_PERIOD_TYPE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.STRG_PERIOD_TYPE,:New.STRG_PERIOD_TYPE,vTableID);
    END IF;
    IF :Old.GROUP_ID != :New.GROUP_ID OR
       :Old.GROUP_ID IS NULL AND :New.GROUP_ID IS NOT NULL OR
       :Old.GROUP_ID IS NOT NULL AND :New.GROUP_ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_GROUP','GROUP_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.GROUP_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.GROUP_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.GROUP_NAME != :New.GROUP_NAME OR
       :Old.GROUP_NAME IS NULL AND :New.GROUP_NAME IS NOT NULL OR
       :Old.GROUP_NAME IS NOT NULL AND :New.GROUP_NAME IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_GROUP','GROUP_NAME',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.GROUP_NAME,:New.GROUP_NAME,vTableID);
    END IF;
    IF :Old.PARENT_GROUP_ID != :New.PARENT_GROUP_ID OR
       :Old.PARENT_GROUP_ID IS NULL AND :New.PARENT_GROUP_ID IS NOT NULL OR
       :Old.PARENT_GROUP_ID IS NOT NULL AND :New.PARENT_GROUP_ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_GROUP','PARENT_GROUP_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.PARENT_GROUP_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.PARENT_GROUP_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
  END IF;
END;
/

prompt
prompt Creating trigger TB_SIGNS_HISTORY_ID_TRG
prompt ========================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.tb_signs_history_id_trg BEFORE INSERT ON dm_skb.tb_signs_history FOR EACH ROW
BEGIN
  SELECT tb_signs_history_id_seq.nextval INTO :New.id FROM dual;
END tb_signs_history_id_trg;
/

prompt
prompt Creating trigger TB_SIGNS_JOB_LAST_UPD_TRG
prompt ==========================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.tb_signs_job_last_upd_trg BEFORE INSERT OR UPDATE ON dm_Skb.Tb_Signs_Job
FOR EACH ROW
BEGIN
  SELECT SYSDATE INTO :NEW.last_update FROM dual;
END tb_signs_job_last_upd_trg;
/

prompt
prompt Creating trigger TB_SIGNS_LOG_ID_TRG
prompt ====================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.tb_signs_log_id_trg BEFORE INSERT ON dm_skb.tb_signs_log FOR EACH ROW
BEGIN SELECT dm_skb.tb_signs_log_id_seq.nextval INTO :NEW.id FROM dual; END tb_signs_log_id_trg;
/

prompt
prompt Creating trigger TB_SIGNS_POOL_H_TRG
prompt ====================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.TB_SIGNS_POOL_h_trg AFTER INSERT OR UPDATE OR DELETE ON DM_SKB.TB_SIGNS_POOL
FOR EACH ROW
DECLARE
  vDML_Type VARCHAR2(1);
  vTableID VARCHAR2(255);
BEGIN
  IF DELETING THEN
    vDML_Type := 'D';
    vTableID := :Old.id;
  ELSIF INSERTING THEN
    vDML_Type := 'I';
    vTableID := :New.id;
  ELSE
    vDML_Type := 'U';
    vTableID := :Old.id;
  END IF;
  IF DELETING OR INSERTING THEN
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_POOL','EXT_PLSQL',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.EXT_PLSQL,:New.EXT_PLSQL,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_POOL','ENTITY_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ENTITY_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ENTITY_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_POOL','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_POOL','SIGN_NAME',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.SIGN_NAME,:New.SIGN_NAME,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_POOL','SIGN_DESCR',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.SIGN_DESCR,:New.SIGN_DESCR,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_POOL','ARCHIVE_FLG',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ARCHIVE_FLG,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ARCHIVE_FLG,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_POOL','DATA_TYPE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.DATA_TYPE,:New.DATA_TYPE,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_POOL','SP_CODE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.SP_CODE,:New.SP_CODE,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_POOL','HIST_FLG',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.HIST_FLG,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.HIST_FLG,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_POOL','SIGN_SQL',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.SIGN_SQL,:New.SIGN_SQL,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_SIGNS_POOL','MASS_SQL',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.MASS_SQL,:New.MASS_SQL,vTableID);
  ELSE
    IF :Old.EXT_PLSQL != :New.EXT_PLSQL OR
       :Old.EXT_PLSQL IS NULL AND :New.EXT_PLSQL IS NOT NULL OR
       :Old.EXT_PLSQL IS NOT NULL AND :New.EXT_PLSQL IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_POOL','EXT_PLSQL',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.EXT_PLSQL,:New.EXT_PLSQL,vTableID);
    END IF;
    IF :Old.ENTITY_ID != :New.ENTITY_ID OR
       :Old.ENTITY_ID IS NULL AND :New.ENTITY_ID IS NOT NULL OR
       :Old.ENTITY_ID IS NOT NULL AND :New.ENTITY_ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_POOL','ENTITY_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ENTITY_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ENTITY_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.ID != :New.ID OR
       :Old.ID IS NULL AND :New.ID IS NOT NULL OR
       :Old.ID IS NOT NULL AND :New.ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_POOL','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.SIGN_NAME != :New.SIGN_NAME OR
       :Old.SIGN_NAME IS NULL AND :New.SIGN_NAME IS NOT NULL OR
       :Old.SIGN_NAME IS NOT NULL AND :New.SIGN_NAME IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_POOL','SIGN_NAME',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.SIGN_NAME,:New.SIGN_NAME,vTableID);
    END IF;
    IF :Old.SIGN_DESCR != :New.SIGN_DESCR OR
       :Old.SIGN_DESCR IS NULL AND :New.SIGN_DESCR IS NOT NULL OR
       :Old.SIGN_DESCR IS NOT NULL AND :New.SIGN_DESCR IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_POOL','SIGN_DESCR',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.SIGN_DESCR,:New.SIGN_DESCR,vTableID);
    END IF;
    IF :Old.ARCHIVE_FLG != :New.ARCHIVE_FLG OR
       :Old.ARCHIVE_FLG IS NULL AND :New.ARCHIVE_FLG IS NOT NULL OR
       :Old.ARCHIVE_FLG IS NOT NULL AND :New.ARCHIVE_FLG IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_POOL','ARCHIVE_FLG',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ARCHIVE_FLG,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ARCHIVE_FLG,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.DATA_TYPE != :New.DATA_TYPE OR
       :Old.DATA_TYPE IS NULL AND :New.DATA_TYPE IS NOT NULL OR
       :Old.DATA_TYPE IS NOT NULL AND :New.DATA_TYPE IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_POOL','DATA_TYPE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.DATA_TYPE,:New.DATA_TYPE,vTableID);
    END IF;
    IF :Old.SP_CODE != :New.SP_CODE OR
       :Old.SP_CODE IS NULL AND :New.SP_CODE IS NOT NULL OR
       :Old.SP_CODE IS NOT NULL AND :New.SP_CODE IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_POOL','SP_CODE',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.SP_CODE,:New.SP_CODE,vTableID);
    END IF;
    IF :Old.HIST_FLG != :New.HIST_FLG OR
       :Old.HIST_FLG IS NULL AND :New.HIST_FLG IS NOT NULL OR
       :Old.HIST_FLG IS NOT NULL AND :New.HIST_FLG IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_POOL','HIST_FLG',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.HIST_FLG,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.HIST_FLG,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.SIGN_SQL != :New.SIGN_SQL OR
       :Old.SIGN_SQL IS NULL AND :New.SIGN_SQL IS NOT NULL OR
       :Old.SIGN_SQL IS NOT NULL AND :New.SIGN_SQL IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_POOL','SIGN_SQL',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.SIGN_SQL,:New.SIGN_SQL,vTableID);
    END IF;
    IF :Old.MASS_SQL != :New.MASS_SQL OR
       :Old.MASS_SQL IS NULL AND :New.MASS_SQL IS NOT NULL OR
       :Old.MASS_SQL IS NOT NULL AND :New.MASS_SQL IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_SIGNS_POOL','MASS_SQL',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.MASS_SQL,:New.MASS_SQL,vTableID);
    END IF;
  END IF;
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

prompt
prompt Creating trigger TB_SIGNS_POOL_ID_TRG
prompt =====================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.tb_signs_pool_id_trg BEFORE INSERT ON dm_skb.tb_signs_pool FOR EACH ROW
BEGIN
  SELECT tb_signs_pool_id_seq.nextval INTO :New.id FROM dual;
  SELECT 'SP'||LPAD(to_char(:New.id),4,'0') INTO :new.sp_code FROM dual;
END;
/

prompt
prompt Creating trigger TB_SIGNS_POOL_LUPD_TRG
prompt =======================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.tb_signs_pool_lupd_trg BEFORE UPDATE ON dm_skb.tb_signs_pool FOR EACH ROW
BEGIN
:NEW.LASTUPDATE := SYSDATE;
END tb_signs_pool_lupd_trg;
/

prompt
prompt Creating trigger TB_TATTR_LUPD_TRG
prompt ==================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.TB_TATTR_LUPD_TRG BEFORE UPDATE ON DM_SKB.TB_TATTR FOR EACH ROW
BEGIN
:NEW.LASTUPDATE := SYSDATE;
END TB_TATTR_LUPD_TRG;
/

prompt
prompt Creating trigger TB_UROLE_REGISTRY_H_TRG
prompt ========================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.TB_UROLE_REGISTRY_h_trg AFTER INSERT OR UPDATE OR DELETE ON DM_SKB.TB_UROLE_REGISTRY
FOR EACH ROW
DECLARE
  vDML_Type VARCHAR2(1);
  vTableID VARCHAR2(255);
BEGIN
  IF DELETING THEN
    vDML_Type := 'D';
    vTableID := :Old.ID;
  ELSIF INSERTING THEN
    vDML_Type := 'I';
    vTableID := :New.ID;
  ELSE
    vDML_Type := 'U';
    vTableID := :Old.ID;
  END IF;
  IF DELETING OR INSERTING THEN
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_UROLE_REGISTRY','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_UROLE_REGISTRY','USER_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.USER_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.USER_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_UROLE_REGISTRY','ROLE_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ROLE_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ROLE_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
  ELSE
    IF :Old.ID != :New.ID OR
       :Old.ID IS NULL AND :New.ID IS NOT NULL OR
       :Old.ID IS NOT NULL AND :New.ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_UROLE_REGISTRY','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.USER_ID != :New.USER_ID OR
       :Old.USER_ID IS NULL AND :New.USER_ID IS NOT NULL OR
       :Old.USER_ID IS NOT NULL AND :New.USER_ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_UROLE_REGISTRY','USER_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.USER_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.USER_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.ROLE_ID != :New.ROLE_ID OR
       :Old.ROLE_ID IS NULL AND :New.ROLE_ID IS NOT NULL OR
       :Old.ROLE_ID IS NOT NULL AND :New.ROLE_ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_UROLE_REGISTRY','ROLE_ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ROLE_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ROLE_ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
  END IF;
END;
/

prompt
prompt Creating trigger TB_USER_REGISTRY_H_TRG
prompt =======================================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.TB_USER_REGISTRY_h_trg AFTER INSERT OR UPDATE OR DELETE ON DM_SKB.TB_USER_REGISTRY
FOR EACH ROW
DECLARE
  vDML_Type VARCHAR2(1);
  vTableID VARCHAR2(255);
BEGIN
  IF DELETING THEN
    vDML_Type := 'D';
    vTableID := :Old.ID;
  ELSIF INSERTING THEN
    vDML_Type := 'I';
    vTableID := :New.ID;
  ELSE
    vDML_Type := 'U';
    vTableID := :Old.ID;
  END IF;
  IF DELETING OR INSERTING THEN
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_USER_REGISTRY','MAIL_DOMAIN',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.MAIL_DOMAIN,:New.MAIL_DOMAIN,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_USER_REGISTRY','AD_LOGIN',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.AD_LOGIN,:New.AD_LOGIN,vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_USER_REGISTRY','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
      VALUES('DM_SKB.TB_USER_REGISTRY','USER_NAME',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.USER_NAME,:New.USER_NAME,vTableID);
  ELSE
    IF :Old.MAIL_DOMAIN != :New.MAIL_DOMAIN OR
       :Old.MAIL_DOMAIN IS NULL AND :New.MAIL_DOMAIN IS NOT NULL OR
       :Old.MAIL_DOMAIN IS NOT NULL AND :New.MAIL_DOMAIN IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_USER_REGISTRY','MAIL_DOMAIN',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.MAIL_DOMAIN,:New.MAIL_DOMAIN,vTableID);
    END IF;
    IF :Old.AD_LOGIN != :New.AD_LOGIN OR
       :Old.AD_LOGIN IS NULL AND :New.AD_LOGIN IS NOT NULL OR
       :Old.AD_LOGIN IS NOT NULL AND :New.AD_LOGIN IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_USER_REGISTRY','AD_LOGIN',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.AD_LOGIN,:New.AD_LOGIN,vTableID);
    END IF;
    IF :Old.ID != :New.ID OR
       :Old.ID IS NULL AND :New.ID IS NOT NULL OR
       :Old.ID IS NOT NULL AND :New.ID IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_USER_REGISTRY','ID',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,to_char(:Old.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),to_char(:New.ID,'FM999999999999999D999999999','nls_numeric_characters='', '''),vTableID);
    END IF;
    IF :Old.USER_NAME != :New.USER_NAME OR
       :Old.USER_NAME IS NULL AND :New.USER_NAME IS NOT NULL OR
       :Old.USER_NAME IS NOT NULL AND :New.USER_NAME IS NULL
      THEN
        INSERT INTO tb_signs_history (table_name,col_name,dt,os_user,ip_addr,dml_type,old_val,new_val,table_id)
          VALUES('DM_SKB.TB_USER_REGISTRY','USER_NAME',SYSDATE,sys_context('userenv','OS_USER'),sys_context('userenv','IP_ADDRESS'),vDML_Type,:Old.USER_NAME,:New.USER_NAME,vTableID);
    END IF;
  END IF;
END;
/

prompt
prompt Creating trigger T_LOG_ID_TRG
prompt =============================
prompt
CREATE OR REPLACE TRIGGER DM_SKB.t_log_id_trg BEFORE INSERT ON dm_skb.t_log FOR EACH ROW
BEGIN
  SELECT dm_skb.t_log_id_seq.nextval INTO :NEW.id FROM dual;
END t_log_id_trg;
/


spool off
